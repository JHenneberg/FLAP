var tipuesearch = {"pages":[{"text":"FLAP FLAP FLAP, Fortran command Line Arguments Parser for poor people A KISS pure Fortran Library for building powerful, easy-to-use, elegant command line interfaces FLAP is a pure Fortran (KISS) library for building easily nice Command Line Interfaces (CLI) for modern Fortran projects; FLAP is Fortran 2003+ standard compliant; FLAP is OOP designed; FLAP is a Free, Open Source Project. Table of Contents What is FLAP? Main features Copyrights Documentation A Taste of FLAP Issues Compiler Support What is FLAP? Modern Fortran standards (2003+) have introduced support for Command Line Arguments (CLA), thus it is possible to construct nice and effective Command Line Interfaces (CLI). FLAP is a small library designed to simplify the (repetitive) construction of complicated CLI in pure Fortran (standard 2003+). FLAP has been inspired by the python module argparse trying to mimic it. Once you have defined the arguments that are required by means of a user-friendly method of the CLI, FLAP will parse the CLAs for you. It is worthy of note that FLAP, as argparse , also automatically generates help and usage messages and issues errors when users give the program invalid arguments. Go to Top Main features FLAP is inspired by the python great module argparse , thus many features are taken from it. Here the main features are listed. User-friendly methods for building flexible and effective Command Line Interfaces (CLI); comprehensive Command Line Arguments (CLA) support: support optional and non optional CLA; support boolean CLA; support positional CLA; support list of allowable values for defined CLA with automatic consistency check; support multiple valued (list of values, aka list-valued) CLA: compiletime sized list, e.g. nargs='3' ; runtime sized list with at least 1 value, e.g. nargs='+' ; runtime sized list with any size, even empty, e.g. nargs='*' ; support mutually exclusive CLAs; self-consistency-check of CLA definition; support fake CLAs input from a string; support fake CLAs input from environment variables; comprehensive command (group of CLAs) support: support nested subcommands; support mutually exclusive commands; self-consistency-check of command definition; automatic generation of help and usage messages; consistency-check of whole CLI definition; errors trapping for invalid CLI usage; POSIX style compliant; automatic generation of MAN PAGE using your CLI definition!; replicate all the useful features of argparse ; implement docopt features. implement click features. Any feature request is welcome. Go to Top Copyrights FLAP is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FLAP is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FLAP documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FLAP Running the provided test program, Test_Driver -h , a taste of FLAP is served: usage:  Test_Driver [value] --string value [--integer value] [--real value] [--boolean] [--boolean_val value] [--integer_list value#1 value#2 value#3] [--help] [--version]\n\nToy program for testing FLAP\n\nRequired switches:\n   --string value, -s value\n          String input\n\nOptional switches:\n   value\n          1-th argument\n          default value 1.0\n          Positional real input\n   --integer value, -i value, value in: (1,3,5)\n          default value 1\n          Integer input with fixed range\n   --real value, -r value\n          default value 1.0\n          Real input\n   --boolean, -b\n          default value .false.\n          Boolean input\n   --boolean_val value, -bv value\n          default value .true.\n          Valued boolean input\n   --integer_list value#1 value#2 value#3, -il value#1 value#2 value#3\n          default value 1 8 32\n          Integer list input\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nExamples:\n   Test_Driver -s 'Hello FLAP'\n   Test_Driver -s 'Hello FLAP' -i -2 # printing error...\n   Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0\n   Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87\n   Test_Driver 33.0 -s 'Hello FLAP' -i 5\n   Test_Driver --string 'Hello FLAP' --boolean Not so bad for just a very few statements as the following: ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP' , & examples = [ \"Test_Driver -s 'Hello FLAP'                          \" ,& \"Test_Driver -s 'Hello FLAP' -i -2 # printing error...\" ,& \"Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0            \" ,& \"Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87  \" ,& \"Test_Driver 33.0 -s 'Hello FLAP' -i 5                \" ,& \"Test_Driver --string 'Hello FLAP' --boolean          \" ]) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) For more details, see the provided example . For a practical example of FLAP usage see POG source file at line 85 . Nested (sub)commands FLAP fully supports nested (sub)commands or groups of command line arguments. For example a fake git toy remake can be coded as ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver_Nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'Test_Driver_Nested                      ' ,& 'Test_Driver_Nested -h                   ' ,& 'Test_Driver_Nested init                 ' ,& 'Test_Driver_Nested commit -m \"fix bug-1\"' ,& 'Test_Driver_Nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif that when invoked without arguments prompts: cowardly you are doing nothing... try at least \"-h\" option! and invoked with -h option gives: usage: Test_Driver_Nested [ --authors ] [ --help ] [ --version ] { init,commit,tag } ...\n\nToy program for testing FLAP with nested commands\n\nOptional switches:\n   --authors, -a\n          default value .false.\n          Print authors names\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nCommands:\n  init\n          fake init versioning\n  commit\n          fake commit changes to current branch\n  tag\n          fake tag current commit\n\nFor more detailed commands help try:\n  Test_Driver_Nested init -h,--help\n  Test_Driver_Nested commit -h,--help\n  Test_Driver_Nested tag -h,--help\n\nExamples:\n   Test_Driver_Nested\n   Test_Driver_Nested -h\n   Test_Driver_Nested init\n   Test_Driver_Nested commit -m \"fix bug-1\" Test_Driver_Nested tag -a \"v2.1.5\" For more details, see the provided example . Go to Top Developer Info Stefano Zaghi","tags":"home","loc":"index.html","title":" FLAP "},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program Test_Driver_Nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- authors_print = . false . ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver_Nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'Test_Driver_Nested                      ' ,& 'Test_Driver_Nested -h                   ' ,& 'Test_Driver_Nested init                 ' ,& 'Test_Driver_Nested commit -m \"fix bug-1\"' ,& 'Test_Driver_Nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver_Nested","tags":"","loc":"sourcefile/test_driver_nested.f90.html","title":"Test_Driver_Nested.f90 – FLAP"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program Test_Driver !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP' , & examples = [ \"Test_Driver -s 'Hello FLAP'                               \" , & \"Test_Driver -s 'Hello FLAP' -i -2 # printing error...     \" , & \"Test_Driver -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"Test_Driver 33.0 -s 'Hello FLAP' -i 5                     \" , & \"Test_Driver --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parsing Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set Test_Driver behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Test_Driver has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"sourcefile/test_driver_args_from_string.f90.html","title":"Test_Driver_Args_From_String.f90 – FLAP"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program Test_Driver !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"Test_Driver -s 'Hello FLAP'                               \" , & \"Test_Driver -s 'Hello FLAP' -i -2 # printing error...     \" , & \"Test_Driver -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"Test_Driver -s 'Hello FLAP' --man_file FLAP.1             \" , & \"Test_Driver 33.0 -s 'Hello FLAP' -i 5                     \" , & \"Test_Driver --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'Test_Driver.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set Test_Driver behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Test_Driver has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str (. true ., l )) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str (. true ., l )) // ') = ' // garbage ( l ) enddo endif if ( cli % passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"sourcefile/test_driver.f90.html","title":"Test_Driver.f90 – FLAP"},{"text":"Pure Fortran (2003+) library for ensuring codes portability Source Code !< Pure Fortran (2003+) library for ensuring codes portability module IR_Precision !----------------------------------------------------------------------------------------------------------------------------------- !< Pure Fortran (2003+) library for ensuring codes portability !<{!README-IR_Precision.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT ! Standard output/error logical units. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: endianL , endianB , endian public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: NRknd , RPl , FRl public :: NIknd , RIl , FIl public :: check_endian public :: bit_size , byte_size public :: str , strz , cton , bstr , bcton public :: digit public :: ir_initialized , IR_Init public :: IR_Print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: ir_initialized = . false . !< Flag for chcecking the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). ! The following are the portable kind parameters available. ! Real precision definitions: #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. ! Integer precision definitions: integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. ! Format parameters useful for writing in a well-ascii-format numeric variables. ! Real output formats: character ( 10 ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P variable. character ( 10 ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P variable. character ( 9 ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P variable. character ( 10 ), parameter :: FR_P = FR8P !< Output format for kind=R_P variable. ! Real number of digits of output formats: integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. ! Integer output formats: character ( 5 ), parameter :: FI8P = '(I20)' !< Output format                     for kind=I8P variable. character ( 8 ), parameter :: FI8PZP = '(I20.19)' !< Output format with zero prefixing for kind=I8P variable. character ( 5 ), parameter :: FI4P = '(I11)' !< Output format                     for kind=I4P variable. character ( 8 ), parameter :: FI4PZP = '(I11.10)' !< Output format with zero prefixing for kind=I4P variable. character ( 4 ), parameter :: FI2P = '(I6)' !< Output format                     for kind=I2P variable. character ( 6 ), parameter :: FI2PZP = '(I6.5)' !< Output format with zero prefixing for kind=I2P variable. character ( 4 ), parameter :: FI1P = '(I4)' !< Output format                     for kind=I1P variable. character ( 6 ), parameter :: FI1PZP = '(I4.3)' !< Output format with zero prefixing for kind=I1P variable. character ( 5 ), parameter :: FI_P = FI4P !< Output format                     for kind=I_P variable. character ( 8 ), parameter :: FI_PZP = FI4PZP !< Output format with zero prefixing for kind=I_P variable. ! Integer number of digits of output formats: integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. ! List of kinds integer , parameter :: NRknd = 4 !< Number of defined real kinds. integer , parameter :: RPl ( 1 : NRknd ) = [ R16P , R8P , R4P , R_P ] !< List of defined real kinds. character ( 10 ), parameter :: FRl ( 1 : NRknd ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of defined real kinds output format. integer , parameter :: NIknd = 5 !< Number of defined integer kinds. integer , parameter :: RIl ( 1 : NIknd ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of defined integer kinds. character ( 5 ), parameter :: FIl ( 1 : NIknd ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of defined integer kinds output format. ! Useful parameters for handling numbers ranges. ! Real min and max values: real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P variable. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P variable. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P variable. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P variable. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P variable. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P variable. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P variable. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P variable. ! Real number of bits/bytes integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P variable. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P variable. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P variable. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P variable. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P variable. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P variable. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P variable. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P variable. ! Real smallest values: real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest (module) representable value of kind=R16P variable. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest (module) representable value of kind=R8P variable. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest (module) representable value of kind=R4P variable. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest (module) representable value of kind=R_P variable. ! Integer min and max values: integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P variable. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P variable. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P variable. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P variable. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P variable. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P variable. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P variable. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P variable. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P variable. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P variable. ! Integer number of bits/bytes: integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P variable. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P variable. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P variable. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P variable. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P variable. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P variable. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P variable. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P variable. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P variable. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P variable. ! Smallest real representable difference by the running calculator. real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P variable. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P variable. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P variable. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P variable. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16p , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface interface byte_size !< Overloading of the *byte_size* function for computing the number of bytes. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface interface str !< Procedure for converting number, real and integer, to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P ,& #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P ,& #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface interface strz !< Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type !< casting with zero padding). module procedure strz_I8P , & strz_I4P , & strz_I2P , & strz_I1P endinterface interface cton !< Procedure for converting string to number, real or initeger, (string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface interface bstr !< Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P ,& #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface interface bcton !< Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface interface digit !< Procedure for computing the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for checking if the type of the bit ordering of the running architecture is little endian. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_endian elemental function bit_size_R16P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( c ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( c , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( c ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( c ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting logical to string. This function achieves casting of logical to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R16P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R8P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R4P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I8P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I4P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I2P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I1P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R16P ), intent ( IN ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine IR_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initilizing module's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! checking the bit ordering architecture call check_endian ! computing the bits/bytes sizes of real variables BIR8P = bit_size ( r = MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( r = MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( r = MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( r = MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif ir_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_init subroutine IR_Print ( pref , iostat , iomsg , unit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . ir_initialized ) call IR_init prefd = '' ; if ( present ( pref )) prefd = pref ! printing informations if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str (. true ., ZeroR16 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str (. true ., ZeroR8 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str (. true ., ZeroR4 ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_Print endmodule IR_Precision","tags":"","loc":"sourcefile/ir_precision.f90.html","title":"IR_Precision.f90 – FLAP"},{"text":"FLAP, Fortran command Line Arguments Parser for poor people Source Code !< FLAP, Fortran command Line Arguments Parser for poor people module Data_Type_Command_Line_Interface !----------------------------------------------------------------------------------------------------------------------------------- !< FLAP, Fortran command Line Arguments Parser for poor people !<{!README-FLAP.md!} !< !<### ChangeLog !< !<{!ChangeLog-FLAP.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT ! Standard output/error logical units. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: Type_Object private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilog message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). integer ( I4P ), public :: error = 0_I4P !< Error traping flag. contains procedure :: free_object !< Free dynamic memory. procedure :: errored !< Trig error occurence and print meaningful message. procedure :: print_version !< Print version. procedure :: assign_object !< Assignment overloading. endtype Type_Object type , extends ( Type_Object ) :: Type_Command_Line_Argument !< Command line arguments (CLA). !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable :: switch !< Switch name. character ( len = :), allocatable :: switch_ab !< Abbreviated switch name. logical :: required = . false . !< Flag for set required argument. logical :: positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ) :: position = 0_I4P !< Position of positional CLA. logical :: passed = . false . !< Flag for checking if CLA has been passed to CLI. logical :: hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable :: act !< CLA value action. character ( len = :), allocatable :: def !< Default value. character ( len = :), allocatable :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable :: val !< CLA value. character ( len = :), allocatable :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free => free_cla !< Free dynamic memory. procedure , public :: check => check_cla !< Check CLA data consistency. procedure , public :: check_choices => check_choices_cla !< Check if CLA value is in allowed choices. procedure , public :: check_list_size => check_list_size_cla !< Check CLA multiple values list size consistency. generic , public :: get => get_cla , get_cla_list !< Get CLA value(s). generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char procedure , public :: usage => usage_cla !< Get correct CLA usage. procedure , public :: signature => signature_cla !< Get CLA signature for adding to CLI one. ! private methods procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cla !< CLA assignment overloading. generic , private :: assignment ( = ) => assign_cla !< CLA assignment overloading. final :: finalize_cla !< Free dynamic memory when finalizing. endtype Type_Command_Line_Argument type , extends ( Type_Object ) :: Type_Command_Line_Arguments_Group !< Group of CLAs for building nested commands. private character ( len = :), allocatable :: group !< Group name (command). integer ( I4P ) :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of command line arguments that CLI requires. integer ( I4P ) :: Na_optional = 0_I4P !< Number of command line arguments that are optional for CLI. type ( Type_Command_Line_Argument ), allocatable :: cla (:) !< CLA list [1:Na]. logical :: called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free => free_clasg !< Free dynamic memory. procedure , public :: check => check_clasg !< Check CLAs data consistency. procedure , public :: check_required => check_required_clasg !< Check if required CLAs are passed. procedure , public :: check_m_exclusive => check_m_exclusive_clasg !< Check if two mutually exclusive CLAs have been passed. procedure , public :: add => add_cla_clasg !< Add CLA to CLAs group. procedure , public :: passed => passed_clasg !< Check if a CLA has been passed. procedure , public :: defined => defined_clasg !< Check if a CLA has been defined. procedure , public :: parse => parse_clasg !< Parse CLAs group arguments. procedure , public :: usage => usage_clasg !< Get correct CLAs group usage. procedure , public :: signature => signature_clasg !< Get CLAs group signature for adding to the CLI one. ! private methods procedure , private :: assign_clasg !< CLAs group assignment overloading. generic , private :: assignment ( = ) => assign_clasg !< CLAs group assignment overloading. final :: finalize_clasg !< Free dynamic memory when finalizing. endtype Type_Command_Line_Arguments_Group type , extends ( Type_Object ), public :: Type_Command_Line_Interface !< Command Line Interface (CLI). private type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 100 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 100 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: passed !< Check if a CLA has been passed. procedure , public :: defined !< Check if a CLA has been defined. procedure , public :: defined_group !< Check if a CLAs group has been defined. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => called_group !< Check if a CLAs group has been runned. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => get_cla_cli , get_cla_list_cli !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P_cli , & #endif get_cla_list_varying_R8P_cli , & get_cla_list_varying_R4P_cli , & get_cla_list_varying_I8P_cli , & get_cla_list_varying_I4P_cli , & get_cla_list_varying_I2P_cli , & get_cla_list_varying_I1P_cli , & get_cla_list_varying_logical_cli , & get_cla_list_varying_char_cli procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. ! private methods procedure , private :: check !< Check CLAs data consistenc. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => get_args_from_string ,& !< Get CLAs from string. get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla_cli !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list_cli !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical_cli !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char_cli !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype Type_Command_Line_Interface ! parameters integer ( I4P ), parameter :: max_val_len = 1000 !< Maximum number of characters of CLA value. character ( len =* ), parameter :: action_store = 'STORE' !< CLA that stores value (if invoked a value must be passed). character ( len =* ), parameter :: action_store_star = 'STORE*' !< CLA that stores value or revert on default is invoked alone. character ( len =* ), parameter :: action_store_true = 'STORE_TRUE' !< CLA that stores .true. without the necessity of a value. character ( len =* ), parameter :: action_store_false = 'STORE_FALSE' !< CLA that stores .false. without the necessity of a value. character ( len =* ), parameter :: action_print_help = 'PRINT_HELP' !< CLA that print help message. character ( len =* ), parameter :: action_print_vers = 'PRINT_VERSION' !< CLA that print version. character ( len =* ), parameter :: args_sep = '||!||' !< Arguments separator for multiple valued (list) CLA. ! code errors and status integer ( I4P ), parameter :: error_cla_optional_no_def = 1 !< Optional CLA without default value. integer ( I4P ), parameter :: error_cla_required_m_exclude = 2 !< Required CLA cannot exclude others. integer ( I4P ), parameter :: error_cla_positional_m_exclude = 3 !< Positional CLA cannot exclude others. integer ( I4P ), parameter :: error_cla_named_no_name = 4 !< Named CLA without switch name. integer ( I4P ), parameter :: error_cla_positional_no_position = 5 !< Positional CLA without position. integer ( I4P ), parameter :: error_cla_positional_no_store = 6 !< Positional CLA without action_store. integer ( I4P ), parameter :: error_cla_not_in_choices = 7 !< CLA value out of a specified choices. integer ( I4P ), parameter :: error_cla_missing_required = 8 !< Missing required CLA. integer ( I4P ), parameter :: error_cla_m_exclude = 9 !< Two mutually exclusive CLAs have been passed. integer ( I4P ), parameter :: error_cla_casting_logical = 10 !< Error casting CLA value to logical type. integer ( I4P ), parameter :: error_cla_no_list = 11 !< Actual CLA is not list-values. integer ( I4P ), parameter :: error_cla_nargs_insufficient = 12 !< Multi-valued CLA with insufficient arguments. integer ( I4P ), parameter :: error_cla_value_missing = 13 !< Missing value of CLA. integer ( I4P ), parameter :: error_cla_unknown = 14 !< Unknown CLA (switch name). integer ( I4P ), parameter :: error_cla_envvar_positional = 15 !< Envvar not allowed for positional CLA. integer ( I4P ), parameter :: error_cla_envvar_not_store = 16 !< Envvar not allowed action different from store; integer ( I4P ), parameter :: error_cla_envvar_nargs = 17 !< Envvar not allowed for list-values CLA. integer ( I4P ), parameter :: error_cla_store_star_positional = 18 !< Action store* not allowed for positional CLA. integer ( I4P ), parameter :: error_cla_store_star_nargs = 19 !< Action store* not allowed for list-values CLA. integer ( I4P ), parameter :: error_cla_store_star_envvar = 20 !< Action store* not allowed for environment variable CLA. integer ( I4P ), parameter :: error_cla_action_unknown = 21 !< Unknown CLA (switch name). integer ( I4P ), parameter :: error_clasg_consistency = 22 !< CLAs group consistency error. integer ( I4P ), parameter :: error_clasg_m_exclude = 23 !< Two mutually exclusive CLAs group have been called. integer ( I4P ), parameter :: error_cli_missing_cla = 24 !< CLA not found in CLI. integer ( I4P ), parameter :: error_cli_missing_group = 25 !< Group not found in CLI. integer ( I4P ), parameter :: error_cli_missing_selection_cla = 26 !< CLA selection in CLI failing. integer ( I4P ), parameter :: error_cli_too_few_clas = 27 !< Insufficient arguments for CLI. integer ( I4P ), parameter :: status_clasg_print_v = - 1 !< Print version status. integer ( I4P ), parameter :: status_clasg_print_h = - 2 !< Print help status. !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary procedures elemental function Upper_Case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string !< String to be converted. character ( len = len ( string )) :: Upper_Case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Upper_Case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) Upper_Case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: strin !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( OUT ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( OUT ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = char ( 0 ) ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize ! Type_Object procedures elemental subroutine free_object ( obj ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( obj % progname )) deallocate ( obj % progname ) if ( allocated ( obj % version )) deallocate ( obj % version ) if ( allocated ( obj % help )) deallocate ( obj % help ) if ( allocated ( obj % description )) deallocate ( obj % description ) if ( allocated ( obj % license )) deallocate ( obj % license ) if ( allocated ( obj % authors )) deallocate ( obj % authors ) if ( allocated ( obj % epilog )) deallocate ( obj % epilog ) if ( allocated ( obj % m_exclude )) deallocate ( obj % m_exclude ) obj % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object subroutine errored ( obj , error , pref , group , switch , val_str , log_value , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. integer ( I4P ), intent ( IN ) :: error !< Error occurred. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Group name. character ( * ), optional , intent ( IN ) :: switch !< CLA switch name. character ( * ), optional , intent ( IN ) :: val_str !< Value string. character ( * ), optional , intent ( IN ) :: log_value !< Logical value to be casted. integer ( I4P ), optional , intent ( IN ) :: a1 , a2 !< CLAs group inconsistent indexes. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- obj % error = error if ( obj % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select type ( obj ) class is ( Type_Command_Line_Argument ) select case ( obj % error ) case ( error_cla_optional_no_def ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option has not a default value!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" has not a default value!' endif case ( error_cla_required_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( error_cla_positional_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( error_cla_named_no_name ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a non positional optiona must have a switch name!' case ( error_cla_positional_no_position ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have a position number different from 0!' case ( error_cla_positional_no_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( error_cla_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the options \"' // obj % switch // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been passed!' case ( error_cla_not_in_choices ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of \"' // trim ( str ( n = obj % position )) // & '-th\" positional option must be chosen in:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of named option \"' // obj % switch // '\" must be chosen in:' endif write ( stderr , '(A)' ) prefd // '(' // obj % choices // ')' write ( stderr , '(A)' ) prefd // '\"' // trim ( val_str ) // '\" has been passed!' case ( error_cla_missing_required ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" is required!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option is required!' endif case ( error_cla_casting_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // obj % switch // & '\" to logical type!' case ( error_cla_no_list ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" has not \"nargs\" value' // & ' but an array has been passed to \"get\" method!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( error_cla_nargs_insufficient ) if (. not . obj % positional ) then if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires at least ' // & '1 argument but no one remains!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif else if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires at least 1 argument but no one remains' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif endif case ( error_cla_value_missing ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" needs a value that is not passed!' case ( error_cla_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( error_cla_envvar_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( error_cla_envvar_not_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( error_cla_envvar_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( error_cla_store_star_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( error_cla_store_star_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( error_cla_store_star_envvar ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( error_cla_action_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has unknown \"' // obj % act // '\" action!' endselect class is ( Type_Command_Line_Arguments_Group ) select case ( obj % error ) case ( error_clasg_consistency ) if ( obj % group /= '' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: group (command) name: \"' // obj % group // '\" consistency error:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: consistency error:' endif write ( stderr , '(A)' ) prefd // ' \"' // trim ( str (. true ., a1 )) // '-th\" option has the same switch or abbreviated switch of \"' & // trim ( str (. true ., a2 )) // '-th\" option:' write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a1 )) // ') switches = ' // obj % cla ( a1 )% switch // ' ' // & obj % cla ( a1 )% switch_ab write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a2 )) // ') switches = ' // obj % cla ( a2 )% switch // ' ' // & obj % cla ( a2 )% switch_ab case ( error_clasg_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the group \"' // obj % group // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect class is ( Type_Command_Line_Interface ) select case ( obj % error ) case ( error_cli_missing_cla ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( error_cli_missing_selection_cla ) write ( stderr , '(A)' ) prefd // obj % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( error_cli_missing_group ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( error_cli_too_few_clas ) ! write(stderr,'(A)')prefd//obj%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,obj%Na_required))//')' endselect endselect write ( stderr , '(A)' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored subroutine print_version ( obj , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( IN ) :: obj !< Object data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) prefd // obj % progname // ' version ' // obj % version if ( obj % license /= '' ) then write ( stdout , '(A)' ) prefd // obj % license endif if ( obj % authors /= '' ) then write ( stdout , '(A)' ) prefd // obj % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: lhs !< Left hand side. class ( Type_Object ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude lhs % error = rhs % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object ! Type_Command_Line_Argument procedures elemental subroutine free_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cla % free_object ! Type_Command_Line_Argument members if ( allocated ( cla % switch )) deallocate ( cla % switch ) if ( allocated ( cla % switch_ab )) deallocate ( cla % switch_ab ) if ( allocated ( cla % act )) deallocate ( cla % act ) if ( allocated ( cla % def )) deallocate ( cla % def ) if ( allocated ( cla % nargs )) deallocate ( cla % nargs ) if ( allocated ( cla % choices )) deallocate ( cla % choices ) if ( allocated ( cla % val )) deallocate ( cla % val ) if ( allocated ( cla % envvar )) deallocate ( cla % envvar ) cla % required = . false . cla % positional = . false . cla % position = 0_I4P cla % passed = . false . cla % hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_cla elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo endselect if (. not . val_in ) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t , tt !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli function usage ( cli , g , pref , no_header , no_examples , no_epilog ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. integer ( I4P ), intent ( IN ) :: g !< Group index. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( IN ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( IN ) :: no_epilog !< Avoid insert epilogue to usage. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = cli % clasg ( g )% usage ( pref = prefd , no_header = no_headerd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // cli % help // cli % progname // ' ' // cli % signature () if ( cli % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // cli % description endif if ( cli % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // cli % clasg ( 0 )% usage ( pref = prefd , no_header = . true .) if ( size ( cli % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // cli % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % progname // ' ' // cli % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( cli % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( cli % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( cli % examples ( e )) enddo endif if ( cli % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // cli % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( cli ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLI signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = cli % clasg ( 0 )% signature () if ( size ( cli % clasg , dim = 1 ) > 1 ) then signd = signd // ' {' // cli % clasg ( 1 )% group do g = 2 , size ( cli % clasg , dim = 1 ) - 1 signd = signd // ',' // cli % clasg ( g )% group enddo signd = signd // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature subroutine print_usage ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage subroutine save_man_page ( cli , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // cli % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // cli % version // & '\" \"' // cli % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // cli % progname // ' - manual page for ' // cli % progname // ' version ' // cli % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // cli % progname // new_line ( 'a' ) // trim ( adjustl ( cli % signature ())) if ( cli % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // cli % description if ( cli % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // cli % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( cli % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( cli % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( cli % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( cli % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // cli % authors if ( cli % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // cli % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page elemental subroutine assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Interface ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cli endmodule Data_Type_Command_Line_Interface","tags":"","loc":"sourcefile/data_type_command_line_interface.f90.html","title":"Data_Type_Command_Line_Interface.F90 – FLAP"},{"text":"Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), private, allocatable :: help Help message. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilog message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). integer(kind=I4P), public :: error = 0_I4P Error traping flag. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. private elemental subroutine free_object (obj) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. Description Free dynamic memory. procedure, public :: errored Trig error occurence and print meaningful message. private  subroutine errored (obj, error, pref, group, switch, val_str, log_value, a1, a2) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. integer(kind=I4P), intent(in), optional :: a1 integer(kind=I4P), intent(in), optional :: a2 CLAs group inconsistent indexes. Description Trig error occurence and print meaningful message. procedure, public :: print_version Print version. private  subroutine print_version (obj, pref) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(in) :: obj Object data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print version. procedure, public :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: lhs Left hand side. class( Type_Object ), intent(in) :: rhs Rigth hand side. Source Code type , abstract :: Type_Object private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), allocatable :: help !< Help message. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilog message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). integer ( I4P ), public :: error = 0_I4P !< Error traping flag. contains procedure :: free_object !< Free dynamic memory. procedure :: errored !< Trig error occurence and print meaningful message. procedure :: print_version !< Print version. procedure :: assign_object !< Assignment overloading. endtype Type_Object","tags":"","loc":"type/type_object.html","title":"Type_Object – FLAP "},{"text":"Command line arguments (CLA). Note If not otherwise declared the action on CLA value is set to \"store\" a value.\n Free dynamic memory when finalizing. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: switch Switch name. character(len=:), private, allocatable :: switch_ab Abbreviated switch name. logical, private :: required = .false. Flag for set required argument. logical, private :: positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), private :: position = 0_I4P Position of positional CLA. logical, private :: passed = .false. Flag for checking if CLA has been passed to CLI. logical, private :: hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), private, allocatable :: act CLA value action. character(len=:), private, allocatable :: def Default value. character(len=:), private, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), private, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), private, allocatable :: val CLA value. character(len=:), private, allocatable :: envvar Environment variable from which take value. Finalization Procedures final :: finalize_cla private elemental subroutine finalize_cla (cla) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_cla Free dynamic memory. private elemental subroutine free_cla (cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory. procedure, public :: check => check_cla Check CLA data consistency. private  subroutine check_cla (cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. procedure, public :: check_choices => check_choices_cla Check if CLA value is in allowed choices. private  subroutine check_choices_cla (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if CLA value is in allowed choices. procedure, public :: check_list_size => check_list_size_cla Check CLA multiple values list size consistency. private  function check_list_size_cla (cla, Nv, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Description Check CLA multiple values list size consistency. generic, public :: get => get_cla , get_cla_list Get CLA value(s). private  subroutine get_cla (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. private  subroutine get_cla_list (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from CLAs list parsedi, varying size list. private  subroutine get_cla_list_varying_R8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). private  subroutine get_cla_list_varying_R4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). private  subroutine get_cla_list_varying_I8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). private  subroutine get_cla_list_varying_I4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). private  subroutine get_cla_list_varying_I2P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). private  subroutine get_cla_list_varying_I1P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). private  subroutine get_cla_list_varying_logical (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. private  subroutine get_cla_list_varying_char (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. procedure, public :: usage => usage_cla Get correct CLA usage. private  function usage_cla (cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLA usage. procedure, public :: signature => signature_cla Get CLA signature for adding to CLI one. private  function signature_cla (cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLA signature for adding to the CLI one. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. private  subroutine get_cla (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. private  subroutine get_cla_list (cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. private  subroutine get_cla_list_varying_R8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. private  subroutine get_cla_list_varying_R4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. private  subroutine get_cla_list_varying_I8P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. private  subroutine get_cla_list_varying_I4P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. private  subroutine get_cla_list_varying_I2P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. private  subroutine get_cla_list_varying_I1P (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. private  subroutine get_cla_list_varying_logical (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. private  subroutine get_cla_list_varying_char (cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. procedure, private :: assign_cla CLA assignment overloading. private elemental subroutine assign_cla (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. generic, private :: assignment(=) => assign_cla CLA assignment overloading. private elemental subroutine assign_cla (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. Source Code type , extends ( Type_Object ) :: Type_Command_Line_Argument !< Command line arguments (CLA). !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable :: switch !< Switch name. character ( len = :), allocatable :: switch_ab !< Abbreviated switch name. logical :: required = . false . !< Flag for set required argument. logical :: positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ) :: position = 0_I4P !< Position of positional CLA. logical :: passed = . false . !< Flag for checking if CLA has been passed to CLI. logical :: hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable :: act !< CLA value action. character ( len = :), allocatable :: def !< Default value. character ( len = :), allocatable :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable :: val !< CLA value. character ( len = :), allocatable :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free => free_cla !< Free dynamic memory. procedure , public :: check => check_cla !< Check CLA data consistency. procedure , public :: check_choices => check_choices_cla !< Check if CLA value is in allowed choices. procedure , public :: check_list_size => check_list_size_cla !< Check CLA multiple values list size consistency. generic , public :: get => get_cla , get_cla_list !< Get CLA value(s). generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char procedure , public :: usage => usage_cla !< Get correct CLA usage. procedure , public :: signature => signature_cla !< Get CLA signature for adding to CLI one. ! private methods procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cla !< CLA assignment overloading. generic , private :: assignment ( = ) => assign_cla !< CLA assignment overloading. final :: finalize_cla !< Free dynamic memory when finalizing. endtype Type_Command_Line_Argument","tags":"","loc":"type/type_command_line_argument.html","title":"Type_Command_Line_Argument – FLAP "},{"text":"Group of CLAs for building nested commands.\n Free dynamic memory when finalizing. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: group Group name (command). integer(kind=I4P), private :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of command line arguments that CLI requires. integer(kind=I4P), private :: Na_optional = 0_I4P Number of command line arguments that are optional for CLI. type( Type_Command_Line_Argument ), private, allocatable :: cla (:) CLA list [1:Na]. logical, private :: called = .false. Flag for checking if CLAs group has been passed to CLI. Finalization Procedures final :: finalize_clasg private elemental subroutine finalize_clasg (clasg) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free => free_clasg Free dynamic memory. private elemental subroutine free_clasg (clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory. procedure, public :: check => check_clasg Check CLAs data consistency. private  subroutine check_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. procedure, public :: check_required => check_required_clasg Check if required CLAs are passed. private  subroutine check_required_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if required CLAs are passed. procedure, public :: check_m_exclusive => check_m_exclusive_clasg Check if two mutually exclusive CLAs have been passed. private  subroutine check_m_exclusive_clasg (clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs have been passed. procedure, public :: add => add_cla_clasg Add CLA to CLAs group. private  subroutine add_cla_clasg (clasg, pref, cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. type( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Description Add CLA to CLAs list. procedure, public :: passed => passed_clasg Check if a CLA has been passed. private pure function passed_clasg (clasg, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. procedure, public :: defined => defined_clasg Check if a CLA has been defined. private  function defined_clasg (clasg, switch, pos) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. procedure, public :: parse => parse_clasg Parse CLAs group arguments. private  subroutine parse_clasg (clasg, pref, args) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in) :: args (:) Command line arguments. Description Parse CLAs group arguments. procedure, public :: usage => usage_clasg Get correct CLAs group usage. private  function usage_clasg (clasg, pref, no_header) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. Return Value character(len=:),\n  allocatable Usage string. Description Get correct CLAs group usage. procedure, public :: signature => signature_clasg Get CLAs group signature for adding to the CLI one. private  function signature_clasg (clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLAs group signature for adding to the CLI one. procedure, private :: assign_clasg CLAs group assignment overloading. private elemental subroutine assign_clasg (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => assign_clasg CLAs group assignment overloading. private elemental subroutine assign_clasg (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. Source Code type , extends ( Type_Object ) :: Type_Command_Line_Arguments_Group !< Group of CLAs for building nested commands. private character ( len = :), allocatable :: group !< Group name (command). integer ( I4P ) :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of command line arguments that CLI requires. integer ( I4P ) :: Na_optional = 0_I4P !< Number of command line arguments that are optional for CLI. type ( Type_Command_Line_Argument ), allocatable :: cla (:) !< CLA list [1:Na]. logical :: called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free => free_clasg !< Free dynamic memory. procedure , public :: check => check_clasg !< Check CLAs data consistency. procedure , public :: check_required => check_required_clasg !< Check if required CLAs are passed. procedure , public :: check_m_exclusive => check_m_exclusive_clasg !< Check if two mutually exclusive CLAs have been passed. procedure , public :: add => add_cla_clasg !< Add CLA to CLAs group. procedure , public :: passed => passed_clasg !< Check if a CLA has been passed. procedure , public :: defined => defined_clasg !< Check if a CLA has been defined. procedure , public :: parse => parse_clasg !< Parse CLAs group arguments. procedure , public :: usage => usage_clasg !< Get correct CLAs group usage. procedure , public :: signature => signature_clasg !< Get CLAs group signature for adding to the CLI one. ! private methods procedure , private :: assign_clasg !< CLAs group assignment overloading. generic , private :: assignment ( = ) => assign_clasg !< CLAs group assignment overloading. final :: finalize_clasg !< Free dynamic memory when finalizing. endtype Type_Command_Line_Arguments_Group","tags":"","loc":"type/type_command_line_arguments_group.html","title":"Type_Command_Line_Arguments_Group – FLAP "},{"text":"Command Line Interface (CLI).\n Free dynamic memory when finalizing. Components Type Visibility Attributes Name Initial type( Type_Command_Line_Arguments_Group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=100), private, allocatable :: args (:) Actually passed command line arguments. character(len=100), private, allocatable :: examples (:) Examples of correct usage. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. Finalization Procedures final :: finalize private elemental subroutine finalize (cli) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory. procedure, public :: init Initialize CLI. private  subroutine init (cli, progname, version, help, description, license, authors, examples, epilog, disable_hv) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. Description Initialize CLI. procedure, public :: add_group Add CLAs group CLI. private  subroutine add_group (cli, help, description, exclude, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Description Add CLAs group to CLI. procedure, public :: add Add CLA to CLI. private  subroutine add (cli, pref, group, group_index, switch, switch_ab, help, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Add CLA to CLI. procedure, public :: passed Check if a CLA has been passed. private  function passed (cli, group, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. procedure, public :: defined Check if a CLA has been defined. private  function defined (cli, switch, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. procedure, public :: defined_group Check if a CLAs group has been defined. private  function defined_group (cli, group, g) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Description Check if a CLAs group has been defined. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. private  subroutine set_mutually_exclusive_groups (cli, group1, group2) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Description Set two CLAs group ad mutually exclusive. procedure, public :: run_command => called_group Check if a CLAs group has been runned. private  function called_group (cli, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Description Check if a CLAs group has been runned. procedure, public :: parse Parse Command Line Interfaces. private  subroutine parse (cli, pref, args, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Parse Command Line Interfaces by means of a previously initialized CLAs groups list. generic, public :: get => get_cla_cli , get_cla_list_cli Get CLA value(s) from CLAs list parsed. private  subroutine get_cla_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. private  subroutine get_cla_list_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. generic, public :: get_varying => get_cla_list_varying_R8P_cli , get_cla_list_varying_R4P_cli , get_cla_list_varying_I8P_cli , get_cla_list_varying_I4P_cli , get_cla_list_varying_I2P_cli , get_cla_list_varying_I1P_cli , get_cla_list_varying_logical_cli , get_cla_list_varying_char_cli Get CLA value(s) from CLAs list parsedi, varying size list. private  subroutine get_cla_list_varying_R8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). private  subroutine get_cla_list_varying_R4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). private  subroutine get_cla_list_varying_I8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). private  subroutine get_cla_list_varying_I4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). private  subroutine get_cla_list_varying_I2P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). private  subroutine get_cla_list_varying_I1P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). private  subroutine get_cla_list_varying_logical_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. private  subroutine get_cla_list_varying_char_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. procedure, public :: usage Get CLI usage. private  function usage (cli, g, pref, no_header, no_examples, no_epilog) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. Return Value character(len=:),\n  allocatable Usage string. Description Print correct usage of CLI. procedure, public :: signature Get CLI signature. private  function signature (cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. Return Value character(len=:),\n  allocatable Temporary CLI signature. Description Get CLI signature. procedure, public :: print_usage Print correct usage of CLI. private  subroutine print_usage (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print correct usage of CLI. procedure, public :: save_man_page Save man page build on CLI. private  subroutine save_man_page (cli, man_file, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Save man page build on the CLI. procedure, private :: check Check CLAs data consistenc. private  subroutine check (cli, pref, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Check CLAs data consistency. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. private  subroutine check_m_exclusive (cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs group have been called. procedure, private :: get_clasg_indexes Get CLAs groups indexes. private  subroutine get_clasg_indexes (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. generic, private :: get_args => get_args_from_string , get_args_from_invocation Get CLAs from string.\n Get CLAs from CLI invocation. private  subroutine get_args_from_string (cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. private  subroutine get_args_from_invocation (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. procedure, private :: get_args_from_string Get CLAs from string. private  subroutine get_args_from_string (cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. private  subroutine get_args_from_invocation (cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. procedure, private :: get_cla_cli Get CLA (single) value from CLAs list parsed. private  subroutine get_cla_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. procedure, private :: get_cla_list_cli Get CLA multiple values from CLAs list parsed. private  subroutine get_cla_list_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. procedure, private :: get_cla_list_varying_R16P_cli Get CLA multiple values from CLAs list parsed, varying size, R16P. private  subroutine get_cla_list_varying_R16P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). procedure, private :: get_cla_list_varying_R8P_cli Get CLA multiple values from CLAs list parsed, varying size, R8P. private  subroutine get_cla_list_varying_R8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). procedure, private :: get_cla_list_varying_R4P_cli Get CLA multiple values from CLAs list parsed, varying size, R4P. private  subroutine get_cla_list_varying_R4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). procedure, private :: get_cla_list_varying_I8P_cli Get CLA multiple values from CLAs list parsed, varying size, I8P. private  subroutine get_cla_list_varying_I8P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). procedure, private :: get_cla_list_varying_I4P_cli Get CLA multiple values from CLAs list parsed, varying size, I4P. private  subroutine get_cla_list_varying_I4P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). procedure, private :: get_cla_list_varying_I2P_cli Get CLA multiple values from CLAs list parsed, varying size, I2P. private  subroutine get_cla_list_varying_I2P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). procedure, private :: get_cla_list_varying_I1P_cli Get CLA multiple values from CLAs list parsed, varying size, I1P. private  subroutine get_cla_list_varying_I1P_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). procedure, private :: get_cla_list_varying_logical_cli Get CLA multiple values from CLAs list parsed, varying size, bool. private  subroutine get_cla_list_varying_logical_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. procedure, private :: get_cla_list_varying_char_cli Get CLA multiple values from CLAs list parsed, varying size, char. private  subroutine get_cla_list_varying_char_cli (cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. procedure, private :: assign_cli CLI assignment overloading. private elemental subroutine assign_cli (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => assign_cli CLI assignment overloading. private elemental subroutine assign_cli (lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. Source Code type , extends ( Type_Object ), public :: Type_Command_Line_Interface !< Command Line Interface (CLI). private type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 100 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 100 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: passed !< Check if a CLA has been passed. procedure , public :: defined !< Check if a CLA has been defined. procedure , public :: defined_group !< Check if a CLAs group has been defined. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => called_group !< Check if a CLAs group has been runned. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => get_cla_cli , get_cla_list_cli !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & !< Get CLA value(s) from CLAs list parsedi, varying size list. #ifdef r16p get_cla_list_varying_R16P_cli , & #endif get_cla_list_varying_R8P_cli , & get_cla_list_varying_R4P_cli , & get_cla_list_varying_I8P_cli , & get_cla_list_varying_I4P_cli , & get_cla_list_varying_I2P_cli , & get_cla_list_varying_I1P_cli , & get_cla_list_varying_logical_cli , & get_cla_list_varying_char_cli procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. ! private methods procedure , private :: check !< Check CLAs data consistenc. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => get_args_from_string ,& !< Get CLAs from string. get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla_cli !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list_cli !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P_cli !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical_cli !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char_cli !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype Type_Command_Line_Interface","tags":"","loc":"type/type_command_line_interface.html","title":"Type_Command_Line_Interface – FLAP "},{"text":"private pure function is_little_endian() Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Procedure for checking if the type of the bit ordering of the running architecture is little endian. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: int1 (1:4) One byte integer array for casting 4 bytes integer. Source Code pure function is_little_endian () result ( is_little ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for checking if the type of the bit ordering of the running architecture is little endian. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian","tags":"","loc":"proc/is_little_endian.html","title":"is_little_endian – FLAP"},{"text":"private elemental function bit_size_R16P(r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – FLAP"},{"text":"private elemental function bit_size_R8P(r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – FLAP"},{"text":"private elemental function bit_size_R4P(r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – FLAP"},{"text":"private elemental function bit_size_chr(c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( c ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( c , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – FLAP"},{"text":"private elemental function byte_size_I8P(i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – FLAP"},{"text":"private elemental function byte_size_I4P(i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – FLAP"},{"text":"private elemental function byte_size_I2P(i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – FLAP"},{"text":"private elemental function byte_size_I1P(i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – FLAP"},{"text":"private elemental function byte_size_R16P(r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – FLAP"},{"text":"private elemental function byte_size_R8P(r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. Source Code elemental function byte_size_R8P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – FLAP"},{"text":"private elemental function byte_size_R4P(r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. Source Code elemental function byte_size_R4P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – FLAP"},{"text":"private elemental function byte_size_chr(c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable. Source Code elemental function byte_size_chr ( c ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( c ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – FLAP"},{"text":"private elemental function strf_R16P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – FLAP"},{"text":"private elemental function strf_R8P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – FLAP"},{"text":"private elemental function strf_R4P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – FLAP"},{"text":"private elemental function strf_I8P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – FLAP"},{"text":"private elemental function strf_I4P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – FLAP"},{"text":"private elemental function strf_I2P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – FLAP"},{"text":"private elemental function strf_I1P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – FLAP"},{"text":"private elemental function str_R16P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function str_R16P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – FLAP"},{"text":"private elemental function str_R8P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function str_R8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – FLAP"},{"text":"private elemental function str_R4P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function str_R4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – FLAP"},{"text":"private elemental function str_I8P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – FLAP"},{"text":"private elemental function str_I4P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – FLAP"},{"text":"private elemental function str_I2P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I2P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – FLAP"},{"text":"private elemental function str_I1P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I1P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – FLAP"},{"text":"private elemental function str_bol(n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting logical to string. This function achieves casting of logical to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – FLAP"},{"text":"private pure function str_a_R16P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R16P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – FLAP"},{"text":"private pure function str_a_R8P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R8P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – FLAP"},{"text":"private pure function str_a_R4P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R4P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – FLAP"},{"text":"private pure function str_a_I8P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I8P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – FLAP"},{"text":"private pure function str_a_I4P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I4P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – FLAP"},{"text":"private pure function str_a_I2P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I2P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – FLAP"},{"text":"private pure function str_a_I1P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I1P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – FLAP"},{"text":"private elemental function strz_I8P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I8P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – FLAP"},{"text":"private elemental function strz_I4P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I4P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – FLAP"},{"text":"private elemental function strz_I2P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I2P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – FLAP"},{"text":"private elemental function strz_I1P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I1P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – FLAP"},{"text":"private  function ctor_R16P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R16P ), intent ( IN ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – FLAP"},{"text":"private  function ctor_R8P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – FLAP"},{"text":"private  function ctor_R4P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – FLAP"},{"text":"private  function ctoi_I8P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – FLAP"},{"text":"private  function ctoi_I4P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – FLAP"},{"text":"private  function ctoi_I2P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – FLAP"},{"text":"private  function ctoi_I1P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – FLAP"},{"text":"private elemental function bstr_R16P(n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – FLAP"},{"text":"private elemental function bstr_R8P(n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – FLAP"},{"text":"private elemental function bstr_R4P(n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – FLAP"},{"text":"private elemental function bstr_I8P(n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – FLAP"},{"text":"private elemental function bstr_I4P(n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – FLAP"},{"text":"private elemental function bstr_I2P(n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – FLAP"},{"text":"private elemental function bstr_I1P(n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – FLAP"},{"text":"private elemental function bctor_R8P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – FLAP"},{"text":"private elemental function bctor_R4P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – FLAP"},{"text":"private elemental function bctoi_I8P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – FLAP"},{"text":"private elemental function bctoi_I4P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – FLAP"},{"text":"private elemental function bctoi_I2P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – FLAP"},{"text":"private elemental function bctoi_I1P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – FLAP"},{"text":"private elemental function digit_I8(n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – FLAP"},{"text":"private elemental function digit_I4(n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – FLAP"},{"text":"private elemental function digit_I2(n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – FLAP"},{"text":"private elemental function digit_I1(n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – FLAP"},{"text":"public  subroutine check_endian() Arguments None Description Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – FLAP"},{"text":"public  subroutine IR_init() Arguments None Description Procedure for initilizing module's variables that are not initialized into the definition specification. Source Code subroutine IR_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initilizing module's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! checking the bit ordering architecture call check_endian ! computing the bits/bytes sizes of real variables BIR8P = bit_size ( r = MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( r = MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( r = MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( r = MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif ir_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_init","tags":"","loc":"proc/ir_init.html","title":"IR_init – FLAP"},{"text":"public  subroutine IR_Print(pref, iostat, iomsg, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. integer(kind=I4P), intent(in) :: unit Logic unit. Description Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine IR_Print ( pref , iostat , iomsg , unit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . ir_initialized ) call IR_init prefd = '' ; if ( present ( pref )) prefd = pref ! printing informations if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str (. true ., ZeroR16 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str (. true ., ZeroR8 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str (. true ., ZeroR4 ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_Print","tags":"","loc":"proc/ir_print.html","title":"IR_Print – FLAP"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Module Procedures private elemental function bit_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable.","tags":"","loc":"interface/bit_size.html","title":"bit_size – FLAP"},{"text":"public interface byte_size Overloading of the byte_size function for computing the number of bytes. Module Procedures private elemental function byte_size_I8P (i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I4P (i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I2P (i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I1P (i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable.","tags":"","loc":"interface/byte_size.html","title":"byte_size – FLAP"},{"text":"public interface str Procedure for converting number, real and integer, to string (number to string type casting). Module Procedures private elemental function strf_R16P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R16P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_I8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I2P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I2P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I1P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I1P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_bol (n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. private pure function str_a_R16P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_I8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I2P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I1P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string.","tags":"","loc":"interface/str.html","title":"str – FLAP"},{"text":"public interface strz Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type\n casting with zero padding). Module Procedures private elemental function strz_I8P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I4P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I2P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I1P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string.","tags":"","loc":"interface/strz.html","title":"strz – FLAP"},{"text":"public interface cton Procedure for converting string to number, real or initeger, (string to number type casting). Module Procedures private  function ctor_R16P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctoi_I8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I2P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I1P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer.","tags":"","loc":"interface/cton.html","title":"cton – FLAP"},{"text":"public interface bstr Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). Module Procedures private elemental function bstr_R16P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R8P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R4P (n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_I8P (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I4P (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I2P (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I1P (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string.","tags":"","loc":"interface/bstr.html","title":"bstr – FLAP"},{"text":"public interface bcton Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). Module Procedures None() Arguments None private elemental function bctor_R8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctor_R4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctoi_I8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I2P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I1P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer.","tags":"","loc":"interface/bcton.html","title":"bcton – FLAP"},{"text":"public interface digit Procedure for computing the number of digits in decimal base of the input integer. Module Procedures private elemental function digit_I8 (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit.html","title":"digit – FLAP"},{"text":"private elemental function Upper_Case(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Description Convert the lower case characters of a string to upper case one. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. character(len=26), public, parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(len=26), public, parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. Source Code elemental function Upper_Case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len =* ), intent ( IN ) :: string !< String to be converted. character ( len = len ( string )) :: Upper_Case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Upper_Case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) Upper_Case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction Upper_Case","tags":"","loc":"proc/upper_case.html","title":"Upper_Case – FLAP"},{"text":"private  function check_list_size_cla(cla, Nv, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Description Check CLA multiple values list size consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla","tags":"","loc":"proc/check_list_size_cla.html","title":"check_list_size_cla – FLAP"},{"text":"private  function usage_cla(cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value character(len=:),\n    allocatable Usage string. Description Get correct CLA usage. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla","tags":"","loc":"proc/usage_cla.html","title":"usage_cla – FLAP"},{"text":"private  function signature_cla(cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Return Value character(len=:),\n    allocatable Temporary CLI signature. Description Get CLA signature for adding to the CLI one. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: nargs Number of arguments consumed by CLA. integer(kind=I4P), public :: a Counter. Source Code function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla","tags":"","loc":"proc/signature_cla.html","title":"signature_cla – FLAP"},{"text":"private pure function passed_clasg(clasg, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a CLA counter. Source Code pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg","tags":"","loc":"proc/passed_clasg.html","title":"passed_clasg – FLAP"},{"text":"private  function defined_clasg(clasg, switch, pos) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a CLA counter. Source Code function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg","tags":"","loc":"proc/defined_clasg.html","title":"defined_clasg – FLAP"},{"text":"private  function usage_clasg(clasg, pref, no_header) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. Return Value character(len=:),\n    allocatable Usage string. Description Get correct CLAs group usage. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counters. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg","tags":"","loc":"proc/usage_clasg.html","title":"usage_clasg – FLAP"},{"text":"private  function signature_clasg(clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(in) :: clasg CLAs group data. Return Value character(len=:),\n    allocatable Temporary CLI signature. Description Get CLAs group signature for adding to the CLI one. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counters. Source Code function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg","tags":"","loc":"proc/signature_clasg.html","title":"signature_clasg – FLAP"},{"text":"private  function passed(cli, group, switch, position) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Description Check if a CLA has been passed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed","tags":"","loc":"proc/passed.html","title":"passed – FLAP"},{"text":"private  function defined_group(cli, group, g) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Description Check if a CLAs group has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: gg integer(kind=I4P), public :: ggg Counters. Source Code function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group","tags":"","loc":"proc/defined_group.html","title":"defined_group – FLAP"},{"text":"private  function called_group(cli, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Description Check if a CLAs group has been runned. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group","tags":"","loc":"proc/called_group.html","title":"called_group – FLAP"},{"text":"private  function defined(cli, switch, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Description Check if a CLA has been defined. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined","tags":"","loc":"proc/defined.html","title":"defined – FLAP"},{"text":"private  function usage(cli, g, pref, no_header, no_examples, no_epilog) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. Return Value character(len=:),\n    allocatable Usage string. Description Print correct usage of CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: no_headerd Avoid insert header to usage. logical, public :: no_examplesd Avoid insert examples to usage. logical, public :: no_epilogd Avoid insert epilogue to usage. integer(kind=I4P), public :: gi Counter. integer(kind=I4P), public :: e Counter. Source Code function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t , tt !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli function usage ( cli , g , pref , no_header , no_examples , no_epilog ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. integer ( I4P ), intent ( IN ) :: g !< Group index. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( IN ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( IN ) :: no_epilog !< Avoid insert epilogue to usage. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = cli % clasg ( g )% usage ( pref = prefd , no_header = no_headerd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // cli % help // cli % progname // ' ' // cli % signature () if ( cli % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // cli % description endif if ( cli % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // cli % clasg ( 0 )% usage ( pref = prefd , no_header = . true .) if ( size ( cli % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // cli % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % progname // ' ' // cli % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( cli % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( cli % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( cli % examples ( e )) enddo endif if ( cli % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // cli % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage","tags":"","loc":"proc/usage.html","title":"usage – FLAP"},{"text":"private  function signature(cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. Return Value character(len=:),\n    allocatable Temporary CLI signature. Description Get CLI signature. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t , tt !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli function usage ( cli , g , pref , no_header , no_examples , no_epilog ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. integer ( I4P ), intent ( IN ) :: g !< Group index. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( IN ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( IN ) :: no_epilog !< Avoid insert epilogue to usage. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = cli % clasg ( g )% usage ( pref = prefd , no_header = no_headerd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // cli % help // cli % progname // ' ' // cli % signature () if ( cli % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // cli % description endif if ( cli % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // cli % clasg ( 0 )% usage ( pref = prefd , no_header = . true .) if ( size ( cli % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // cli % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( cli % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // cli % progname // ' ' // cli % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( cli % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( cli % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( cli % examples ( e )) enddo endif if ( cli % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // cli % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( cli ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLI signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = cli % clasg ( 0 )% signature () if ( size ( cli % clasg , dim = 1 ) > 1 ) then signd = signd // ' {' // cli % clasg ( 1 )% group do g = 2 , size ( cli % clasg , dim = 1 ) - 1 signd = signd // ',' // cli % clasg ( g )% group enddo signd = signd // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature.html","title":"signature – FLAP"},{"text":"private pure subroutine tokenize(strin, delimiter, toks, Nt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens. Description Tokenize a string in order to parse it. Note The dummy array containing tokens must allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to char(0). Variables Type Visibility Attributes Name Initial character(len=len(strin)), public :: strsub Temporary string. integer(kind=I4P), public :: dlen Delimiter length. integer(kind=I4P), public :: c Counter. integer(kind=I4P), public :: n Counter. integer(kind=I4P), public :: t Counter. Source Code pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( IN ) :: strin !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( OUT ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( OUT ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = char ( 0 ) ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize","tags":"","loc":"proc/tokenize.html","title":"tokenize – FLAP"},{"text":"private elemental subroutine free_object(obj) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. Description Free dynamic memory. Source Code elemental subroutine free_object ( obj ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( obj % progname )) deallocate ( obj % progname ) if ( allocated ( obj % version )) deallocate ( obj % version ) if ( allocated ( obj % help )) deallocate ( obj % help ) if ( allocated ( obj % description )) deallocate ( obj % description ) if ( allocated ( obj % license )) deallocate ( obj % license ) if ( allocated ( obj % authors )) deallocate ( obj % authors ) if ( allocated ( obj % epilog )) deallocate ( obj % epilog ) if ( allocated ( obj % m_exclude )) deallocate ( obj % m_exclude ) obj % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object","tags":"","loc":"proc/free_object.html","title":"free_object – FLAP"},{"text":"private  subroutine errored(obj, error, pref, group, switch, val_str, log_value, a1, a2) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: obj Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. integer(kind=I4P), intent(in), optional :: a1 integer(kind=I4P), intent(in), optional :: a2 CLAs group inconsistent indexes. Description Trig error occurence and print meaningful message. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine errored ( obj , error , pref , group , switch , val_str , log_value , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. integer ( I4P ), intent ( IN ) :: error !< Error occurred. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Group name. character ( * ), optional , intent ( IN ) :: switch !< CLA switch name. character ( * ), optional , intent ( IN ) :: val_str !< Value string. character ( * ), optional , intent ( IN ) :: log_value !< Logical value to be casted. integer ( I4P ), optional , intent ( IN ) :: a1 , a2 !< CLAs group inconsistent indexes. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- obj % error = error if ( obj % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select type ( obj ) class is ( Type_Command_Line_Argument ) select case ( obj % error ) case ( error_cla_optional_no_def ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option has not a default value!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" has not a default value!' endif case ( error_cla_required_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( error_cla_positional_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( error_cla_named_no_name ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a non positional optiona must have a switch name!' case ( error_cla_positional_no_position ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have a position number different from 0!' case ( error_cla_positional_no_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( error_cla_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the options \"' // obj % switch // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been passed!' case ( error_cla_not_in_choices ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of \"' // trim ( str ( n = obj % position )) // & '-th\" positional option must be chosen in:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of named option \"' // obj % switch // '\" must be chosen in:' endif write ( stderr , '(A)' ) prefd // '(' // obj % choices // ')' write ( stderr , '(A)' ) prefd // '\"' // trim ( val_str ) // '\" has been passed!' case ( error_cla_missing_required ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" is required!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option is required!' endif case ( error_cla_casting_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // obj % switch // & '\" to logical type!' case ( error_cla_no_list ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" has not \"nargs\" value' // & ' but an array has been passed to \"get\" method!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( error_cla_nargs_insufficient ) if (. not . obj % positional ) then if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires at least ' // & '1 argument but no one remains!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif else if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires at least 1 argument but no one remains' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif endif case ( error_cla_value_missing ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" needs a value that is not passed!' case ( error_cla_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( error_cla_envvar_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( error_cla_envvar_not_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( error_cla_envvar_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( error_cla_store_star_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( error_cla_store_star_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( error_cla_store_star_envvar ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( error_cla_action_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has unknown \"' // obj % act // '\" action!' endselect class is ( Type_Command_Line_Arguments_Group ) select case ( obj % error ) case ( error_clasg_consistency ) if ( obj % group /= '' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: group (command) name: \"' // obj % group // '\" consistency error:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: consistency error:' endif write ( stderr , '(A)' ) prefd // ' \"' // trim ( str (. true ., a1 )) // '-th\" option has the same switch or abbreviated switch of \"' & // trim ( str (. true ., a2 )) // '-th\" option:' write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a1 )) // ') switches = ' // obj % cla ( a1 )% switch // ' ' // & obj % cla ( a1 )% switch_ab write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a2 )) // ') switches = ' // obj % cla ( a2 )% switch // ' ' // & obj % cla ( a2 )% switch_ab case ( error_clasg_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the group \"' // obj % group // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect class is ( Type_Command_Line_Interface ) select case ( obj % error ) case ( error_cli_missing_cla ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( error_cli_missing_selection_cla ) write ( stderr , '(A)' ) prefd // obj % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( error_cli_missing_group ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( error_cli_too_few_clas ) ! write(stderr,'(A)')prefd//obj%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,obj%Na_required))//')' endselect endselect write ( stderr , '(A)' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored","tags":"","loc":"proc/errored.html","title":"errored – FLAP"},{"text":"private  subroutine print_version(obj, pref) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(in) :: obj Object data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print version. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine print_version ( obj , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( IN ) :: obj !< Object data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) prefd // obj % progname // ' version ' // obj % version if ( obj % license /= '' ) then write ( stdout , '(A)' ) prefd // obj % license endif if ( obj % authors /= '' ) then write ( stdout , '(A)' ) prefd // obj % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version","tags":"","loc":"proc/print_version.html","title":"print_version – FLAP"},{"text":"private elemental subroutine assign_object(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Object ), intent(inout) :: lhs Left hand side. class( Type_Object ), intent(in) :: rhs Rigth hand side. Source Code elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: lhs !< Left hand side. class ( Type_Object ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude lhs % error = rhs % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object","tags":"","loc":"proc/assign_object.html","title":"assign_object – FLAP"},{"text":"private elemental subroutine free_cla(cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory. Source Code elemental subroutine free_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cla % free_object ! Type_Command_Line_Argument members if ( allocated ( cla % switch )) deallocate ( cla % switch ) if ( allocated ( cla % switch_ab )) deallocate ( cla % switch_ab ) if ( allocated ( cla % act )) deallocate ( cla % act ) if ( allocated ( cla % def )) deallocate ( cla % def ) if ( allocated ( cla % nargs )) deallocate ( cla % nargs ) if ( allocated ( cla % choices )) deallocate ( cla % choices ) if ( allocated ( cla % val )) deallocate ( cla % val ) if ( allocated ( cla % envvar )) deallocate ( cla % envvar ) cla % required = . false . cla % positional = . false . cla % position = 0_I4P cla % passed = . false . cla % hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_cla","tags":"","loc":"proc/free_cla.html","title":"free_cla – FLAP"},{"text":"private elemental subroutine finalize_cla(cla) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla","tags":"","loc":"proc/finalize_cla.html","title":"finalize_cla – FLAP"},{"text":"private  subroutine check_cla(cla, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla","tags":"","loc":"proc/check_cla.html","title":"check_cla – FLAP"},{"text":"private  subroutine check_choices_cla(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if CLA value is in allowed choices. Note This procedure can be called if and only if cla%choices has been allocated. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. character(len=len(cla%choices)), public, allocatable :: toks (:) Tokens for parsing choices list. integer(kind=I4P), public :: Nc Number of choices. logical, public :: val_in Flag for checking if val is in the choosen range. character(len=:), public, allocatable :: val_str Value in string form. character(len=:), public, allocatable :: tmp Temporary string for avoiding GNU gfrotran bug. integer(kind=I4P), public :: c Counter. Source Code subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo endselect if (. not . val_in ) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla","tags":"","loc":"proc/check_choices_cla.html","title":"check_choices_cla – FLAP"},{"text":"private  subroutine get_cla(cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val CLA value. Description Get CLA (single) value. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla","tags":"","loc":"proc/get_cla.html","title":"get_cla – FLAP"},{"text":"private  subroutine get_cla_list(cla, pref, val) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Description Get CLA (multiple) value. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list.html","title":"get_cla_list – FLAP"},{"text":"private  subroutine get_cla_list_varying_R16P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R16P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p.html","title":"get_cla_list_varying_R16P – FLAP"},{"text":"private  subroutine get_cla_list_varying_R8P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p.html","title":"get_cla_list_varying_R8P – FLAP"},{"text":"private  subroutine get_cla_list_varying_R4P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, real(R4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p.html","title":"get_cla_list_varying_R4P – FLAP"},{"text":"private  subroutine get_cla_list_varying_I8P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I8P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p.html","title":"get_cla_list_varying_I8P – FLAP"},{"text":"private  subroutine get_cla_list_varying_I4P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I4P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p.html","title":"get_cla_list_varying_I4P – FLAP"},{"text":"private  subroutine get_cla_list_varying_I2P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I2P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p.html","title":"get_cla_list_varying_I2P – FLAP"},{"text":"private  subroutine get_cla_list_varying_I1P(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, integer(I1P). Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p.html","title":"get_cla_list_varying_I1P – FLAP"},{"text":"private  subroutine get_cla_list_varying_logical(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, logical. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical.html","title":"get_cla_list_varying_logical – FLAP"},{"text":"private  subroutine get_cla_list_varying_char(cla, val, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: cla CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Description Get CLA (multiple) value with varying size, character. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Nv Number of values. character(len=len(cla%val)), public, allocatable :: valsV (:) String array of values based on cla%val. character(len=len(cla%def)), public, allocatable :: valsD (:) String array of values based on cla%def. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: v Values counter. Source Code subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char.html","title":"get_cla_list_varying_char – FLAP"},{"text":"private elemental subroutine assign_cla(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Argument ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Argument ), intent(in) :: rhs Rigth hand side. Source Code elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla","tags":"","loc":"proc/assign_cla.html","title":"assign_cla – FLAP"},{"text":"private elemental subroutine free_clasg(clasg) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory. Source Code elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg","tags":"","loc":"proc/free_clasg.html","title":"free_clasg – FLAP"},{"text":"private elemental subroutine finalize_clasg(clasg) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg","tags":"","loc":"proc/finalize_clasg.html","title":"finalize_clasg – FLAP"},{"text":"private  subroutine check_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check CLA data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a integer(kind=I4P), public :: aa Counters. Source Code subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg","tags":"","loc":"proc/check_clasg.html","title":"check_clasg – FLAP"},{"text":"private  subroutine check_required_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if required CLAs are passed. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg","tags":"","loc":"proc/check_required_clasg.html","title":"check_required_clasg – FLAP"},{"text":"private  subroutine check_m_exclusive_clasg(clasg, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs have been passed. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: a Counter. Source Code subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg","tags":"","loc":"proc/check_m_exclusive_clasg.html","title":"check_m_exclusive_clasg – FLAP"},{"text":"private  subroutine add_cla_clasg(clasg, pref, cla) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. type( Type_Command_Line_Argument ), intent(in) :: cla CLA data. Description Add CLA to CLAs list. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Argument ), public, allocatable :: cla_list_new (:) New (extended) CLA list. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: c Counter. Source Code subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg","tags":"","loc":"proc/add_cla_clasg.html","title":"add_cla_clasg – FLAP"},{"text":"private  subroutine parse_clasg(clasg, pref, args) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: clasg CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in) :: args (:) Command line arguments. Description Parse CLAs group arguments. Variables Type Visibility Attributes Name Initial character(len=500), public :: envvar Environment variables buffer. integer(kind=I4P), public :: arg Argument counter. integer(kind=I4P), public :: a Counter. integer(kind=I4P), public :: aa Counter. integer(kind=I4P), public :: aaa Counter. integer(kind=I4P), public :: nargs Number of arguments consumed by a CLA. character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if switch is a defined CLA. logical, public :: found_val Flag for checking if switch value is found. Source Code subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg","tags":"","loc":"proc/parse_clasg.html","title":"parse_clasg – FLAP"},{"text":"private elemental subroutine assign_clasg(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Arguments_Group ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Arguments_Group ), intent(in) :: rhs Right hand side. Source Code elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg","tags":"","loc":"proc/assign_clasg.html","title":"assign_clasg – FLAP"},{"text":"private elemental subroutine free(cli) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g Counter. Source Code elemental subroutine free_object ( obj ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( obj % progname )) deallocate ( obj % progname ) if ( allocated ( obj % version )) deallocate ( obj % version ) if ( allocated ( obj % help )) deallocate ( obj % help ) if ( allocated ( obj % description )) deallocate ( obj % description ) if ( allocated ( obj % license )) deallocate ( obj % license ) if ( allocated ( obj % authors )) deallocate ( obj % authors ) if ( allocated ( obj % epilog )) deallocate ( obj % epilog ) if ( allocated ( obj % m_exclude )) deallocate ( obj % m_exclude ) obj % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object subroutine errored ( obj , error , pref , group , switch , val_str , log_value , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: obj !< Object data. integer ( I4P ), intent ( IN ) :: error !< Error occurred. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Group name. character ( * ), optional , intent ( IN ) :: switch !< CLA switch name. character ( * ), optional , intent ( IN ) :: val_str !< Value string. character ( * ), optional , intent ( IN ) :: log_value !< Logical value to be casted. integer ( I4P ), optional , intent ( IN ) :: a1 , a2 !< CLAs group inconsistent indexes. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- obj % error = error if ( obj % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select type ( obj ) class is ( Type_Command_Line_Argument ) select case ( obj % error ) case ( error_cla_optional_no_def ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option has not a default value!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" has not a default value!' endif case ( error_cla_required_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // obj % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( error_cla_positional_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str ( n = obj % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( error_cla_named_no_name ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a non positional optiona must have a switch name!' case ( error_cla_positional_no_position ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have a position number different from 0!' case ( error_cla_positional_no_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( error_cla_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the options \"' // obj % switch // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been passed!' case ( error_cla_not_in_choices ) if ( obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of \"' // trim ( str ( n = obj % position )) // & '-th\" positional option must be chosen in:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: value of named option \"' // obj % switch // '\" must be chosen in:' endif write ( stderr , '(A)' ) prefd // '(' // obj % choices // ')' write ( stderr , '(A)' ) prefd // '\"' // trim ( val_str ) // '\" has been passed!' case ( error_cla_missing_required ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" is required!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option is required!' endif case ( error_cla_casting_logical ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // obj % switch // & '\" to logical type!' case ( error_cla_no_list ) if (. not . obj % positional ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" has not \"nargs\" value' // & ' but an array has been passed to \"get\" method!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( error_cla_nargs_insufficient ) if (. not . obj % positional ) then if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires at least ' // & '1 argument but no one remains!' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // '\" requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif else if ( obj % nargs == '+' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires at least 1 argument but no one remains' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // & '-th\" positional option requires ' // & trim ( adjustl ( obj % nargs )) // ' arguments but no enough ones remain!' endif endif case ( error_cla_value_missing ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" needs a value that is not passed!' case ( error_cla_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( error_cla_envvar_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( error_cla_envvar_not_store ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( error_cla_envvar_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( error_cla_store_star_positional ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: \"' // trim ( str (. true ., obj % position )) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( error_cla_store_star_nargs ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( error_cla_store_star_envvar ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( error_cla_action_unknown ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: named option \"' // trim ( adjustl ( obj % switch )) // & '\" has unknown \"' // obj % act // '\" action!' endselect class is ( Type_Command_Line_Arguments_Group ) select case ( obj % error ) case ( error_clasg_consistency ) if ( obj % group /= '' ) then write ( stderr , '(A)' ) prefd // obj % progname // ': error: group (command) name: \"' // obj % group // '\" consistency error:' else write ( stderr , '(A)' ) prefd // obj % progname // ': error: consistency error:' endif write ( stderr , '(A)' ) prefd // ' \"' // trim ( str (. true ., a1 )) // '-th\" option has the same switch or abbreviated switch of \"' & // trim ( str (. true ., a2 )) // '-th\" option:' write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a1 )) // ') switches = ' // obj % cla ( a1 )% switch // ' ' // & obj % cla ( a1 )% switch_ab write ( stderr , '(A)' ) prefd // ' CLA(' // trim ( str (. true ., a2 )) // ') switches = ' // obj % cla ( a2 )% switch // ' ' // & obj % cla ( a2 )% switch_ab case ( error_clasg_m_exclude ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: the group \"' // obj % group // '\" and \"' // obj % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect class is ( Type_Command_Line_Interface ) select case ( obj % error ) case ( error_cli_missing_cla ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( error_cli_missing_selection_cla ) write ( stderr , '(A)' ) prefd // obj % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( error_cli_missing_group ) write ( stderr , '(A)' ) prefd // obj % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( error_cli_too_few_clas ) ! write(stderr,'(A)')prefd//obj%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,obj%Na_required))//')' endselect endselect write ( stderr , '(A)' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored subroutine print_version ( obj , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( IN ) :: obj !< Object data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) prefd // obj % progname // ' version ' // obj % version if ( obj % license /= '' ) then write ( stdout , '(A)' ) prefd // obj % license endif if ( obj % authors /= '' ) then write ( stdout , '(A)' ) prefd // obj % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Object ), intent ( INOUT ) :: lhs !< Left hand side. class ( Type_Object ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude lhs % error = rhs % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object ! Type_Command_Line_Argument procedures elemental subroutine free_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cla % free_object ! Type_Command_Line_Argument members if ( allocated ( cla % switch )) deallocate ( cla % switch ) if ( allocated ( cla % switch_ab )) deallocate ( cla % switch_ab ) if ( allocated ( cla % act )) deallocate ( cla % act ) if ( allocated ( cla % def )) deallocate ( cla % def ) if ( allocated ( cla % nargs )) deallocate ( cla % nargs ) if ( allocated ( cla % choices )) deallocate ( cla % choices ) if ( allocated ( cla % val )) deallocate ( cla % val ) if ( allocated ( cla % envvar )) deallocate ( cla % envvar ) cla % required = . false . cla % positional = . false . cla % position = 0_I4P cla % passed = . false . cla % hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_cla elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo endselect if (. not . val_in ) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free – FLAP"},{"text":"private elemental subroutine finalize(cli) Arguments Type Intent Optional Attributes Name type( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. Description Free dynamic memory when finalizing. Source Code elemental subroutine finalize_cla ( cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cla % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_cla subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo endselect if (. not . val_in ) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FLAP"},{"text":"private  subroutine init(cli, progname, version, help, description, license, authors, examples, epilog, disable_hv) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. Description Initialize CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prog_invocation Complete program invocation. integer(kind=I4P), public :: invocation_length Length of invocation. integer(kind=I4P), public :: retrieval_status Retrieval status. Source Code subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FLAP"},{"text":"private  subroutine add_group(cli, help, description, exclude, group) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Description Add CLAs group to CLI. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Arguments_Group ), public, allocatable :: clasg_list_new (:) New (extended) CLAs group list. character(len=:), public, allocatable :: helpd Help message. character(len=:), public, allocatable :: descriptiond Detailed description. character(len=:), public, allocatable :: excluded Group name of the mutually exclusive group. integer(kind=I4P), public :: Ng Number of groups. Source Code subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group","tags":"","loc":"proc/add_group.html","title":"add_group – FLAP"},{"text":"private  subroutine set_mutually_exclusive_groups(cli, group1, group2) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Description Set two CLAs group ad mutually exclusive. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: g1 integer(kind=I4P), public :: g2 Counters. Source Code subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups","tags":"","loc":"proc/set_mutually_exclusive_groups.html","title":"set_mutually_exclusive_groups – FLAP"},{"text":"private  subroutine add(cli, pref, group, group_index, switch, switch_ab, help, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Add CLA to CLI. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. Note If CLA belongs to a not yet present group it is created on the fly. Variables Type Visibility Attributes Name Initial type( Type_Command_Line_Argument ), public :: cla CLA data. character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter. Source Code subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add","tags":"","loc":"proc/add.html","title":"add – FLAP"},{"text":"private  subroutine check(cli, pref, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Check CLAs data consistency. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g integer(kind=I4P), public :: gg Counters. Source Code subroutine check_cla ( cla , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( allocated ( cla % envvar )) then if ( cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_envvar_positional ) return endif if (. not . allocated ( cla % act )) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return else if ( cla % act /= action_store ) then call cla % errored ( pref = prefd , error = error_cla_envvar_not_store ) return endif endif if ( allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_envvar_nargs ) return endif endif if ( allocated ( cla % act )) then if ( cla % act == action_store_star . and . cla % positional ) then call cla % errored ( pref = prefd , error = error_cla_store_star_positional ) return endif if ( cla % act == action_store_star . and . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_store_star_nargs ) return endif if ( cla % act == action_store_star . and . allocated ( cla % envvar )) then call cla % errored ( pref = prefd , error = error_cla_store_star_envvar ) return endif if ( cla % act /= action_store . and . & cla % act /= action_store_star . and . & cla % act /= action_store_true . and . & cla % act /= action_store_false . and .& cla % act /= action_print_help . and . & cla % act /= action_print_vers ) then call cla % errored ( pref = prefd , error = error_cla_action_unknown ) return endif endif if ((. not . cla % required ). and .(. not . allocated ( cla % def ))) then call cla % errored ( pref = prefd , error = error_cla_optional_no_def ) return endif if (( cla % required ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_required_m_exclude ) return endif if (( cla % positional ). and .( cla % m_exclude /= '' )) then call cla % errored ( pref = prefd , error = error_cla_positional_m_exclude ) return endif if ((. not . cla % positional ). and .(. not . allocated ( cla % switch ))) then call cla % errored ( pref = prefd , error = error_cla_named_no_name ) return elseif (( cla % positional ). and .( cla % position == 0_I4P )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_position ) return elseif (( cla % positional ). and .( cla % act /= action_store )) then call cla % errored ( pref = prefd , error = error_cla_positional_no_store ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_cla subroutine check_choices_cla ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. class ( * ), intent ( IN ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. character ( len ( cla % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = cla % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo endselect if (. not . val_in ) then prefd = '' ; if ( present ( pref )) prefd = pref call cla % errored ( pref = prefd , error = error_cla_not_in_choices , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices_cla subroutine get_cla ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if ( cla % act == action_store . or . cla % act == action_store_star ) then if ( cla % passed . and . allocated ( cla % val )) then select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % val )), knd = 1_I1P ) type is ( logical ) read ( cla % val , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % val ) type is ( character ( * )) val = cla % val endselect elseif ( allocated ( cla % def )) then ! using default value select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( cla % def )), knd = 1_I1P ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) type is ( character ( * )) val = cla % def endselect endif if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val , pref = prefd ) elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( cla % def )) then select type ( val ) type is ( logical ) read ( cla % def , * , iostat = cla % error ) val if ( cla % error /= 0 ) call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = cla % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_list ( cla , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsV ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = valsD ( v ) if ( allocated ( cla % choices ). and . cla % error == 0 ) call cla % check_choices ( val = val ( v ), pref = prefd ) if ( cla % error /= 0 ) exit enddo endselect endif elseif ( cla % act == action_store_true ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( cla % act == action_store_false ) then if ( cla % passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list function check_list_size_cla ( cla , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), intent ( IN ) :: Nv !< Number of values. character ( * ), intent ( IN ) :: val !< First value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical :: is_ok !< Check result. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size_cla subroutine get_cla_list_varying_R16P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( cla % nargs == '+' ) then call cla % errored ( pref = prefd , error = error_cla_nargs_insufficient ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = prefd , error = cla % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( cla % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = cla % error ) val ( v ) if ( cla % error /= 0 ) then call cla % errored ( pref = prefd , error = error_cla_casting_logical , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( cla , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: cla !< CLA data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( cla % val )), allocatable :: valsV (:) !< String array of values based on cla%val. character ( len = len ( cla % def )), allocatable :: valsD (:) !< String array of values based on cla%def. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if (((. not . cla % passed ). and . cla % required ). or .((. not . cla % passed ). and .(. not . allocated ( cla % def )))) then call cla % errored ( pref = prefd , error = error_cla_missing_required ) return endif if (. not . allocated ( cla % nargs )) then call cla % errored ( pref = prefd , error = error_cla_no_list ) return endif if ( cla % act == action_store ) then if ( cla % passed ) then call tokenize ( strin = cla % val , delimiter = args_sep , toks = valsV , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = cla % def , delimiter = ' ' , toks = valsD , Nt = Nv ) if (. not . cla % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = prefd )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char function usage_cla ( cla , pref ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLA usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then prefd = '' ; if ( present ( pref )) prefd = pref if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then usage = '' select case ( cla % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str (. true ., a )) enddo endselect if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // usage // ', ' // trim ( adjustl ( cla % switch_ab )) // usage else usage = '   ' // trim ( adjustl ( cla % switch )) // usage endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ' value, ' // trim ( adjustl ( cla % switch_ab )) // ' value' else usage = '   ' // trim ( adjustl ( cla % switch )) // ' value' endif endif else usage = '  value' endif if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif elseif ( cla % act == action_store_star ) then usage = '  [value]' if ( allocated ( cla % choices )) then usage = usage // ', value in: (' // cla % choices // ')' endif else if ( trim ( adjustl ( cla % switch )) /= trim ( adjustl ( cla % switch_ab ))) then usage = '   ' // trim ( adjustl ( cla % switch )) // ', ' // trim ( adjustl ( cla % switch_ab )) else usage = '   ' // trim ( adjustl ( cla % switch )) endif endif usage = prefd // usage if ( cla % positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( str (. true ., cla % position )) // '-th argument' if ( allocated ( cla % envvar )) then if ( cla % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( cla % envvar )) // '\"' endif endif if (. not . cla % required ) then if ( cla % def /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'default value ' // trim ( adjustl ( cla % def )) endif endif if ( cla % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'mutually exclude \"' // cla % m_exclude // '\"' usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // trim ( adjustl ( cla % help )) else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_cla function signature_cla ( cla ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cla % hidden ) then if ( cla % act == action_store ) then if (. not . cla % positional ) then if ( allocated ( cla % nargs )) then select case ( cla % nargs ) case ( '+' ) signd = ' value#1 [value#2 value#3...]' case ( '*' ) signd = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( cla % nargs )), knd = 1_I4P ) signd = '' do a = 1 , nargs signd = signd // ' value#' // trim ( str (. true ., a )) enddo endselect else signd = ' value' endif if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) // signd else signd = ' [' // trim ( adjustl ( cla % switch )) // signd // ']' endif else if ( cla % required ) then signd = ' value' else signd = ' [value]' endif endif elseif ( cla % act == action_store_star ) then signd = ' [value]' else if ( cla % required ) then signd = ' ' // trim ( adjustl ( cla % switch )) else signd = ' [' // trim ( adjustl ( cla % switch )) // ']' endif endif else signd = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_cla elemental subroutine assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Argument ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Argument ), intent ( IN ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % required = rhs % required lhs % positional = rhs % positional lhs % position = rhs % position lhs % passed = rhs % passed lhs % hidden = rhs % hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cla ! Type_Command_Line_Arguments_Group procedures elemental subroutine free_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call clasg % free_object ! Type_Command_Line_Arguments_Group members if ( allocated ( clasg % group )) deallocate ( clasg % group ) if ( allocated ( clasg % cla )) then call clasg % cla % free deallocate ( clasg % cla ) endif clasg % Na = 0_I4P clasg % Na_required = 0_I4P clasg % Na_optional = 0_I4P clasg % called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_clasg elemental subroutine finalize_clasg ( clasg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call clasg % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize_clasg subroutine check_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a , aa !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! verifing if CLAs switches are unique CLA_unique : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then do aa = 1 , clasg % Na if (( a /= aa ). and .(. not . clasg % cla ( aa )% positional )) then if (( clasg % cla ( a )% switch == clasg % cla ( aa )% switch ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch ). or .& ( clasg % cla ( a )% switch == clasg % cla ( aa )% switch_ab ). or .( clasg % cla ( a )% switch_ab == clasg % cla ( aa )% switch_ab )) then call clasg % errored ( pref = prefd , error = error_clasg_consistency , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! updating mutually exclusive relations CLA_exclude : do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % defined ( switch = clasg % cla ( a )% m_exclude , pos = aa )) then clasg % cla ( aa )% m_exclude = clasg % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_clasg subroutine check_required_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( clasg % called ) then do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) then if (. not . clasg % cla ( a )% passed ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_missing_required ) clasg % error = clasg % cla ( a )% error write ( stdout , '(A)' ) clasg % usage ( pref = prefd ) return endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_required_clasg subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check.html","title":"check – FLAP"},{"text":"private  subroutine check_m_exclusive(cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Check if two mutually exclusive CLAs group have been called. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g integer(kind=I4P), public :: gg Counters. Source Code subroutine check_m_exclusive_clasg ( clasg , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref do a = 1 , clasg % Na if ( clasg % cla ( a )% passed ) then if ( clasg % cla ( a )% m_exclude /= '' ) then if ( clasg % passed ( switch = clasg % cla ( a )% m_exclude )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_m_exclude ) clasg % error = clasg % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive_clasg subroutine add_cla_clasg ( clasg , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. type ( Type_Command_Line_Argument ), intent ( IN ) :: cla !< CLA data. type ( Type_Command_Line_Argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % Na > 0_I4P ) then if (. not . cla % positional ) then allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , clasg % Na cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( clasg % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : clasg % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = clasg % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , clasg % Na + 1 cla_list_new ( c ) = clasg % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = clasg % cla ) clasg % Na = clasg % Na + 1 if ( cla % required ) then clasg % Na_required = clasg % Na_required + 1 else clasg % Na_optional = clasg % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) prefd = '' ; if ( present ( pref )) prefd = pref call clasg % check ( pref = prefd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_cla_clasg pure function passed_clasg ( clasg , switch , position ) result ( passed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if ( clasg % Na > 0 ) then if ( present ( switch )) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then passed = clasg % cla ( a )% passed exit endif endif enddo elseif ( present ( position )) then passed = clasg % cla ( position )% passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed_clasg function defined_clasg ( clasg , switch , pos ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( OUT ) :: pos !< CLA position. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if ( present ( pos )) pos = 0 if ( clasg % Na > 0 ) then do a = 1 , clasg % Na if (. not . clasg % cla ( a )% positional ) then if (( clasg % cla ( a )% switch == switch ). or .( clasg % cla ( a )% switch_ab == switch )) then defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_clasg subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive.html","title":"check_m_exclusive – FLAP"},{"text":"private  subroutine parse(cli, pref, args, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Note The leading and trailing white spaces are removed from CLA values. Note If the args argument is passed the command line arguments are taken from it and not from the actual program CLI\n invocations. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: g Counter for CLAs group. integer(kind=I4P), public, allocatable :: ai (:,:) Counter for CLAs grouped. Source Code subroutine parse_clasg ( clasg , pref , args ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAs group arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), intent ( IN ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( clasg % called ) then prefd = '' ; if ( present ( pref )) prefd = pref arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , clasg % Na ! loop ver CLAs group clas named options if (. not . clasg % cla ( a )% positional ) then if ( trim ( adjustl ( clasg % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( clasg % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then if ( clasg % cla ( a )% act == action_store ) then found_val = . false . if ( allocated ( clasg % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = clasg % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then clasg % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) then clasg % cla ( a )% val = clasg % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( clasg % cla ( a )% nargs )) then clasg % cla ( a )% val = '' select case ( clasg % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . clasg % defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( clasg % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_nargs_insufficient ) clasg % error = clasg % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug clasg % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( clasg % cla ( a )% val ) enddo arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call clasg % cla ( a )% errored ( pref = prefd , error = error_cla_value_missing ) clasg % error = clasg % cla ( a )% error return endif arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( clasg % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . clasg % defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 clasg % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . endif endif if (. not . found ) then ! flush default to val if environment is not set and default is set if ( allocated ( clasg % cla ( a )% def )) clasg % cla ( a )% val = clasg % cla ( a )% def endif elseif ( clasg % cla ( a )% act == action_print_help ) then clasg % error = status_clasg_print_h elseif ( clasg % cla ( a )% act == action_print_vers ) then clasg % error = status_clasg_print_v endif clasg % cla ( a )% passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . clasg % cla ( arg )% positional ) then ! current argument (arg-th) is not positional... there is a problem! call clasg % cla ( arg )% errored ( pref = prefd , error = error_cla_unknown , switch = trim ( adjustl ( args ( arg )))) clasg % error = clasg % cla ( arg )% error return else ! positional CLA always stores a value clasg % cla ( arg )% val = trim ( adjustl ( args ( arg ))) clasg % cla ( arg )% passed = . true . endif endif enddo call clasg % check_m_exclusive ( pref = prefd ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_clasg function usage_clasg ( clasg , pref , no_header ) result ( usage ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAs group usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. logical , optional , intent ( IN ) :: no_header !< Avoid insert header to usage. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref usage = clasg % progname ; if ( clasg % group /= '' ) usage = clasg % progname // ' ' // clasg % group usage = prefd // clasg % help // ' ' // usage // clasg % signature () if ( clasg % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // clasg % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( clasg % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , clasg % Na if ( clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif if ( clasg % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , clasg % Na if (. not . clasg % cla ( a )% required ) usage = usage // new_line ( 'a' ) // clasg % cla ( a )% usage ( pref = prefd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage_clasg function signature_clasg ( clasg ) result ( signd ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs group signature for adding to the CLI one. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: clasg !< CLAs group data. character ( len = :), allocatable :: signd !< Temporary CLI signature. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signd = '' do a = 1 , clasg % Na signd = signd // clasg % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature_clasg elemental subroutine assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Arguments_Group ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Arguments_Group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Arguments_Group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % called = rhs % called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_clasg ! Type_Command_Line_Interface procedures elemental subroutine free ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call cli % free_object ! Type_Command_Line_Interface members if ( allocated ( cli % clasg )) then do g = 1 , size ( cli % clasg , dim = 1 ) call cli % clasg ( g )% free enddo deallocate ( cli % clasg ) endif if ( allocated ( cli % examples )) deallocate ( cli % examples ) cli % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental subroutine finalize ( cli ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine init ( cli , progname , version , help , description , license , authors , examples , epilog , disable_hv ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: progname !< Program name. character ( * ), optional , intent ( IN ) :: version !< Program version. character ( * ), optional , intent ( IN ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( IN ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( IN ) :: license !< License description. character ( * ), optional , intent ( IN ) :: authors !< Authors list. character ( * ), optional , intent ( IN ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( IN ) :: epilog !< Epilog message. logical , optional , intent ( IN ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call cli % free if ( present ( progname )) then cli % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then cli % progname = prog_invocation else cli % progname = 'program' endif endif cli % version = 'unknown' ; if ( present ( version )) cli % version = version cli % help = 'usage: ' ; if ( present ( help )) cli % help = help cli % description = '' ; if ( present ( description )) cli % description = description cli % license = '' ; if ( present ( license )) cli % license = license cli % authors = '' ; if ( present ( authors )) cli % authors = authors cli % epilog = '' ; if ( present ( epilog )) cli % epilog = epilog if ( present ( disable_hv )) cli % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( cli % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: cli % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif cli % examples = examples endif ! initialize only the first default group allocate ( cli % clasg ( 0 : 0 )) call cli % clasg ( 0 )% assign_object ( cli ) cli % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( cli , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: help !< Help message. character ( * ), optional , intent ( IN ) :: description !< Detailed description. character ( * ), optional , intent ( IN ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( IN ) :: group !< Name of the grouped CLAs. type ( Type_Command_Line_Arguments_Group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . cli % defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( cli % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) clasg_list_new ( 0 : Ng - 1 ) = cli % clasg ( 0 : Ng - 1 ) call clasg_list_new ( Ng )% assign_object ( cli ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( cli % clasg ) allocate ( cli % clasg ( 0 : Ng )) cli % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( cli , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( IN ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 , g2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( cli % defined_group ( group = group1 , g = g1 ). and . cli % defined_group ( group = group2 , g = g2 )) then cli % clasg ( g1 )% m_exclude = group2 cli % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( cli , pref , group , group_index , switch , switch_ab , help , required , positional , position , hidden , act , def , nargs ,& choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( IN ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( IN ) :: help !< Help message describing the CLA. logical , optional , intent ( IN ) :: required !< Flag for set required argument. logical , optional , intent ( IN ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical , optional , intent ( IN ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( IN ) :: act !< CLA value action. character ( * ), optional , intent ( IN ) :: def !< Default value. character ( * ), optional , intent ( IN ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( IN ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( IN ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( IN ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. type ( Type_Command_Line_Argument ) :: cla !< CLA data. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initializing CLA call cla % assign_object ( cli ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % required = . false . ; if ( present ( required )) cla % required = required cla % positional = . false . ; if ( present ( positional )) cla % positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % hidden = . false . ; if ( present ( hidden )) cla % hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar prefd = '' ; if ( present ( pref )) prefd = pref call cla % check ( pref = prefd ) ; cli % error = cla % error if ( cli % error /= 0 ) then if ( present ( error )) error = cli % error return endif ! adding CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call cli % clasg ( 0 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( 0 )% error elseif ( present ( group )) then if ( cli % defined_group ( group = group , g = g )) then call cli % clasg ( g )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( g )% error else call cli % add_group ( group = group ) call cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( size ( cli % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( cli % clasg , dim = 1 ) - 1 ) then call cli % clasg ( group_index )% add ( pref = prefd , cla = cla ) ; cli % error = cli % clasg ( group_index )% error endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( cli , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLAs data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref do g = 0 , size ( cli % clasg , dim = 1 ) - 1 ! check group consistency call cli % clasg ( g )% check ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( present ( error )) error = cli % error if ( cli % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( cli % clasg ( g )% m_exclude /= '' ) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) cli % clasg ( gg )% m_exclude = cli % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g , gg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( cli % clasg , dim = 1 ) - 1 if ( cli % clasg ( g )% called . and .( cli % clasg ( g )% m_exclude /= '' )) then if ( cli % defined_group ( group = cli % clasg ( g )% m_exclude , g = gg )) then if ( cli % clasg ( gg )% called ) then prefd = '' ; if ( present ( pref )) prefd = pref call cli % clasg ( g )% errored ( pref = prefd , error = error_clasg_m_exclude ) cli % error = cli % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function passed ( cli , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. logical :: passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- passed = . false . if (. not . present ( group )) then if ( present ( switch )) then passed = cli % clasg ( 0 )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( 0 )% passed ( position = position ) endif else if ( cli % defined_group ( group = group , g = g )) then if ( present ( switch )) then passed = cli % clasg ( g )% passed ( switch = switch ) elseif ( present ( position )) then passed = cli % clasg ( g )% passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction passed function defined_group ( cli , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( OUT ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg , ggg !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( cli % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( cli % clasg ( gg )% group )) defined = ( cli % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined_group function called_group ( cli , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been runned. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( cli % defined_group ( group = group , g = g )) called = cli % clasg ( g )% called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction called_group function defined ( cli , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: switch !< Switch name. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLAs. logical :: defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . if (. not . present ( group )) then defined = cli % clasg ( 0 )% defined ( switch = switch ) else if ( cli % defined_group ( group = group , g = g )) defined = cli % clasg ( g )% defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction defined subroutine parse ( cli , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref ! add help and version switches if not done by user if (. not . cli % disable_hv ) then do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--help' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-h' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( cli % defined ( group = cli % clasg ( g )% group , switch = '--version' ). and . cli % defined ( group = cli % clasg ( g )% group , switch = '-v' ))) & call cli % add ( pref = prefd , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( cli % clasg , dim = 1 ) - 1 if (. not . cli % defined ( group = cli % clasg ( g )% group , switch = '--' )) & call cli % add ( pref = prefd , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parsing passed CLAs grouping in indexes if ( present ( args )) then call cli % get_args ( args = args , ai = ai ) else call cli % get_args ( ai = ai ) endif ! checking CLI consistency call cli % check ( pref = prefd ) if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! parsing cli do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) call cli % clasg ( g )% parse ( pref = prefd , args = cli % args ( ai ( g , 1 ): ai ( g , 2 ))) cli % error = cli % clasg ( g )% error if ( cli % error /= 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! trapping the special cases of version/help printing if ( cli % error == status_clasg_print_v ) then call cli % print_version ( pref = prefd ) stop elseif ( cli % error == status_clasg_print_h ) then write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = g ) stop endif ! checking if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call cli % clasg ( g )% check_required ( pref = prefd ) cli % error = cli % clasg ( g )% error if ( cli % error > 0 ) exit enddo if ( cli % error > 0 ) then if ( present ( error )) error = cli % error return endif ! check mutually exclusive interaction call cli % check_m_exclusive ( pref = prefd ) if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse.html","title":"parse – FLAP"},{"text":"private  subroutine get_clasg_indexes(cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na Number of command line arguments passed. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: aa Counter for CLAs. integer(kind=I4P), public :: g Counter for CLAs group. logical, public :: found Flag for inquiring if a named group is found. Source Code subroutine get_clasg_indexes ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( cli % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( cli % args )) then Na = size ( cli % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( cli % defined_group ( group = trim ( cli % args ( a )), g = g )) then found = . true . cli % clasg ( g )% called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( cli % defined_group ( group = trim ( cli % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 cli % clasg ( 0 )% called = . true . elseif ( all ( ai == 0 )) then cli % clasg ( 0 )% called = . true . endif else cli % clasg ( 0 )% called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes","tags":"","loc":"proc/get_clasg_indexes.html","title":"get_clasg_indexes – FLAP"},{"text":"private  subroutine get_args_from_string(cli, args, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from string. Variables Type Visibility Attributes Name Initial character(len=len_trim(args)), public :: argsd Dummy string containing command line arguments. character(len=len_trim(args)), public, allocatable :: toks (:) CLAs tokenized. integer(kind=I4P), public :: Nt Number of tokens. integer(kind=I4P), public :: Na Number of command line arguments passed. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: t Counter for tokens. integer(kind=I4P), public :: c Counter for characters inside tokens. Functions function sanitize_args(argsin, delimiter) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: argsin Arguments string. character(len=*), intent(in) :: delimiter Delimiter enclosing string argument. Return Value character(len=len_trim(argsin)) Arguments string sanitized. Description Sanitize arguments string. Source Code subroutine get_args_from_string ( cli , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), intent ( IN ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare cli arguments list if ( allocated ( cli % args )) deallocate ( cli % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate cli arguments list #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: cli % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 cli % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: argsin !< Arguments string. character ( * ), intent ( IN ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t , tt !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string","tags":"","loc":"proc/get_args_from_string.html","title":"get_args_from_string – FLAP"},{"text":"private  subroutine get_args_from_invocation(cli, ai) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Description Get CLAs from CLI invocation. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: Na Number of command line arguments passed. character(len=max_val_len), public :: switch Switch name. integer(kind=I4P), public :: a Counter for CLAs. integer(kind=I4P), public :: aa Counter for CLAs. Source Code subroutine get_args_from_invocation ( cli , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( cli % args )) deallocate ( cli % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( cli % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: cli % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) cli % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call cli % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation","tags":"","loc":"proc/get_args_from_invocation.html","title":"get_args_from_invocation – FLAP"},{"text":"private  subroutine get_cla_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA (single) value from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val !< CLA value. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( cli % error == 0. and . cli % clasg ( g )% called ) then if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( position )% error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_cli","tags":"","loc":"proc/get_cla_cli.html","title":"get_cla_cli – FLAP"},{"text":"private  subroutine get_cla_list_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. class ( * ), intent ( INOUT ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_cli","tags":"","loc":"proc/get_cla_list_cli.html","title":"get_cla_list_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_R16P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R16P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R16P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P_cli","tags":"","loc":"proc/get_cla_list_varying_r16p_cli.html","title":"get_cla_list_varying_R16P_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_R8P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P_cli","tags":"","loc":"proc/get_cla_list_varying_r8p_cli.html","title":"get_cla_list_varying_R8P_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_R4P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_R4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. real ( R4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P_cli","tags":"","loc":"proc/get_cla_list_varying_r4p_cli.html","title":"get_cla_list_varying_R4P_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_I8P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I8P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I8P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P_cli","tags":"","loc":"proc/get_cla_list_varying_i8p_cli.html","title":"get_cla_list_varying_I8P_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_I4P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I4P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P_cli","tags":"","loc":"proc/get_cla_list_varying_i4p_cli.html","title":"get_cla_list_varying_I4P_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_I2P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I2P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I2P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P_cli","tags":"","loc":"proc/get_cla_list_varying_i2p_cli.html","title":"get_cla_list_varying_I2P_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_I1P_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_I1P_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. integer ( I1P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P_cli","tags":"","loc":"proc/get_cla_list_varying_i1p_cli.html","title":"get_cla_list_varying_I1P_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_logical_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, logical. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_logical_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. logical , allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical_cli","tags":"","loc":"proc/get_cla_list_varying_logical_cli.html","title":"get_cla_list_varying_logical_cli – FLAP"},{"text":"private  subroutine get_cla_list_varying_char_cli(cli, val, pref, group, switch, position, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: cli CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Get CLA multiple values from CLAs list parsed with varying size list, character. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. logical, public :: found Flag for checking if CLA containing switch has been found. integer(kind=I4P), public :: g Group counter. integer(kind=I4P), public :: a Argument counter. Source Code subroutine get_cla_list_varying_char_cli ( cli , val , pref , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: cli !< CLI data. character ( * ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( * ), optional , intent ( IN ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( IN ) :: switch !< Switch name. integer ( I4P ), optional , intent ( IN ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref if ( present ( group )) then if (. not . cli % defined_group ( group = group , g = g )) then call cli % errored ( pref = prefd , error = error_cli_missing_group , group = group ) endif else g = 0 endif if ( present ( switch )) then ! searching for the CLA corresponding to switch found = . false . do a = 1 , cli % clasg ( g )% Na if (. not . cli % clasg ( g )% cla ( a )% positional ) then if (( cli % clasg ( g )% cla ( a )% switch == switch ). or .( cli % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call cli % errored ( pref = prefd , error = error_cli_missing_cla , switch = switch ) else call cli % clasg ( g )% cla ( a )% get_varying ( pref = prefd , val = val ) ; cli % error = cli % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call cli % clasg ( g )% cla ( position )% get_varying ( pref = prefd , val = val ) ; cli % error = error else call cli % errored ( pref = prefd , error = error_cli_missing_selection_cla ) endif if ( present ( error )) error = cli % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char_cli","tags":"","loc":"proc/get_cla_list_varying_char_cli.html","title":"get_cla_list_varying_char_cli – FLAP"},{"text":"private  subroutine print_usage(cli, pref) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Description Print correct usage of CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. Source Code subroutine print_usage ( cli , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( stdout , '(A)' ) cli % usage ( pref = prefd , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage","tags":"","loc":"proc/print_usage.html","title":"print_usage – FLAP"},{"text":"private  subroutine save_man_page(cli, man_file, error) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(in) :: cli CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Description Save man page build on the CLI. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: man Man page. integer(kind=I4P), public :: idate (1:8) Integer array for handling the date. integer(kind=I4P), public :: e Counter. integer(kind=I4P), public :: u Unit file handler. character(len=*), public, parameter :: month (12) = [\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\",\"Jan\"] Source Code subroutine save_man_page ( cli , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( IN ) :: cli !< CLI data. character ( * ), intent ( IN ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // cli % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // cli % version // & '\" \"' // cli % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // cli % progname // ' - manual page for ' // cli % progname // ' version ' // cli % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // cli % progname // new_line ( 'a' ) // trim ( adjustl ( cli % signature ())) if ( cli % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // cli % description if ( cli % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // cli % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( cli % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( cli % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( cli % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( cli % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // cli % authors if ( cli % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // cli % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page","tags":"","loc":"proc/save_man_page.html","title":"save_man_page – FLAP"},{"text":"private elemental subroutine assign_cli(lhs, rhs) Arguments Type Intent Optional Attributes Name class( Type_Command_Line_Interface ), intent(inout) :: lhs Left hand side. type( Type_Command_Line_Interface ), intent(in) :: rhs Right hand side. Source Code elemental subroutine assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- class ( Type_Command_Line_Interface ), intent ( INOUT ) :: lhs !< Left hand side. type ( Type_Command_Line_Interface ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Type_Object members call lhs % assign_object ( rhs ) ! Type_Command_Line_Interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_cli","tags":"","loc":"proc/assign_cli.html","title":"assign_cli – FLAP"},{"text":"Uses: iso_fortran_env Pure Fortran (2003+) library for ensuring codes portability Variables Type Visibility Attributes Name Initial logical, public :: ir_initialized = .false. Flag for chcecking the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(33,4931) 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. integer, public, parameter :: R16P = selected_real_kind(15,307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15,307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6,37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=10), public, parameter :: FR16P = '(E42.33E4)' Output format for kind=R16P variable. character(len=10), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P variable. character(len=9), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P variable. character(len=10), public, parameter :: FR_P = FR8P Output format for kind=R_P variable. integer, public, parameter :: DR16P = 42 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. character(len=5), public, parameter :: FI8P = '(I20)' Output format                     for kind=I8P variable. character(len=8), private, parameter :: FI8PZP = '(I20.19)' Output format with zero prefixing for kind=I8P variable. character(len=5), public, parameter :: FI4P = '(I11)' Output format                     for kind=I4P variable. character(len=8), private, parameter :: FI4PZP = '(I11.10)' Output format with zero prefixing for kind=I4P variable. character(len=4), public, parameter :: FI2P = '(I6)' Output format                     for kind=I2P variable. character(len=6), private, parameter :: FI2PZP = '(I6.5)' Output format with zero prefixing for kind=I2P variable. character(len=4), public, parameter :: FI1P = '(I4)' Output format                     for kind=I1P variable. character(len=6), private, parameter :: FI1PZP = '(I4.3)' Output format with zero prefixing for kind=I1P variable. character(len=5), public, parameter :: FI_P = FI4P Output format                     for kind=I_P variable. character(len=8), private, parameter :: FI_PZP = FI4PZP Output format with zero prefixing for kind=I_P variable. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: NRknd = 4 Number of defined real kinds. integer, public, parameter :: RPl (1:NRknd) = [R16P,R8P,R4P,R_P] List of defined real kinds. character(len=10), public, parameter :: FRl (1:NRknd) = [FR16P,FR8P,FR4P//' ',FR_P] List of defined real kinds output format. integer, public, parameter :: NIknd = 5 Number of defined integer kinds. integer, public, parameter :: RIl (1:NIknd) = [I8P,I4P,I2P,I1P,I_P] List of defined integer kinds. character(len=5), public, parameter :: FIl (1:NIknd) = [FI8P,FI4P,FI2P//' ',FI1P//' ',FI_P] List of defined integer kinds output format. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P variable. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P variable. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P variable. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P variable. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P variable. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P variable. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P variable. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P variable. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P variable. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P variable. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P variable. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P variable. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P variable. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P variable. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P variable. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P variable. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest (module) representable value of kind=R16P variable. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest (module) representable value of kind=R8P variable. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest (module) representable value of kind=R4P variable. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest (module) representable value of kind=R_P variable. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P variable. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P variable. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P variable. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P variable. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P variable. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P variable. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P variable. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P variable. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P variable. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P variable. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P variable. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P variable. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P variable. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P variable. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P variable. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P variable. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P variable. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P variable. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P variable. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P variable. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P,1._R16P)-nearest(1._R16P,-1._R16P) Smallest representable difference of kind=R16P variable. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P,1._R8P)-nearest(1._R8P,-1._R8P) Smallest representable difference of kind=R8P variable. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P,1._R4P)-nearest(1._R4P,-1._R4P) Smallest representable difference of kind=R4P variable. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P variable. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable. public interface byte_size Overloading of the byte_size function for computing the number of bytes. private elemental function byte_size_I8P (i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I4P (i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I2P (i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I1P (i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable. public interface str Procedure for converting number, real and integer, to string (number to string type casting). private elemental function strf_R16P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R16P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_I8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I2P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I2P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I1P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I1P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_bol (n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. private pure function str_a_R16P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_I8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I2P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I1P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. public interface strz Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type\n casting with zero padding). private elemental function strz_I8P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I4P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I2P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I1P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. public interface cton Procedure for converting string to number, real or initeger, (string to number type casting). private  function ctor_R16P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctoi_I8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I2P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I1P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. public interface bstr Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). private elemental function bstr_R16P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R8P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R4P (n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_I8P (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I4P (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I2P (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I1P (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. public interface bcton Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). None() Arguments None private elemental function bctor_R8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctor_R4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctoi_I8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I2P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I1P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. public interface digit Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer.","tags":"","loc":"module/ir_precision.html","title":"IR_Precision – FLAP"},{"text":"Uses: IR_Precision iso_fortran_env FLAP, Fortran command Line Arguments Parser for poor people FLAP FLAP, Fortran command Line Arguments Parser for poor people A KISS pure Fortran Library for building powerful, easy-to-use, elegant command line interfaces FLAP is a pure Fortran (KISS) library for building easily nice Command Line Interfaces (CLI) for modern Fortran projects; FLAP is Fortran 2003+ standard compliant; FLAP is OOP designed; FLAP is a Free, Open Source Project. Table of Contents What is FLAP? Main features Copyrights Documentation A Taste of FLAP Issues Compiler Support What is FLAP? Modern Fortran standards (2003+) have introduced support for Command Line Arguments (CLA), thus it is possible to construct nice and effective Command Line Interfaces (CLI). FLAP is a small library designed to simplify the (repetitive) construction of complicated CLI in pure Fortran (standard 2003+). FLAP has been inspired by the python module argparse trying to mimic it. Once you have defined the arguments that are required by means of a user-friendly method of the CLI, FLAP will parse the CLAs for you. It is worthy of note that FLAP, as argparse , also automatically generates help and usage messages and issues errors when users give the program invalid arguments. Go to Top Main features FLAP is inspired by the python great module argparse , thus many features are taken from it. Here the main features are listed. User-friendly methods for building flexible and effective Command Line Interfaces (CLI); comprehensive Command Line Arguments (CLA) support: support optional and non optional CLA; support boolean CLA; support positional CLA; support list of allowable values for defined CLA with automatic consistency check; support multiple valued (list of values, aka list-valued) CLA: compiletime sized list, e.g. nargs='3' ; runtime sized list with at least 1 value, e.g. nargs='+' ; runtime sized list with any size, even empty, e.g. nargs='*' ; support mutually exclusive CLAs; self-consistency-check of CLA definition; support fake CLAs input from a string; support fake CLAs input from environment variables; comprehensive command (group of CLAs) support: support nested subcommands; support mutually exclusive commands; self-consistency-check of command definition; automatic generation of help and usage messages; consistency-check of whole CLI definition; errors trapping for invalid CLI usage; POSIX style compliant; automatic generation of MAN PAGE using your CLI definition!; replicate all the useful features of argparse ; implement docopt features. implement click features. Any feature request is welcome. Go to Top Copyrights FLAP is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FLAP is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FLAP documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FLAP Running the provided test program, Test_Driver -h , a taste of FLAP is served: usage:  Test_Driver [value] --string value [--integer value] [--real value] [--boolean] [--boolean_val value] [--integer_list value#1 value#2 value#3] [--help] [--version]\n\nToy program for testing FLAP\n\nRequired switches:\n   --string value, -s value\n          String input\n\nOptional switches:\n   value\n          1-th argument\n          default value 1.0\n          Positional real input\n   --integer value, -i value, value in: (1,3,5)\n          default value 1\n          Integer input with fixed range\n   --real value, -r value\n          default value 1.0\n          Real input\n   --boolean, -b\n          default value .false.\n          Boolean input\n   --boolean_val value, -bv value\n          default value .true.\n          Valued boolean input\n   --integer_list value#1 value#2 value#3, -il value#1 value#2 value#3\n          default value 1 8 32\n          Integer list input\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nExamples:\n   Test_Driver -s 'Hello FLAP'\n   Test_Driver -s 'Hello FLAP' -i -2 # printing error...\n   Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0\n   Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87\n   Test_Driver 33.0 -s 'Hello FLAP' -i 5\n   Test_Driver --string 'Hello FLAP' --boolean Not so bad for just a very few statements as the following: ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP' , & examples = [ \"Test_Driver -s 'Hello FLAP'                          \" ,& \"Test_Driver -s 'Hello FLAP' -i -2 # printing error...\" ,& \"Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0            \" ,& \"Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87  \" ,& \"Test_Driver 33.0 -s 'Hello FLAP' -i 5                \" ,& \"Test_Driver --string 'Hello FLAP' --boolean          \" ]) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) For more details, see the provided example . For a practical example of FLAP usage see POG source file at line 85 . Nested (sub)commands FLAP fully supports nested (sub)commands or groups of command line arguments. For example a fake git toy remake can be coded as ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver_Nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'Test_Driver_Nested                      ' ,& 'Test_Driver_Nested -h                   ' ,& 'Test_Driver_Nested init                 ' ,& 'Test_Driver_Nested commit -m \"fix bug-1\"' ,& 'Test_Driver_Nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif that when invoked without arguments prompts: cowardly you are doing nothing... try at least \"-h\" option! and invoked with -h option gives: usage: Test_Driver_Nested [ --authors ] [ --help ] [ --version ] { init,commit,tag } ...\n\nToy program for testing FLAP with nested commands\n\nOptional switches:\n   --authors, -a\n          default value .false.\n          Print authors names\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nCommands:\n  init\n          fake init versioning\n  commit\n          fake commit changes to current branch\n  tag\n          fake tag current commit\n\nFor more detailed commands help try:\n  Test_Driver_Nested init -h,--help\n  Test_Driver_Nested commit -h,--help\n  Test_Driver_Nested tag -h,--help\n\nExamples:\n   Test_Driver_Nested\n   Test_Driver_Nested -h\n   Test_Driver_Nested init\n   Test_Driver_Nested commit -m \"fix bug-1\" Test_Driver_Nested tag -a \"v2.1.5\" For more details, see the provided example . Go to Top ChangeLog Variables Type Visibility Attributes Name Initial integer(kind=I4P), private, parameter :: max_val_len = 1000 Maximum number of characters of CLA value. character(len=*), private, parameter :: action_store = 'STORE' CLA that stores value (if invoked a value must be passed). character(len=*), private, parameter :: action_store_star = 'STORE*' CLA that stores value or revert on default is invoked alone. character(len=*), private, parameter :: action_store_true = 'STORE_TRUE' CLA that stores .true. without the necessity of a value. character(len=*), private, parameter :: action_store_false = 'STORE_FALSE' CLA that stores .false. without the necessity of a value. character(len=*), private, parameter :: action_print_help = 'PRINT_HELP' CLA that print help message. character(len=*), private, parameter :: action_print_vers = 'PRINT_VERSION' CLA that print version. character(len=*), private, parameter :: args_sep = '||!||' Arguments separator for multiple valued (list) CLA. integer(kind=I4P), private, parameter :: error_cla_optional_no_def = 1 Optional CLA without default value. integer(kind=I4P), private, parameter :: error_cla_required_m_exclude = 2 Required CLA cannot exclude others. integer(kind=I4P), private, parameter :: error_cla_positional_m_exclude = 3 Positional CLA cannot exclude others. integer(kind=I4P), private, parameter :: error_cla_named_no_name = 4 Named CLA without switch name. integer(kind=I4P), private, parameter :: error_cla_positional_no_position = 5 Positional CLA without position. integer(kind=I4P), private, parameter :: error_cla_positional_no_store = 6 Positional CLA without action_store. integer(kind=I4P), private, parameter :: error_cla_not_in_choices = 7 CLA value out of a specified choices. integer(kind=I4P), private, parameter :: error_cla_missing_required = 8 Missing required CLA. integer(kind=I4P), private, parameter :: error_cla_m_exclude = 9 Two mutually exclusive CLAs have been passed. integer(kind=I4P), private, parameter :: error_cla_casting_logical = 10 Error casting CLA value to logical type. integer(kind=I4P), private, parameter :: error_cla_no_list = 11 Actual CLA is not list-values. integer(kind=I4P), private, parameter :: error_cla_nargs_insufficient = 12 Multi-valued CLA with insufficient arguments. integer(kind=I4P), private, parameter :: error_cla_value_missing = 13 Missing value of CLA. integer(kind=I4P), private, parameter :: error_cla_unknown = 14 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: error_cla_envvar_positional = 15 Envvar not allowed for positional CLA. integer(kind=I4P), private, parameter :: error_cla_envvar_not_store = 16 Envvar not allowed action different from store; integer(kind=I4P), private, parameter :: error_cla_envvar_nargs = 17 Envvar not allowed for list-values CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_positional = 18 Action store* not allowed for positional CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_nargs = 19 Action store* not allowed for list-values CLA. integer(kind=I4P), private, parameter :: error_cla_store_star_envvar = 20 Action store* not allowed for environment variable CLA. integer(kind=I4P), private, parameter :: error_cla_action_unknown = 21 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: error_clasg_consistency = 22 CLAs group consistency error. integer(kind=I4P), private, parameter :: error_clasg_m_exclude = 23 Two mutually exclusive CLAs group have been called. integer(kind=I4P), private, parameter :: error_cli_missing_cla = 24 CLA not found in CLI. integer(kind=I4P), private, parameter :: error_cli_missing_group = 25 Group not found in CLI. integer(kind=I4P), private, parameter :: error_cli_missing_selection_cla = 26 CLA selection in CLI failing. integer(kind=I4P), private, parameter :: error_cli_too_few_clas = 27 Insufficient arguments for CLI. integer(kind=I4P), private, parameter :: status_clasg_print_v = -1 Print version status. integer(kind=I4P), private, parameter :: status_clasg_print_h = -2 Print help status. Derived Types type, private :: Type_Object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), private, allocatable :: help Help message. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilog message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). integer(kind=I4P), public :: error = 0_I4P Error traping flag. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. procedure, public :: errored Trig error occurence and print meaningful message. procedure, public :: print_version Print version. procedure, public :: assign_object Assignment overloading. type, private, extends( Type_Object ) :: Type_Command_Line_Argument Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: switch Switch name. character(len=:), private, allocatable :: switch_ab Abbreviated switch name. logical, private :: required = .false. Flag for set required argument. logical, private :: positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), private :: position = 0_I4P Position of positional CLA. logical, private :: passed = .false. Flag for checking if CLA has been passed to CLI. logical, private :: hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), private, allocatable :: act CLA value action. character(len=:), private, allocatable :: def Default value. character(len=:), private, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), private, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), private, allocatable :: val CLA value. character(len=:), private, allocatable :: envvar Environment variable from which take value. Finalizations Procedures final :: finalize_cla","tags":"","loc":"module/data_type_command_line_interface.html","title":"Data_Type_Command_Line_Interface – FLAP"},{"text":"Uses: IR_Precision Data_Type_Command_Line_Interface A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Variables Type Attributes Name Initial type( Type_Command_Line_Interface ) :: cli Command Line Interface (CLI). logical :: authors_print Boolean value. character(len=500) :: message Message value. integer(kind=I4P) :: error Error trapping flag. Source Code program Test_Driver_Nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- authors_print = . false . ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver_Nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'Test_Driver_Nested                      ' ,& 'Test_Driver_Nested -h                   ' ,& 'Test_Driver_Nested init                 ' ,& 'Test_Driver_Nested commit -m \"fix bug-1\"' ,& 'Test_Driver_Nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver_Nested","tags":"","loc":"program/test_driver_nested.html","title":"Test_Driver_Nested – FLAP"},{"text":"Uses: IR_Precision Data_Type_Command_Line_Interface A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Variables Type Attributes Name Initial type( Type_Command_Line_Interface ) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program Test_Driver !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP' , & examples = [ \"Test_Driver -s 'Hello FLAP'                               \" , & \"Test_Driver -s 'Hello FLAP' -i -2 # printing error...     \" , & \"Test_Driver -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"Test_Driver 33.0 -s 'Hello FLAP' -i 5                     \" , & \"Test_Driver --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parsing Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set Test_Driver behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Test_Driver has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"program/test_driver.html","title":"Test_Driver – FLAP"},{"text":"Uses: IR_Precision Data_Type_Command_Line_Interface A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Variables Type Attributes Name Initial type( Type_Command_Line_Interface ) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. integer(kind=I4P) :: envi Environment set integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. real(kind=R8P), allocatable :: vlistR8P (:) Varying size real list values. real(kind=R4P), allocatable :: vlistR4P (:) Varying size real list values. integer(kind=I8P), allocatable :: vlistI8P (:) Varying size integer list values. integer(kind=I4P), allocatable :: vlistI4P (:) Varying size integer list values. integer(kind=I2P), allocatable :: vlistI2P (:) Varying size integer list values. integer(kind=I1P), allocatable :: vlistI1P (:) Varying size integer list values. logical, allocatable :: vlistBool (:) Varying size boolean list values. character(len=10), allocatable :: vlistChar (:) Varying size character list values. character(len=99), allocatable :: garbage (:) Varying size character list for trailing garbage values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program Test_Driver !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- USE IR_Precision ! Integers and reals precision definition. USE Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface ! Definition of Type_Command_Line_Interface. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initializing Command Line Interface call cli % init ( progname = 'Test_Driver' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"Test_Driver -s 'Hello FLAP'                               \" , & \"Test_Driver -s 'Hello FLAP' -i -2 # printing error...     \" , & \"Test_Driver -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"Test_Driver -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"Test_Driver -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"Test_Driver -s 'Hello FLAP' --man_file FLAP.1             \" , & \"Test_Driver 33.0 -s 'Hello FLAP' -i 5                     \" , & \"Test_Driver --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! setting Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'Test_Driver.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) stop ! using Command Line Interface data to set Test_Driver behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Test_Driver has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str (. true ., l )) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str (. true ., l )) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str (. true ., l )) // ') = ' // garbage ( l ) enddo endif if ( cli % passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"program/test_driver.html","title":"Test_Driver – FLAP"}]}