var tipuesearch = {"pages":[{"text":"FLAP FLAP FLAP, Fortran command Line Arguments Parser for poor people A KISS pure Fortran Library for building powerful, easy-to-use, elegant command line interfaces FLAP is a pure Fortran (KISS) library for building easily nice Command Line Interfaces (CLI) for modern Fortran projects; FLAP is Fortran 2003+ standard compliant; FLAP is OOP designed; FLAP is a Free, Open Source Project. Issues Compiler Support | What is FLAP? | Main features | Copyrights | Documentation | Download & Compile | What is FLAP? Modern Fortran standards (2003+) have introduced support for Command Line Arguments (CLA), thus it is possible to construct nice and effective Command Line Interfaces (CLI). FLAP is a small library designed to simplify the (repetitive) construction of complicated CLI in pure Fortran (standard 2003+). FLAP has been inspired by the python module argparse trying to mimic it. Once you have defined the arguments that are required by means of a user-friendly method of the CLI, FLAP will parse the CLAs for you. It is worthy of note that FLAP, as argparse , also automatically generates help and usage messages and issues errors when users give the program invalid arguments. Go to Top Main features FLAP is inspired by the python great module argparse , thus many features are taken from it. Here the main features are listed. User-friendly methods for building flexible and effective Command Line Interfaces (CLI); comprehensive Command Line Arguments (CLA) support: support optional and non optional CLA; support boolean CLA; support positional CLA; support list of allowable values for defined CLA with automatic consistency check; support multiple valued (list of values, aka list-valued) CLA: compiletime sized list, e.g. nargs='3' ; runtime sized list with at least 1 value, e.g. nargs='+' ; runtime sized list with any size, even empty, e.g. nargs='*' ; support mutually exclusive CLAs; self-consistency-check of CLA definition; support fake CLAs input from a string; support fake CLAs input from environment variables; comprehensive command (group of CLAs) support: support nested subcommands; support mutually exclusive commands; self-consistency-check of command definition; automatic generation of help and usage messages; consistency-check of whole CLI definition; errors trapping for invalid CLI usage; POSIX style compliant; automatic generation of MAN PAGE using your CLI definition!; replicate all the useful features of argparse ; implement docopt features. implement click features. Any feature request is welcome. Go to Top Copyrights FLAP is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FLAP is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FLAP documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FLAP A minimal plate : program minimal type ( command_line_interface ) :: cli ! Command Line Interface (CLI). character ( 99 ) :: string ! String value. integer :: error ! Error trapping flag. call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , & switch_ab = '-s' , & help = 'a string' , & required = . true ., & act = 'store' , & error = error ) if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) endprogram minimal That built and run provides: → ./minimal\n./minimal: error: named option \"--string\" is required!\n\nusage:  ./exe/test_minimal --string value [ --help ] [ --version ] minimal FLAP example\n\nRequired switches:\n   --string value, -s value\n    a string\n\nOptional switches:\n   --help, -h\n    Print this help message\n   --version, -v\n    Print version A nice automatic help-message, right? Executed correctly gives. → ./minimal --string 'hello world' ./exe/minimal has been called with the following argument: String = hello world For more details, see the provided tests . Nested (sub)commands FLAP fully supports nested (sub)commands or groups of command line arguments. For example a fake git toy remake can be coded as ! initializing Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' ,& examples = [ 'test_nested                      ' ,& 'test_nested -h                   ' ,& 'test_nested init                 ' ,& 'test_nested commit -m \"fix bug-1\"' ,& 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif that when invoked without arguments prompts: cowardly you are doing nothing... try at least \"-h\" option! and invoked with -h option gives: usage: test_nested [ --authors ] [ --help ] [ --version ] { init,commit,tag } ...\n\nToy program for testing FLAP with nested commands\n\nOptional switches:\n   --authors, -a\n          default value .false.\n          Print authors names\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nCommands:\n  init\n          fake init versioning\n  commit\n          fake commit changes to current branch\n  tag\n          fake tag current commit\n\nFor more detailed commands help try:\n  test_nested init -h,--help\n  test_nested commit -h,--help\n  test_nested tag -h,--help\n\nExamples:\n   test_nested\n   test_nested -h\n   test_nested init\n   test_nested commit -m \"fix bug-1\" test_nested tag -a \"v2.1.5\" For more details, see the provided example . Go to Top Download and Compile FLAP is a Fortran library composed by several modules. Before download and compile the library you must check the requirements . Download The tree structure of the FLAP project is the following: .\n├── CONTRIBUTING.md\n├── fobos\n├── LICENSE.bsd-2.md\n├── LICENSE.bsd-3.md\n├── LICENSE.gpl3.md\n├── LICENSE.mit.md\n├── makedoc.sh\n├── makefile\n├── README.md\n└── src\n    ├── lib\n    │   ├── flap_command_line_arguments_group_t.f90\n    │   ├── flap_command_line_argument_t.F90\n    │   ├── flap_command_line_interface_t.F90\n    │   ├── flap.f90\n    │   ├── flap_object_t.f90\n    │   └── flap_utils_m.f90\n    ├── tests\n    │   ├── test_basic.f90\n    │   ├── test_choices_logical.f90\n    │   ├── test_nested.f90\n    │   └── test_string.f90\n    └── third_party\n        └── PENF To download all the available releases and utilities (fobos, license, readme, etc…), it can be convenient to clone whole the project: git clone --recursive https://github.com/szaghi/FLAP Alternatively, you can directly download a release from GitHub server, see the ChangeLog . Compile The most easy way to compile FLAP is to use FoBiS.py within the provided fobos file. Consequently, it is strongly encouraged to install FoBiS.py . | Build by means of FoBiS | Build by means of GNU Make | Build by means of CMake | Build by means of FoBiS FoBiS.py is a KISS tool for automatic building of modern Fortran projects. Providing very few options, FoBiS.py is able to build almost automatically complex Fortran projects with cumbersome inter-modules dependency. This removes the necessity to write complex makefile. Moreover, providing a very simple options file (in the FoBiS.py nomenclature indicated as fobos file) FoBiS.py can substitute the (ab)use of makefile for other project stuffs (build documentations, make project archive, etc…). FLAP is shipped with a fobos file that can build the library in both static and shared forms and also build the Test_Driver program. The provided fobos file has several building modes. Listing fobos building modes Typing: FoBiS.py build -lmodes the following message should be printed: The fobos file defines the following modes:\n - \"shared-gnu\" - \"static-gnu\" - \"test-driver-gnu\" - \"shared-gnu-debug\" - \"static-gnu-debug\" - \"test-driver-gnu-debug\" - \"shared-intel\" - \"static-intel\" - \"test-driver-intel\" - \"shared-intel-debug\" - \"static-intel-debug\" - \"test-driver-intel-debug\" The modes should be self-explicative: shared , static and test-driver are the modes for building (in release, optimized form) the shared and static versions of the library and the Test Driver program, respectively. The other 3 modes are the same, but in debug form instead of release one. -gnu use the GNU gfortran compiler while -intel the Intel one. Building the library The shared or static directories are created accordingly to the form of the library built. The compiled objects and mod files are placed inside this directory, as well as the linked library. Release shared library FoBiS.py build -mode shared-gnu Release static library FoBiS.py build -mode static-gnu Debug shared library FoBiS.py build -mode shared-gnu-debug Debug static library FoBiS.py build -mode static-gnu-debug Building the Test Driver program The Test_Driver directory is created. The compiled objects and mod files are placed inside this directory, as well as the linked program. Release test driver program FoBiS.py build -mode test-driver-gnu Debug test driver program FoBiS.py build -mode test-driver-gnu-debug Listing fobos rules Typing: FoBiS.py rule -ls the following message should be printed: The fobos file defines the following rules:\n  - \"makedoc\" Rule for building documentation from source files Command = > rm -rf doc/html/* Command = > ford doc/main_page.md Command = > cp -r doc/html/publish/* doc/html/\n  - \"deldoc\" Rule for deleting documentation Command = > rm -rf doc/html/*\n  - \"maketar\" Rule for making tar archive of the project Command = > tar -czf FLAP.tar.gz *\n  - \"makecoverage\" Rule for performing coverage analysis Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33.0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64.123d0  --boolean --boolean_val .false.\n  - \"coverage-analysis\" Rule for performing coverage analysis and saving reports in markdown Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33.0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64.123d0  --boolean --boolean_val .false. Command = > gcov -o Test_Driver/obj/ src/* Command = > FoBiS.py rule -gcov_analyzer wiki/ Coverage-Analysis Command = > rm -f *.gcov The rules should be self-explicative. Build by means of GNU Make Bad choice :-) However, a makefile (generated by FoBiS.py…) to be used with a compatible GNU Make tool is provided . It is convenient to clone the whole FLAP repository and run a standard make: git clone --recursive https://github.com/szaghi/FLAP cd FLAP\nmake This commands build all tests (executables are in exe/ directory). To build only the library (statically linked) type: git clone --recursive https://github.com/szaghi/FLAP cd FLAP\nmake STATIC = yes Build by means of CMake Bad choice :-) However, a CMake setup (kindly developed by victorsndvg ) is provided. It is convenient to clone the whole FLAP repository and run a standard CMake configure/build commands: git clone --recursive https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake $YOUR_FLAP_PATH make If you want to run the tests suite type: git clone --recursive https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake -DFLAP_ENABLE_TESTS = ON $YOUR_FLAP_PATH make\nctest Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" FLAP "},{"text":"FLAP, Fortran command Line Arguments Parser for poor people This File Depends On sourcefile~~flap.f90~~EfferentGraph sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 var pansourcefileflapf90EfferentGraph = svgPanZoom('#sourcefileflapf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap.f90~~AfferentGraph sourcefile~flap.f90 flap.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap Source Code flap.f90 Source Code !< FLAP, Fortran command Line Arguments Parser for poor people module flap !----------------------------------------------------------------------------------------------------------------------------------- !< FLAP, Fortran command Line Arguments Parser for poor people !<{!README-FLAP.md!} !----------------------------------------------------------------------------------------------------------------------------------- use flap_command_line_argument_t , only : command_line_argument use flap_command_line_arguments_group_t , only : command_line_arguments_group use flap_command_line_interface_t , only : command_line_interface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: command_line_argument public :: command_line_arguments_group public :: command_line_interface !----------------------------------------------------------------------------------------------------------------------------------- endmodule flap","tags":"","loc":"sourcefile/flap.f90.html","title":"flap.f90 – FLAP"},{"text":"Command Line Argument (CLA) class. This File Depends On sourcefile~~flap_command_line_argument_t.f90~~EfferentGraph sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflap_command_line_argument_tf90EfferentGraph = svgPanZoom('#sourcefileflap_command_line_argument_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_command_line_argument_t.f90~~AfferentGraph sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 var pansourcefileflap_command_line_argument_tf90AfferentGraph = svgPanZoom('#sourcefileflap_command_line_argument_tf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_command_line_argument_t Source Code flap_command_line_argument_t.F90 Source Code !< Command Line Argument (CLA) class. module flap_command_line_argument_t !----------------------------------------------------------------------------------------------------------------------------------- !< Command Line Argument (CLA) class. !----------------------------------------------------------------------------------------------------------------------------------- use flap_object_t , only : object use flap_utils_m use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: command_line_argument public :: ACTION_STORE public :: ACTION_STORE_STAR public :: ACTION_STORE_TRUE public :: ACTION_STORE_FALSE public :: ACTION_PRINT_HELP public :: ACTION_PRINT_VERS public :: ARGS_SEP !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( object ) :: command_line_argument !< Command Line Argument (CLA) class. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable , public :: switch !< Switch name. character ( len = :), allocatable , public :: switch_ab !< Abbreviated switch name. logical , public :: is_required = . false . !< Flag for set required argument. logical , public :: is_positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), public :: position = 0_I4P !< Position of positional CLA. logical , public :: is_passed = . false . !< Flag for checking if CLA has been passed to CLI. logical , public :: is_hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable , public :: act !< CLA value action. character ( len = :), allocatable , public :: def !< Default value. character ( len = :), allocatable , public :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable , public :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable , public :: val !< CLA value. character ( len = :), allocatable , public :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLA is passed. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: raise_error_nargs_insufficient !< Raise error insufficient number of argument values passed. procedure , public :: raise_error_value_missing !< Raise error missing value. procedure , public :: raise_error_switch_unknown !< Raise error switch_unknown. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s). generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from varying size list. procedure , public :: sanitize_defaults !< Sanitize default values. procedure , public :: usage !< Get correct usage. procedure , public :: signature !< Get signature. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check_envvar_consistency !< Check data consistency for envvar CLA. procedure , private :: check_action_consistency !< Check CLA action consistency. procedure , private :: check_optional_consistency !< Check optional CLA consistency. procedure , private :: check_m_exclude_consistency !< Check mutually exclusion consistency. procedure , private :: check_named_consistency !< Check named CLA consistency. procedure , private :: check_positional_consistency !< Check positional CLA consistency. procedure , private :: check_choices !< Check if CLA value is in allowed choices. procedure , private :: check_list_size !< Check CLA multiple values list size consistency. procedure , private :: get_cla !< Get CLA (single) value. procedure , private :: get_cla_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list !< Get CLA multiple values. procedure , private :: get_cla_list_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values, varying size, char. procedure , private :: cla_assign_cla !< Assignment operator. generic , private :: assignment ( = ) => cla_assign_cla !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_argument ! parameters character ( len =* ), parameter :: ACTION_STORE = 'STORE' !< Store value (if invoked a value must be passed). character ( len =* ), parameter :: ACTION_STORE_STAR = 'STORE*' !< Store value or revert on default is invoked alone. character ( len =* ), parameter :: ACTION_STORE_TRUE = 'STORE_TRUE' !< Store .true. without the necessity of a value. character ( len =* ), parameter :: ACTION_STORE_FALSE = 'STORE_FALSE' !< Store .false. without the necessity of a value. character ( len =* ), parameter :: ACTION_PRINT_HELP = 'PRINT_HELP' !< Print help message. character ( len =* ), parameter :: ACTION_PRINT_VERS = 'PRINT_VERSION' !< Print version. character ( len =* ), parameter :: ARGS_SEP = '||!||' !< Arguments separator for multiple valued (list) CLA. ! errors codes integer ( I4P ), parameter :: ERROR_OPTIONAL_NO_DEF = 1 !< Optional CLA without default value. integer ( I4P ), parameter :: ERROR_REQUIRED_M_EXCLUDE = 2 !< Required CLA cannot exclude others. integer ( I4P ), parameter :: ERROR_POSITIONAL_M_EXCLUDE = 3 !< Positional CLA cannot exclude others. integer ( I4P ), parameter :: ERROR_NAMED_NO_NAME = 4 !< Named CLA without switch name. integer ( I4P ), parameter :: ERROR_POSITIONAL_NO_POSITION = 5 !< Positional CLA without position. integer ( I4P ), parameter :: ERROR_POSITIONAL_NO_STORE = 6 !< Positional CLA without action_store. integer ( I4P ), parameter :: ERROR_NOT_IN_CHOICES = 7 !< CLA value out of a specified choices. integer ( I4P ), parameter :: ERROR_MISSING_REQUIRED = 8 !< Missing required CLA. integer ( I4P ), parameter :: ERROR_M_EXCLUDE = 9 !< Two mutually exclusive CLAs have been passed. integer ( I4P ), parameter :: ERROR_CASTING_LOGICAL = 10 !< Error casting CLA value to logical type. integer ( I4P ), parameter :: ERROR_CHOICES_LOGICAL = 11 !< Error adding choices check for CLA val of logical type. integer ( I4P ), parameter :: ERROR_NO_LIST = 12 !< Actual CLA is not list-values. integer ( I4P ), parameter :: ERROR_NARGS_INSUFFICIENT = 13 !< Multi-valued CLA with insufficient arguments. integer ( I4P ), parameter :: ERROR_VALUE_MISSING = 14 !< Missing value of CLA. integer ( I4P ), parameter :: ERROR_UNKNOWN = 15 !< Unknown CLA (switch name). integer ( I4P ), parameter :: ERROR_ENVVAR_POSITIONAL = 16 !< Envvar not allowed for positional CLA. integer ( I4P ), parameter :: ERROR_ENVVAR_NOT_STORE = 17 !< Envvar not allowed action different from store; integer ( I4P ), parameter :: ERROR_ENVVAR_NARGS = 18 !< Envvar not allowed for list-values CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_POSITIONAL = 19 !< Action store* not allowed for positional CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_NARGS = 20 !< Action store* not allowed for list-values CLA. integer ( I4P ), parameter :: ERROR_STORE_STAR_ENVVAR = 21 !< Action store* not allowed for environment variable CLA. integer ( I4P ), parameter :: ERROR_ACTION_UNKNOWN = 22 !< Unknown CLA (switch name). !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_argument members if ( allocated ( self % switch )) deallocate ( self % switch ) if ( allocated ( self % switch_ab )) deallocate ( self % switch_ab ) if ( allocated ( self % act )) deallocate ( self % act ) if ( allocated ( self % def )) deallocate ( self % def ) if ( allocated ( self % nargs )) deallocate ( self % nargs ) if ( allocated ( self % choices )) deallocate ( self % choices ) if ( allocated ( self % val )) deallocate ( self % val ) if ( allocated ( self % envvar )) deallocate ( self % envvar ) self % is_required = . false . self % is_positional = . false . self % position = 0_I4P self % is_passed = . false . self % is_hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % check_envvar_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_action_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_optional_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_m_exclude_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_named_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_positional_consistency ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check function is_required_passed ( self , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLA is passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if (((. not . self % is_passed ). and . self % is_required ). or .((. not . self % is_passed ). and .(. not . allocated ( self % def )))) then call self % errored ( pref = pref , error = ERROR_MISSING_REQUIRED ) is_ok = . false . endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_required_passed subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude subroutine raise_error_nargs_insufficient ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error insufficient number of argument values passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_nargs_insufficient subroutine raise_error_value_missing ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error missing value. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_VALUE_MISSING ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_value_missing subroutine raise_error_switch_unknown ( self , switch , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error switch_unknown. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_UNKNOWN , switch = switch ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_switch_unknown subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_passed ) then if ( allocated ( self % def )) then ! strip leading and trailing white spaces self % def = wstrip ( self % def ) if ( allocated ( self % nargs )) then ! replace white space separator with FLAP ARGS_SEP self % def = unique ( string = self % def , substring = ' ' ) self % def = replace_all ( string = self % def , substring = ' ' , restring = ARGS_SEP ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults function usage ( self , pref , markdown ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( in ) :: self !< CLAs group data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: markdown !< Format for markdown character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. logical :: markdownd !< Format for markdown integer :: indent !< how many spaces to indent !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- markdownd = . false . ; if ( present ( markdown )) markdownd = markdown indent = 4 if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then usage = '' select case ( self % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str ( a , . true .)) enddo endselect if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`, `' // trim ( adjustl ( self % switch_ab )) // usage // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // usage // ', ' // trim ( adjustl ( self % switch_ab )) // usage endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // usage endif endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`, `' // trim ( adjustl ( self % switch_ab )) // ' value' // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // ' value, ' // trim ( adjustl ( self % switch_ab )) // ' value' endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`' else usage = '   ' // trim ( adjustl ( self % switch )) // ' value' endif endif endif else usage = '  value' endif if ( allocated ( self % choices )) then usage = usage // ', value in: `' // self % choices // '`' endif elseif ( self % act == action_store_star ) then usage = '  [value]' if ( allocated ( self % choices )) then usage = usage // ', value in: (' // self % choices // ')' endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`, `' // trim ( adjustl ( self % switch_ab )) // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // ', ' // trim ( adjustl ( self % switch_ab )) endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`' else usage = '   ' // trim ( adjustl ( self % switch )) endif endif endif prefd = '' ; if ( present ( pref )) prefd = pref usage = prefd // usage if ( self % is_positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( str ( self % position , . true .)) // & '-th argument' if ( allocated ( self % envvar )) then if ( self % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( self % envvar )) // '\"' endif endif if (. not . self % is_required ) then if ( self % def /= '' ) then if ( markdownd ) then ! two spaces make a line break in markdown. usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) endif endif endif if ( self % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'mutually exclude \"' // self % m_exclude // '\"' if ( markdownd ) then usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // trim ( adjustl ( self % help )) if ( self % help_markdown /= '' ) then usage = usage // trim ( adjustl ( self % help_markdown )) endif else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( adjustl ( self % help )) endif else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( in ) :: self !< CLA data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then select case ( self % nargs ) case ( '+' ) signature = ' value#1 [value#2 value#3...]' case ( '*' ) signature = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) signature = '' do a = 1 , nargs signature = signature // ' value#' // trim ( str ( a , . true .)) enddo endselect else signature = ' value' endif if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) // signature else signature = ' [' // trim ( adjustl ( self % switch )) // signature // ']' endif else if ( self % is_required ) then signature = ' value' else signature = ' [value]' endif endif elseif ( self % act == action_store_star ) then signature = ' [value]' else if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) else signature = ' [' // trim ( adjustl ( self % switch )) // ']' endif endif else signature = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature ! private methods subroutine errored ( self , error , pref , switch , val_str , log_value ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: val_str !< Value string. character ( * ), optional , intent ( in ) :: log_value !< Logical value to be casted. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select case ( self % error ) case ( ERROR_OPTIONAL_NO_DEF ) if ( self % is_positional ) then self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( n = self % position )) // & '-th\" positional option has not a default value!' else self % error_message = prefd // self % progname // ': error: named option \"' // self % switch // '\" has not a default value!' endif case ( ERROR_REQUIRED_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: named option \"' // self % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( ERROR_POSITIONAL_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( n = self % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( ERROR_NAMED_NO_NAME ) self % error_message = prefd // self % progname // ': error: a non positional optiona must have a switch name!' case ( ERROR_POSITIONAL_NO_POSITION ) self % error_message = prefd // self % progname // ': error: a positional option must have a position number different from 0!' case ( ERROR_POSITIONAL_NO_STORE ) self % error_message = prefd // self % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( ERROR_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: the options \"' // self % switch // '\" and \"' // self % m_exclude // & '\" are mutually exclusive, but both have been passed!' case ( ERROR_NOT_IN_CHOICES ) if ( self % is_positional ) then self % error_message = prefd // self % progname // ': error: value of \"' // trim ( str ( n = self % position )) // & '-th\" positional option must be chosen in:' else self % error_message = prefd // self % progname // ': error: value of named option \"' // self % switch // '\" must be chosen in: ' endif self % error_message = self % error_message // '(' // self % choices // ')' self % error_message = self % error_message // ' but \"' // trim ( val_str ) // '\" has been passed!' case ( ERROR_MISSING_REQUIRED ) if (. not . self % is_positional ) then self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // '\" is required!' else self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option is required!' endif case ( ERROR_CASTING_LOGICAL ) self % error_message = prefd // self % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // self % switch // & '\" to logical type!' case ( ERROR_CHOICES_LOGICAL ) self % error_message = prefd // self % progname // ': error: cannot use \"choices\" value check for option \"' // self % switch // & '\" it being of logical type! The choices is, by definition of logical, limited to \".true.\" or \".false.\"' case ( ERROR_NO_LIST ) if (. not . self % is_positional ) then self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has not \"nargs\" value but an array has been passed to \"get\" method!' else self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( ERROR_NARGS_INSUFFICIENT ) if (. not . self % is_positional ) then if ( self % nargs == '+' ) then self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" requires at least 1 argument but no one remains!' else self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // '\" requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif else if ( self % nargs == '+' ) then self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires at least 1 argument but no one remains' else self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif endif case ( ERROR_VALUE_MISSING ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" needs a value that is not passed!' case ( ERROR_UNKNOWN ) self % error_message = prefd // self % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( ERROR_ENVVAR_POSITIONAL ) self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( ERROR_ENVVAR_NOT_STORE ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( ERROR_ENVVAR_NARGS ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( ERROR_STORE_STAR_POSITIONAL ) self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( ERROR_STORE_STAR_NARGS ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( ERROR_STORE_STAR_ENVVAR ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( ERROR_ACTION_UNKNOWN ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has unknown \"' // self % act // '\" action!' endselect call self % print_error_message endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored subroutine check_envvar_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency for envvar CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % envvar )) then if ( self % is_positional ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_POSITIONAL ) return endif if (. not . allocated ( self % act )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return else if ( self % act /= action_store ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return endif endif if ( allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NARGS ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_envvar_consistency subroutine check_action_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA action consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % act )) then if ( self % act == ACTION_STORE_STAR . and . self % is_positional ) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_POSITIONAL ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_NARGS ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % envvar )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_ENVVAR ) return endif if ( self % act /= ACTION_STORE . and . & self % act /= ACTION_STORE_STAR . and . & self % act /= ACTION_STORE_TRUE . and . & self % act /= ACTION_STORE_FALSE . and .& self % act /= ACTION_PRINT_HELP . and . & self % act /= ACTION_PRINT_VERS ) then call self % errored ( pref = pref , error = ERROR_ACTION_UNKNOWN ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_action_consistency subroutine check_optional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check optional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_required ). and .(. not . allocated ( self % def ))) call self % errored ( pref = pref , error = ERROR_OPTIONAL_NO_DEF ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_optional_consistency subroutine check_m_exclude_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check mutually exclusion consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_required ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_REQUIRED_M_EXCLUDE ) return endif if (( self % is_positional ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_M_EXCLUDE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclude_consistency subroutine check_named_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check named CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_positional ). and .(. not . allocated ( self % switch ))) call self % errored ( pref = pref , error = ERROR_NAMED_NO_NAME ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_named_consistency subroutine check_positional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check positional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_positional ). and .( self % position == 0_I4P )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_POSITION ) return elseif (( self % is_positional ). and .( self % act /= action_store )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_STORE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_positional_consistency subroutine check_choices ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( in ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len ( self % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = self % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) call self % errored ( pref = pref , error = ERROR_CHOICES_LOGICAL ) endselect if (. not . val_in . and .( self % error == 0 )) then call self % errored ( pref = pref , error = ERROR_NOT_IN_CHOICES , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices function check_list_size ( self , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: Nv !< Number of values. character ( * ), intent ( in ) :: val !< First value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size subroutine get_cla ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if ( self % act == action_store . or . self % act == action_store_star ) then if ( self % is_passed . and . allocated ( self % val )) then call self % get_cla_from_buffer ( buffer = self % val , val = val , pref = pref ) elseif ( allocated ( self % def )) then ! using default value call self % get_cla_from_buffer ( buffer = self % def , val = val , pref = pref ) endif if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val , pref = pref ) elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from parsed value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I1P ) type is ( logical ) read ( buffer , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = buffer ) type is ( character ( * )) val = buffer endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_from_buffer subroutine get_cla_list ( self , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call self % get_cla_list_from_buffer ( buffer = self % val , val = val , pref = pref ) else ! using default value call self % get_cla_list_from_buffer ( buffer = self % def , val = val , pref = pref ) endif elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list subroutine get_cla_list_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from a buffer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val ( 1 :) !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( buffer )), allocatable :: vals (:) !< String array of values based on buffer value. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = buffer , delimiter = args_sep , toks = vals , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R16P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I2P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I1P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( vals ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = vals ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = vals ( v ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_from_buffer subroutine get_cla_list_varying_R16P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( INOUT ) :: self !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char elemental subroutine cla_assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_argument ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % is_required = rhs % is_required lhs % is_positional = rhs % is_positional lhs % position = rhs % position lhs % is_passed = rhs % is_passed lhs % is_hidden = rhs % is_hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine cla_assign_cla elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule flap_command_line_argument_t","tags":"","loc":"sourcefile/flap_command_line_argument_t.f90.html","title":"flap_command_line_argument_t.F90 – FLAP"},{"text":"Command Line Arguments Group (CLAsG) class. This File Depends On sourcefile~~flap_command_line_arguments_group_t.f90~~EfferentGraph sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflap_command_line_arguments_group_tf90EfferentGraph = svgPanZoom('#sourcefileflap_command_line_arguments_group_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_command_line_arguments_group_t.f90~~AfferentGraph sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 var pansourcefileflap_command_line_arguments_group_tf90AfferentGraph = svgPanZoom('#sourcefileflap_command_line_arguments_group_tf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_command_line_arguments_group_t Source Code flap_command_line_arguments_group_t.f90 Source Code !< Command Line Arguments Group (CLAsG) class. module flap_command_line_arguments_group_t !----------------------------------------------------------------------------------------------------------------------------------- !< Command Line Arguments Group (CLAsG) class. !----------------------------------------------------------------------------------------------------------------------------------- use flap_command_line_argument_t , only : command_line_argument , & ACTION_PRINT_HELP , & ACTION_PRINT_VERS , & ACTION_STORE , & ACTION_STORE_STAR , & ARGS_SEP use flap_object_t , only : object use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: command_line_arguments_group public :: STATUS_PRINT_V public :: STATUS_PRINT_H !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( object ) :: command_line_arguments_group !< Command Line Arguments Group (CLAsG) class. !< !< CLAsG are useful for building nested commands. private character ( len = :), allocatable , public :: group !< Group name (command). integer ( I4P ), public :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of required command line arguments. integer ( I4P ) :: Na_optional = 0_I4P !< Number of optional command line arguments. type ( command_line_argument ), allocatable , public :: cla (:) !< CLA list [1:Na]. logical , public :: is_called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLAs are passed. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: add !< Add CLA to CLAsG. procedure , public :: parse !< Parse CLAsG arguments. procedure , public :: usage !< Get correct CLAsG usage. procedure , public :: signature !< Get CLAsG signature. procedure , public :: sanitize_defaults !< Sanitize default values. ! private methods procedure , private :: errored !< Trig error occurrence and print meaningful message. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs have been passed. procedure , private :: clasg_assign_clasg !< Assignment operator. generic , private :: assignment ( = ) => clasg_assign_clasg !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_arguments_group ! status codes integer ( I4P ), parameter :: STATUS_PRINT_V = - 1 !< Print version status. integer ( I4P ), parameter :: STATUS_PRINT_H = - 2 !< Print help status. ! errors codes integer ( I4P ), parameter :: ERROR_CONSISTENCY = 23 !< CLAs group consistency error. integer ( I4P ), parameter :: ERROR_M_EXCLUDE = 24 !< Two mutually exclusive CLAs group have been called. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_arguments_group members if ( allocated ( self % group )) deallocate ( self % group ) if ( allocated ( self % cla )) then call self % cla % free deallocate ( self % cla ) endif self % Na = 0_I4P self % Na_required = 0_I4P self % Na_optional = 0_I4P self % is_called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! verify if CLAs switches are unique CLA_unique : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then do aa = 1 , self % Na if (( a /= aa ). and .(. not . self % cla ( aa )% is_positional )) then if (( self % cla ( a )% switch == self % cla ( aa )% switch ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch ). or .& ( self % cla ( a )% switch == self % cla ( aa )% switch_ab ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch_ab )) then call self % errored ( pref = pref , error = ERROR_CONSISTENCY , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! update mutually exclusive relations CLA_exclude : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_defined ( switch = self % cla ( a )% m_exclude , pos = aa )) then self % cla ( aa )% m_exclude = self % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine is_required_passed ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_required_passed ( pref = pref )) then self % error = self % cla ( a )% error write ( self % usage_lun , '(A)' ) self % usage ( pref = pref ) return endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine is_required_passed pure function is_passed ( self , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_passed = . false . if ( self % Na > 0 ) then if ( present ( switch )) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_passed = self % cla ( a )% is_passed exit endif endif enddo elseif ( present ( position )) then is_passed = self % cla ( position )% is_passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_passed function is_defined ( self , switch , pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( out ) :: pos !< CLA position. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_defined = . false . if ( present ( pos )) pos = 0 if ( self % Na > 0 ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude subroutine add ( self , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. type ( command_line_argument ), intent ( in ) :: cla !< CLA data. type ( command_line_argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % Na > 0_I4P ) then if (. not . cla % is_positional ) then allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , self % Na cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( self % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , self % Na + 1 cla_list_new ( c ) = self % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = self % cla ) self % Na = self % Na + 1 if ( cla % is_required ) then self % Na_required = self % Na_required + 1 else self % Na_optional = self % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) call self % check ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine parse ( self , args , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAsG arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), intent ( in ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , self % Na ! loop over CLAs group clas named options if (. not . self % cla ( a )% is_positional ) then if ( trim ( adjustl ( self % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( self % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then found_val = . false . if ( self % cla ( a )% act == action_store ) then if ( allocated ( self % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = self % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then self % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( self % cla ( a )% def )) then self % cla ( a )% val = self % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( self % cla ( a )% nargs )) then self % cla ( a )% val = '' select case ( self % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( self % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) enddo found_val = . true . arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call self % cla ( a )% raise_error_value_missing ( pref = pref ) self % error = self % cla ( a )% error return endif arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( self % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! flush default to val if default is set if ( allocated ( self % cla ( a )% def )) self % cla ( a )% val = self % cla ( a )% def endif elseif ( self % cla ( a )% act == action_print_help ) then self % error = STATUS_PRINT_H elseif ( self % cla ( a )% act == action_print_vers ) then self % error = STATUS_PRINT_V endif self % cla ( a )% is_passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . self % cla ( arg )% is_positional ) then ! current argument (arg-th) is not positional... there is a problem! call self % cla ( arg )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error return else ! positional CLA always stores a value self % cla ( arg )% val = trim ( adjustl ( args ( arg ))) self % cla ( arg )% is_passed = . true . endif endif enddo call self % check_m_exclusive ( pref = pref ) call self % sanitize_defaults endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse function usage ( self , pref , no_header , markdown ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAsG usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: markdown !< Format things form markdown. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: markdownd !< Markdonw format, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref usage = self % progname ; if ( self % group /= '' ) usage = self % progname // ' ' // self % group usage = prefd // self % help // ' ' // usage // self % signature () if ( self % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( self % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , self % Na if ( self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif if ( self % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , self % Na if (. not . self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAsG signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signature = '' do a = 1 , self % Na signature = signature // self % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature ! private methods subroutine errored ( self , error , pref , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurrence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( in ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( in ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select case ( self % error ) case ( ERROR_CONSISTENCY ) if ( self % group /= '' ) then self % error_message = prefd // self % progname // ': error: group (command) name: \"' // self % group // '\" consistency error:' else self % error_message = prefd // self % progname // ': error: consistency error:' endif self % error_message = self % error_message // ' \"' // trim ( str ( a1 , . true .)) // & '-th\" option has the same switch or abbreviated switch of \"' // trim ( str ( a2 , . true .)) // '-th\" option:' // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a1 , . true .)) // ') switches = ' // self % cla ( a1 )% switch // ' ' // & self % cla ( a1 )% switch_ab // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a2 , . true .)) // ') switches = ' // self % cla ( a2 )% switch // ' ' // & self % cla ( a2 )% switch_ab case ( ERROR_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: the group \"' // self % group // '\" and \"' // self % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect call self % print_error_message endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored subroutine check_m_exclusive ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if ( self % cla ( a )% is_passed ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_passed ( switch = self % cla ( a )% m_exclude )) then call self % cla ( a )% raise_error_m_exclude ( pref = pref ) self % error = self % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na call self % cla ( a )% sanitize_defaults enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults elemental subroutine clasg_assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( INOUT ) :: lhs !< Left hand side. type ( command_line_arguments_group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_arguments_group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % is_called = rhs % is_called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine clasg_assign_clasg elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule flap_command_line_arguments_group_t","tags":"","loc":"sourcefile/flap_command_line_arguments_group_t.f90.html","title":"flap_command_line_arguments_group_t.f90 – FLAP"},{"text":"Command Line Interface (CLI) class. This File Depends On sourcefile~~flap_command_line_interface_t.f90~~EfferentGraph sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflap_command_line_interface_tf90EfferentGraph = svgPanZoom('#sourcefileflap_command_line_interface_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_command_line_interface_t.f90~~AfferentGraph sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_command_line_interface_t Source Code flap_command_line_interface_t.F90 Source Code !< Command Line Interface (CLI) class. module flap_command_line_interface_t !----------------------------------------------------------------------------------------------------------------------------------- !< Command Line Interface (CLI) class. !----------------------------------------------------------------------------------------------------------------------------------- use flap_command_line_argument_t , only : command_line_argument , action_store use flap_command_line_arguments_group_t , only : command_line_arguments_group , STATUS_PRINT_H , STATUS_PRINT_V use flap_object_t , only : object use flap_utils_m use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( object ), public :: command_line_interface !< Command Line Interface (CLI) class. private type ( command_line_arguments_group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. logical :: is_parsed_ = . false . !< Parse status. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined_group !< Check if a CLAs group has been defined. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: is_parsed !< Check if CLI has been parsed. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => is_called_group !< Check if a CLAs group has been run. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from CLAs list parsed, varying size list. procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. procedure , public :: save_usage_to_markdown !< Save parts of the CLI as markdown. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check !< Check data consistency. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => & get_args_from_string , & get_args_from_invocation !< Get CLAs. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: cli_assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => cli_assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_interface integer ( I4P ), parameter , public :: MAX_VAL_LEN = 1000 !< Maximum number of characters of CLA value. ! errors codes integer ( I4P ), parameter , public :: ERROR_MISSING_CLA = 25 !< CLA not found in CLI. integer ( I4P ), parameter , public :: ERROR_MISSING_GROUP = 26 !< Group not found in CLI. integer ( I4P ), parameter , public :: ERROR_MISSING_SELECTION_CLA = 27 !< CLA selection in CLI failing. integer ( I4P ), parameter , public :: ERROR_TOO_FEW_CLAS = 28 !< Insufficient arguments for CLI. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_interface members if ( allocated ( self % clasg )) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 call self % clasg ( g )% free enddo deallocate ( self % clasg ) endif if ( allocated ( self % examples )) deallocate ( self % examples ) self % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free subroutine init ( self , progname , version , help , description , license , authors , examples , epilog , disable_hv , & usage_lun , error_lun , version_lun ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: progname !< Program name. character ( * ), optional , intent ( in ) :: version !< Program version. character ( * ), optional , intent ( in ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( in ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( in ) :: license !< License description. character ( * ), optional , intent ( in ) :: authors !< Authors list. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( in ) :: epilog !< Epilog message. logical , optional , intent ( in ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. integer ( I4P ), optional , intent ( in ) :: usage_lun !< Unit number to print usage/help integer ( I4P ), optional , intent ( in ) :: version_lun !< Unit number to print version/license info integer ( I4P ), optional , intent ( in ) :: error_lun !< Unit number to print error info character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free if ( present ( usage_lun )) self % usage_lun = usage_lun if ( present ( version_lun )) self % version_lun = version_lun if ( present ( error_lun )) self % error_lun = error_lun if ( present ( progname )) then self % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then self % progname = prog_invocation else self % progname = 'program' endif endif self % version = 'unknown' ; if ( present ( version )) self % version = version self % help = 'usage: ' ; if ( present ( help )) self % help = help self % description = '' ; if ( present ( description )) self % description = description self % license = '' ; if ( present ( license )) self % license = license self % authors = '' ; if ( present ( authors )) self % authors = authors self % epilog = '' ; if ( present ( epilog )) self % epilog = epilog if ( present ( disable_hv )) self % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( self % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: self % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif self % examples = examples endif ! initialize only the first default group allocate ( self % clasg ( 0 : 0 )) call self % clasg ( 0 )% assign_object ( self ) self % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine add_group ( self , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: help !< Help message. character ( * ), optional , intent ( in ) :: description !< Detailed description. character ( * ), optional , intent ( in ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( in ) :: group !< Name of the grouped CLAs. type ( command_line_arguments_group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( self % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = self%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = self % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( self ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( self % clasg ) allocate ( self % clasg ( 0 : Ng )) self % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group subroutine set_mutually_exclusive_groups ( self , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( in ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_defined_group ( group = group1 , g = g1 ). and . self % is_defined_group ( group = group2 , g = g2 )) then self % clasg ( g1 )% m_exclude = group2 self % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups subroutine add ( self , pref , group , group_index , switch , switch_ab , help , help_markdown , required , & positional , position , hidden , act , def , nargs , choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( in ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( in ) :: help !< Help message describing the CLA. character ( * ), optional , intent ( in ) :: help_markdown !< Longer help message, markdown formatted. logical , optional , intent ( in ) :: required !< Flag for set required argument. logical , optional , intent ( in ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical , optional , intent ( in ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( in ) :: act !< CLA value action. character ( * ), optional , intent ( in ) :: def !< Default value. character ( * ), optional , intent ( in ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( in ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( in ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( in ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. type ( command_line_argument ) :: cla !< CLA data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize CLA call cla % assign_object ( self ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % help_markdown = '' ; if ( present ( help_markdown )) cla % help_markdown = help_markdown cla % is_required = . false . ; if ( present ( required )) cla % is_required = required cla % is_positional = . false . ; if ( present ( positional )) cla % is_positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % is_hidden = . false . ; if ( present ( hidden )) cla % is_hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar call cla % check ( pref = pref ) ; self % error = cla % error if ( self % error /= 0 ) then if ( present ( error )) error = self % error return endif ! add CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call self % clasg ( 0 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( 0 )% error elseif ( present ( group )) then if ( self % is_defined_group ( group = group , g = g )) then call self % clasg ( g )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( g )% error else call self % add_group ( group = group ) call self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( self % clasg , dim = 1 ) - 1 ) then call self % clasg ( group_index )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( group_index )% error endif endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add subroutine check ( self , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( INOUT ) :: self !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 0 , size ( self % clasg , dim = 1 ) - 1 ! check group consistency call self % clasg ( g )% check ( pref = pref ) self % error = self % clasg ( g )% error if ( present ( error )) error = self % error if ( self % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( self % clasg ( g )% m_exclude /= '' ) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) self % clasg ( gg )% m_exclude = self % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check subroutine check_m_exclusive ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( self % clasg , dim = 1 ) - 1 if ( self % clasg ( g )% is_called . and .( self % clasg ( g )% m_exclude /= '' )) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) then if ( self % clasg ( gg )% is_called ) then call self % clasg ( g )% raise_error_m_exclude ( pref = pref ) self % error = self % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive function is_passed ( self , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_passed = . false . if (. not . present ( group )) then if ( present ( switch )) then is_passed = self % clasg ( 0 )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( 0 )% is_passed ( position = position ) endif else if ( self % is_defined_group ( group = group , g = g )) then if ( present ( switch )) then is_passed = self % clasg ( g )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( g )% is_passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_passed function is_defined_group ( self , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( out ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( self % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( self % clasg ( gg )% group )) defined = ( self % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined_group function is_called_group ( self , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been run. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( self % is_defined_group ( group = group , g = g )) called = self % clasg ( g )% is_called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_called_group function is_defined ( self , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLAs. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_defined = . false . if (. not . present ( group )) then is_defined = self % clasg ( 0 )% is_defined ( switch = switch ) else if ( self % is_defined_group ( group = group , g = g )) is_defined = self % clasg ( g )% is_defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined elemental function is_parsed ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLI has been parsed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical :: is_parsed !< Parsed status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_parsed = self % is_parsed_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_parsed subroutine parse ( self , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_parsed_ ) return ! add help and version switches if not done by user if (. not . self % disable_hv ) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--help' ). and .& self % is_defined ( group = self % clasg ( g )% group , switch = '-h' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--version' ). and . & self % is_defined ( group = self % clasg ( g )% group , switch = '-v' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not . self % is_defined ( group = self % clasg ( g )% group , switch = '--' )) & call self % add ( pref = pref , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parse passed CLAs grouping in indexes if ( present ( args )) then call self % get_args ( args = args , ai = ai ) else call self % get_args ( ai = ai ) endif ! check CLI consistency call self % check ( pref = pref ) if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! parse CLI do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) then call self % clasg ( g )% parse ( args = self % args ( ai ( g , 1 ): ai ( g , 2 )), pref = pref ) else call self % clasg ( g )% sanitize_defaults endif self % error = self % clasg ( g )% error if ( self % error /= 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! trap the special cases of version/help printing if ( self % error == STATUS_PRINT_V ) then call self % print_version ( pref = pref ) stop elseif ( self % error == STATUS_PRINT_H ) then write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = g ) stop endif ! check if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call self % clasg ( g )% is_required_passed ( pref = pref ) self % error = self % clasg ( g )% error if ( self % error > 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! check mutually exclusive interaction call self % check_m_exclusive ( pref = pref ) self % is_parsed_ = . true . if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse subroutine get_clasg_indexes ( self , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( self % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( self % args )) then Na = size ( self % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( self % is_defined_group ( group = trim ( self % args ( a )), g = g )) then found = . true . self % clasg ( g )% is_called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( self % is_defined_group ( group = trim ( self % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 self % clasg ( 0 )% is_called = . true . elseif ( all ( ai == 0 )) then self % clasg ( 0 )% is_called = . true . endif else self % clasg ( 0 )% is_called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes subroutine get_args_from_string ( self , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare CLI arguments list if ( allocated ( self % args )) deallocate ( self % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate CLI arguments list #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: self % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 self % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call self % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: argsin !< Arguments string. character ( * ), intent ( in ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string subroutine get_args_from_invocation ( self , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % args )) deallocate ( self % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: self % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) self % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call self % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation subroutine get_cla ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( self % error == 0. and . self % clasg ( g )% is_called ) then if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( position )% error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla subroutine get_cla_list ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list subroutine get_cla_list_varying_R16P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P subroutine get_cla_list_varying_R8P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P subroutine get_cla_list_varying_R4P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P subroutine get_cla_list_varying_I8P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P subroutine get_cla_list_varying_I4P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P subroutine get_cla_list_varying_I2P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P subroutine get_cla_list_varying_I1P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P subroutine get_cla_list_varying_logical ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical subroutine get_cla_list_varying_char ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char function usage ( self , g , pref , no_header , no_examples , no_epilog , markdown ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. integer ( I4P ), intent ( in ) :: g !< Group index. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( in ) :: no_epilog !< Avoid insert epilogue to usage. logical , optional , intent ( in ) :: markdown !< Format things with markdown character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. logical :: markdownd !< Format for markdown. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = self % clasg ( g )% usage ( pref = prefd , no_header = no_headerd , markdown = markdownd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // self % help // self % progname // ' ' // self % signature () if ( self % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description endif if ( self % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // self % clasg ( 0 )% usage ( pref = prefd , no_header = . true ., markdown = markdownd ) if ( size ( self % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // self % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % progname // ' ' // self % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( self % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( self % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( self % examples ( e )) enddo endif if ( self % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // self % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signature = self % clasg ( 0 )% signature () if ( size ( self % clasg , dim = 1 ) > 1 ) then signature = signature // ' {' // self % clasg ( 1 )% group do g = 2 , size ( self % clasg , dim = 1 ) - 1 signature = signature // ',' // self % clasg ( g )% group enddo signature = signature // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature subroutine print_usage ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage subroutine save_man_page ( self , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // self % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // self % version // & '\" \"' // self % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // self % progname // ' - manual page for ' // self % progname // ' version ' // self % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // self % progname // new_line ( 'a' ) // trim ( adjustl ( self % signature ())) if ( self % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( self % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( self % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // self % authors if ( self % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // self % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page subroutine save_usage_to_markdown ( self , markdown_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save the CLI as a markdown page, for inclusion into the documentation. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: markdown_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! add the other tags here. man = '' ! add the short description if ( self % description /= '' ) man = man // new_line ( 'a' ) // '### Short description' // new_line ( 'a' ) // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // new_line ( 'a' ) // '### Command line options:' man = man // new_line ( 'a' ) // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 , markdown = . true .) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '### Examples' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) man = man // new_line ( 'a' ) // '`' // trim ( self % examples ( e )) // '` ' enddo endif open ( newunit = u , file = trim ( adjustl ( markdown_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_usage_to_markdown ! private methods subroutine errored ( self , error , pref , group , switch ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurrence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< Object data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Group name. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select case ( self % error ) case ( ERROR_MISSING_CLA ) self % error_message = prefd // self % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( ERROR_MISSING_SELECTION_CLA ) self % error_message = prefd // self % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( ERROR_MISSING_GROUP ) self % error_message = prefd // self % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( ERROR_TOO_FEW_CLAS ) ! self%error_message = prefd//self%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,self%Na_required))//')' endselect write ( self % error_lun , '(A)' ) call self % print_error_message endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored elemental subroutine cli_assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_interface ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine cli_assign_cli elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_interface ), intent ( inout ) :: self !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule flap_command_line_interface_t","tags":"","loc":"sourcefile/flap_command_line_interface_t.f90.html","title":"flap_command_line_interface_t.F90 – FLAP"},{"text":"Base (abstract) class upon which FLAP's concrete classes are built. This File Depends On sourcefile~~flap_object_t.f90~~EfferentGraph sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflap_object_tf90EfferentGraph = svgPanZoom('#sourcefileflap_object_tf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_object_t.f90~~AfferentGraph sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 var pansourcefileflap_object_tf90AfferentGraph = svgPanZoom('#sourcefileflap_object_tf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_object_t Source Code flap_object_t.f90 Source Code !< Base (abstract) class upon which FLAP's concrete classes are built. module flap_object_t !----------------------------------------------------------------------------------------------------------------------------------- !< Base (abstract) class upon which FLAP's concrete classes are built. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract , public :: object !< Base (abstract) class upon which FLAP's concrete classes are built. private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), public , allocatable :: help !< Help message. character ( len = :), public , allocatable :: help_markdown !< Longer help message, markdown formatted. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilogue message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). character ( len = :), public , allocatable :: error_message !< Meaningful error message to standard-error. integer ( I4P ), public :: error = 0_I4P !< Error trapping flag. integer ( I4P ), public :: usage_lun = stderr !< Output unit to print help/usage messages integer ( I4P ), public :: version_lun = stdout !< Output unit to print version message integer ( I4P ), public :: error_lun = stderr !< Error unit to print error messages contains procedure :: free_object !< Free dynamic memory. procedure :: print_version !< Print version. procedure :: print_error_message !< Print meaningful error message. procedure :: assign_object !< Assignment overloading. endtype object !----------------------------------------------------------------------------------------------------------------------------------- contains elemental subroutine free_object ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( inout ) :: self !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % progname )) deallocate ( self % progname ) if ( allocated ( self % version )) deallocate ( self % version ) if ( allocated ( self % help )) deallocate ( self % help ) if ( allocated ( self % description )) deallocate ( self % description ) if ( allocated ( self % license )) deallocate ( self % license ) if ( allocated ( self % authors )) deallocate ( self % authors ) if ( allocated ( self % epilog )) deallocate ( self % epilog ) if ( allocated ( self % m_exclude )) deallocate ( self % m_exclude ) if ( allocated ( self % error_message )) deallocate ( self % error_message ) self % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object subroutine print_version ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( in ) :: self !< Object data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( self % version_lun , '(A)' ) prefd // self % progname // ' version ' // self % version if ( self % license /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % license endif if ( self % authors /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version subroutine print_error_message ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print meaningful error message to standard-error. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( in ) :: self !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( self % error_lun , '(A)' ) self % error_message write ( self % error_lun , '(A)' ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_error_message elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two abstract objects. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( inout ) :: lhs !< Left hand side. class ( object ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object endmodule flap_object_t","tags":"","loc":"sourcefile/flap_object_t.f90.html","title":"flap_object_t.f90 – FLAP"},{"text":"FLAP utils. This File Depends On sourcefile~~flap_utils_m.f90~~EfferentGraph sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflap_utils_mf90EfferentGraph = svgPanZoom('#sourcefileflap_utils_mf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flap_utils_m.f90~~AfferentGraph sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 var pansourcefileflap_utils_mf90AfferentGraph = svgPanZoom('#sourcefileflap_utils_mf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flap_utils_m Source Code flap_utils_m.f90 Source Code !< FLAP utils. module flap_utils_m !----------------------------------------------------------------------------------------------------------------------------------- !< FLAP utils. !----------------------------------------------------------------------------------------------------------------------------------- use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: count public :: replace public :: replace_all public :: tokenize public :: unique public :: upper_case public :: wstrip !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface count !< Overload intrinsic function count for counting substring occurences into strings. module procedure count_substring endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function count_substring ( string , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string )) return c1 = 1 do c2 = index ( string = string ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring pure function replace ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (only first occurrence) into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. integer ( I4P ) :: pos !< Position from which replace the substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos = index ( string = string , substring = substring ) newstring = string if ( pos > 0 ) then if ( pos == 1 ) then newstring = restring // string ( len ( substring ) + 1 :) else newstring = string ( 1 : pos - 1 ) // restring // string ( pos + len ( substring ):) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace pure function replace_all ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (all occurrences) into a string. !< !< @note Leading and trailing white spaces are stripped out. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- newstring = wstrip ( string ) do if ( index ( newstring , substring ) > 0 ) then newstring = replace ( string = newstring , substring = substring , restring = restring ) else exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_all pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to input string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: strin !< String to be tokenized. character ( len =* ), intent ( in ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( out ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( out ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = strin ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize elemental function unique ( string , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be parsed. character ( len =* ), intent ( in ) :: substring !< Substring which multiple occurences must be reduced to one. character ( len = len ( string )) :: uniq !< String parsed. integer ( I4P ) :: Lsub !< Lenght of substring. integer ( I4P ) :: c1 !< Counter. integer ( I4P ) :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- uniq = string Lsub = len ( substring ) if ( Lsub > len ( string )) return c1 = 1 Loop1 : do if ( c1 >= len_trim ( uniq )) exit Loop1 if ( uniq ( c1 : c1 + Lsub - 1 ) == substring . and . uniq ( c1 + Lsub : c1 + 2 * Lsub - 1 ) == substring ) then c2 = c1 + Lsub Loop2 : do if ( c2 >= len_trim ( uniq )) exit Loop2 if ( uniq ( c2 : c2 + Lsub - 1 ) == substring ) then c2 = c2 + Lsub else exit Loop2 endif enddo Loop2 uniq = uniq ( 1 : c1 ) // uniq ( c2 :) else c1 = c1 + Lsub endif enddo Loop1 return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique elemental function upper_case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be converted. character ( len = len ( string )) :: upper_case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- upper_case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) upper_case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper_case pure function wstrip ( string ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Strip out leading and trailing white spaces from a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( newstring , source = trim ( adjustl ( string ))) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction wstrip endmodule flap_utils_m","tags":"","loc":"sourcefile/flap_utils_m.f90.html","title":"flap_utils_m.f90 – FLAP"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This File Depends On sourcefile~~test_basic.f90~~EfferentGraph sourcefile~test_basic.f90 test_basic.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_basic.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_basicf90EfferentGraph = svgPanZoom('#sourcefiletest_basicf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_basic Source Code test_basic.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_basic !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize Command Line Interface call cli % init ( progname = 'test_basic' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"test_basic -s 'Hello FLAP'                               \" , & \"test_basic -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_basic -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_basic -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_basic -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_basic -s 'Hello FLAP' --man_file FLAP.1             \" , & \"test_basic 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_basic --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'test_basic.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parse Command Line Interface ! this is optional: if skipped the first call to cli%get will automatically call cli%parse call cli % parse ( error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_basic behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_basic has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str ( l , . true .)) // ') = ' // garbage ( l ) enddo endif if ( cli % is_passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_basic","tags":"","loc":"sourcefile/test_basic.f90.html","title":"test_basic.f90 – FLAP"},{"text":"Test FLAP for bad usage of choices option with logical This File Depends On sourcefile~~test_choices_logical.f90~~EfferentGraph sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_choices_logical.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_choices_logicalf90EfferentGraph = svgPanZoom('#sourcefiletest_choices_logicalf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_choices_logical Source Code test_choices_logical.f90 Source Code !< Test FLAP for bad usage of choices option with logical program test_choices_logical !----------------------------------------------------------------------------------------------------------------------------------- !< Test FLAP for bad usage of choices option with logical !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: vbval !< Valued-boolean value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( progname = 'test_choices_logical' ) call cli % add ( switch = '--boolean-value' , switch_ab = '-bv' , help = 'A help message' , & required = . false ., def = '.false.' , choices = '.True.,.False.' , act = 'store' , error = error ) call cli % parse ( error = error ) call cli % get ( switch = '-bv' , val = vbval , error = error ) print \"(A)\" , \"Error code: \" // trim ( str ( error , . true .)) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_choices_logical","tags":"","loc":"sourcefile/test_choices_logical.f90.html","title":"test_choices_logical.f90 – FLAP"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This File Depends On sourcefile~~test_hidden.f90~~EfferentGraph sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_hidden.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_hiddenf90EfferentGraph = svgPanZoom('#sourcefiletest_hiddenf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_hidden Source Code test_hidden.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_hidden !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. character ( 99 ) :: g_string !< Ghost string value. integer ( I4P ) :: a_integer !< Integer value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( description = 'hiddens usage FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--hidden' , switch_ab = '-hi' , help = 'ghost string' , required = . false ., def = 'gstring not passed' , & hidden = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = a_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-hi' , val = g_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = a_integer , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) print '(A)' , 'Ghost string = ' // trim ( adjustl ( g_string )) print '(A)' , 'Integer      = ' // trim ( adjustl ( str ( a_integer , . true .))) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_hidden","tags":"","loc":"sourcefile/test_hidden.f90.html","title":"test_hidden.f90 – FLAP"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This File Depends On sourcefile~~test_minimal.f90~~EfferentGraph sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_minimal.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_minimalf90EfferentGraph = svgPanZoom('#sourcefiletest_minimalf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_minimal Source Code test_minimal.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_minimal !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !< !< @note The minimal steps for using a FLAP CLI are: !<+ `init` the CLI; !<+ `add` at least one CLA to the CLI; !<+ `get` the CLAs defined into the CLI; !< !<Note that `get` automatically calls `parse` method beacuse it is not explicitely called. !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: string !< String value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_minimal","tags":"","loc":"sourcefile/test_minimal.f90.html","title":"test_minimal.f90 – FLAP"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This File Depends On sourcefile~~test_nested.f90~~EfferentGraph sourcefile~test_nested.f90 test_nested.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_nested.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_nestedf90EfferentGraph = svgPanZoom('#sourcefiletest_nestedf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_nested Source Code test_nested.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- authors_print = . false . ! initialize Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'test_nested                      ' , & 'test_nested -h                   ' , & 'test_nested init                 ' , & 'test_nested commit -m \"fix bug-1\"' , & 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parse Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! use Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_nested","tags":"","loc":"sourcefile/test_nested.f90.html","title":"test_nested.f90 – FLAP"},{"text":"A testing program for FLAP, Fortran command Line Arguments Parser for poor people This File Depends On sourcefile~~test_string.f90~~EfferentGraph sourcefile~test_string.f90 test_string.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_string.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_stringf90EfferentGraph = svgPanZoom('#sourcefiletest_stringf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_string Source Code test_string.f90 Source Code !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people program test_string !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize Command Line Interface call cli % init ( progname = 'test_sting' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with a fake string input' , & examples = [ \"test_sting -s 'Hello FLAP'                               \" , & \"test_sting -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_sting -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_sting -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_sting -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_sting 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_sting --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Arguments call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parse Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_string behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_string has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_string","tags":"","loc":"sourcefile/test_string.f90.html","title":"test_string.f90 – FLAP"},{"text":"Portability Environment for Fortran poor people. This File Depends On sourcefile~~penf.f90~~EfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf.f90~~AfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~penf.f90->sourcefile~test_choices_logical.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~penf.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~penf.f90->sourcefile~test_hidden.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~penf.f90->sourcefile~test_basic.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~penf.f90->sourcefile~test_string.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~penf.f90->sourcefile~test_minimal.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 var pansourcefilepenff90AfferentGraph = svgPanZoom('#sourcefilepenff90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf Source Code penf.F90 Source Code !< Portability Environment for Fortran poor people. module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 – FLAP"},{"text":"This File Depends On sourcefile~~penf_b_size.f90~~EfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_b_size.f90~~AfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~penf.f90->sourcefile~test_choices_logical.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~penf.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~penf.f90->sourcefile~test_hidden.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~penf.f90->sourcefile~test_basic.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~penf.f90->sourcefile~test_string.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~penf.f90->sourcefile~test_minimal.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 var pansourcefilepenf_b_sizef90AfferentGraph = svgPanZoom('#sourcefilepenf_b_sizef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_b_size Source Code penf_b_size.F90 Source Code module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size","tags":"","loc":"sourcefile/penf_b_size.f90.html","title":"penf_b_size.F90 – FLAP"},{"text":"Files Dependent On This One sourcefile~~penf_global_parameters_variables.f90~~AfferentGraph sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~penf.f90->sourcefile~test_choices_logical.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~penf.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~penf.f90->sourcefile~test_hidden.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~penf.f90->sourcefile~test_basic.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~penf.f90->sourcefile~test_string.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~penf.f90->sourcefile~test_minimal.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 var pansourcefilepenf_global_parameters_variablesf90AfferentGraph = svgPanZoom('#sourcefilepenf_global_parameters_variablesf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_global_parameters_variables Source Code penf_global_parameters_variables.F90 Source Code module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables","tags":"","loc":"sourcefile/penf_global_parameters_variables.f90.html","title":"penf_global_parameters_variables.F90 – FLAP"},{"text":"This File Depends On sourcefile~~penf_stringify.f90~~EfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_stringify.f90~~AfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~test_choices_logical.f90 test_choices_logical.f90 sourcefile~penf.f90->sourcefile~test_choices_logical.f90 sourcefile~flap_command_line_argument_t.f90 flap_command_line_argument_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~flap_command_line_arguments_group_t.f90 flap_command_line_arguments_group_t.f90 sourcefile~penf.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_interface_t.f90 flap_command_line_interface_t.F90 sourcefile~penf.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~flap_object_t.f90 flap_object_t.f90 sourcefile~penf.f90->sourcefile~flap_object_t.f90 sourcefile~flap_utils_m.f90 flap_utils_m.f90 sourcefile~penf.f90->sourcefile~flap_utils_m.f90 sourcefile~test_nested.f90 test_nested.f90 sourcefile~penf.f90->sourcefile~test_nested.f90 sourcefile~test_hidden.f90 test_hidden.f90 sourcefile~penf.f90->sourcefile~test_hidden.f90 sourcefile~test_basic.f90 test_basic.f90 sourcefile~penf.f90->sourcefile~test_basic.f90 sourcefile~test_string.f90 test_string.f90 sourcefile~penf.f90->sourcefile~test_string.f90 sourcefile~test_minimal.f90 test_minimal.f90 sourcefile~penf.f90->sourcefile~test_minimal.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90 flap.f90 sourcefile~flap_command_line_argument_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_command_line_arguments_group_t.f90->sourcefile~flap.f90 sourcefile~flap_command_line_interface_t.f90->sourcefile~flap.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_arguments_group_t.f90 sourcefile~flap_object_t.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_argument_t.f90 sourcefile~flap_utils_m.f90->sourcefile~flap_command_line_interface_t.f90 sourcefile~flap.f90->sourcefile~test_choices_logical.f90 sourcefile~flap.f90->sourcefile~test_nested.f90 sourcefile~flap.f90->sourcefile~test_hidden.f90 sourcefile~flap.f90->sourcefile~test_basic.f90 sourcefile~flap.f90->sourcefile~test_string.f90 sourcefile~flap.f90->sourcefile~test_minimal.f90 var pansourcefilepenf_stringifyf90AfferentGraph = svgPanZoom('#sourcefilepenf_stringifyf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_stringify Source Code penf_stringify.F90 Source Code module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify","tags":"","loc":"sourcefile/penf_stringify.f90.html","title":"penf_stringify.F90 – FLAP"},{"text":"PENF's testing program. This File Depends On sourcefile~~compact_real.f90~~EfferentGraph sourcefile~compact_real.f90 compact_real.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~compact_real.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefilecompact_realf90EfferentGraph = svgPanZoom('#sourcefilecompact_realf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs compact_real Source Code compact_real.f90 Source Code !< PENF's testing program. program compact_real !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init test_passed = . false . test_passed ( 1 ) = trim ( str ( n = 1._R8P , compact = . true .)) == '+0.1E+1' print \"(A,L1)\" , 'Compact 1.0: ' // trim ( str ( n = 1._R8P , compact = . true .)) // ', is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) == '+0.333333E+0' print \"(A,L1)\" , 'Compact 1.0/3.0: ' // trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) // ', is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) == '+0.25E+0' print \"(A,L1)\" , 'Compact 1.0/4.0: ' // trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) // ', is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram compact_real","tags":"","loc":"sourcefile/compact_real.f90.html","title":"compact_real.f90 – FLAP"},{"text":"PENF's testing program. This File Depends On sourcefile~~test_all.f90~~EfferentGraph sourcefile~test_all.f90 test_all.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~test_all.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefiletest_allf90EfferentGraph = svgPanZoom('#sourcefiletest_allf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs test_all Source Code test_all.F90 Source Code !< PENF's testing program. program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init call penf_print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"sourcefile/test_all.f90.html","title":"test_all.F90 – FLAP"},{"text":"type, public, extends( object ) :: command_line_argument type~~command_line_argument~~InheritsGraph type~command_line_argument command_line_argument type~object object type~object->type~command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Command Line Argument (CLA) class. Note If not otherwise declared the action on CLA value is set to \"store\" a value. Inherited By type~~command_line_argument~~InheritedByGraph type~command_line_argument command_line_argument type~command_line_arguments_group command_line_arguments_group type~command_line_argument->type~command_line_arguments_group cla type~command_line_interface command_line_interface type~command_line_arguments_group->type~command_line_interface clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables progname version help help_markdown description license authors epilog m_exclude error_message error usage_lun version_lun error_lun switch switch_ab is_required is_positional position is_passed is_hidden act def nargs choices val envvar Finalization Procedures finalize Type-Bound Procedures free_object print_version print_error_message assign_object free check is_required_passed raise_error_m_exclude raise_error_nargs_insufficient raise_error_value_missing raise_error_switch_unknown get get_varying sanitize_defaults usage signature errored check_envvar_consistency check_action_consistency check_optional_consistency check_m_exclude_consistency check_named_consistency check_positional_consistency check_choices check_list_size get_cla get_cla_from_buffer get_cla_list get_cla_list_from_buffer get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char cla_assign_cla assignment(=) Source Code command_line_argument Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: switch Switch name. character(len=:), public, allocatable :: switch_ab Abbreviated switch name. logical, public :: is_required = .false. Flag for set required argument. logical, public :: is_positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), public :: position = 0_I4P Position of positional CLA. logical, public :: is_passed = .false. Flag for checking if CLA has been passed to CLI. logical, public :: is_hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), public, allocatable :: act CLA value action. character(len=:), public, allocatable :: def Default value. character(len=:), public, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), public, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), public, allocatable :: val CLA value. character(len=:), public, allocatable :: envvar Environment variable from which take value. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. procedure, public :: check Check data consistency. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: is_required_passed Check if required CLA is passed. private function is_required_passed (self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_nargs_insufficient Raise error insufficient number of argument values passed. private subroutine raise_error_nargs_insufficient (self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_value_missing Raise error missing value. private subroutine raise_error_value_missing (self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: raise_error_switch_unknown Raise error switch_unknown. private subroutine raise_error_switch_unknown (self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: pref Prefixing string. generic, public :: get => get_cla , get_cla_list Get CLA value(s). private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from varying size list. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: sanitize_defaults Sanitize default values. private subroutine sanitize_defaults (self) Sanitize defaults values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data. procedure, public :: usage Get correct usage. private function usage (self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),\n  allocatable Usage string. procedure, public :: signature Get signature. private function signature (self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value character(len=:),\n  allocatable Signature. procedure, private :: errored Trig error occurence and print meaningful message. private subroutine errored (self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. procedure, private :: check_envvar_consistency Check data consistency for envvar CLA. private subroutine check_envvar_consistency (self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_action_consistency Check CLA action consistency. private subroutine check_action_consistency (self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_optional_consistency Check optional CLA consistency. private subroutine check_optional_consistency (self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_m_exclude_consistency Check mutually exclusion consistency. private subroutine check_m_exclude_consistency (self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_named_consistency Check named CLA consistency. private subroutine check_named_consistency (self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_positional_consistency Check positional CLA consistency. private subroutine check_positional_consistency (self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_choices Check if CLA value is in allowed choices. private subroutine check_choices (self, val, pref) Check if CLA value is in allowed choices. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: check_list_size Check CLA multiple values list size consistency. private function check_list_size (self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. procedure, private :: get_cla Get CLA (single) value. private subroutine get_cla (self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_from_buffer Get CLA (single) value from a buffer. private subroutine get_cla_from_buffer (self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list Get CLA multiple values. private subroutine get_cla_list (self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. procedure, private :: get_cla_list_from_buffer Get CLA (single) value from a buffer. private subroutine get_cla_list_from_buffer (self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values, varying size, R8P. private subroutine get_cla_list_varying_R8P (self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values, varying size, R4P. private subroutine get_cla_list_varying_R4P (self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values, varying size, I8P. private subroutine get_cla_list_varying_I8P (self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values, varying size, I4P. private subroutine get_cla_list_varying_I4P (self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values, varying size, I2P. private subroutine get_cla_list_varying_I2P (self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values, varying size, I1P. private subroutine get_cla_list_varying_I1P (self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_logical Get CLA multiple values, varying size, bool. private subroutine get_cla_list_varying_logical (self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_cla_list_varying_char Get CLA multiple values, varying size, char. private subroutine get_cla_list_varying_char (self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: cla_assign_cla Assignment operator. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. generic, private :: assignment(=) => cla_assign_cla Assignment operator overloading. private elemental subroutine cla_assign_cla (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. Source Code type , extends ( object ) :: command_line_argument !< Command Line Argument (CLA) class. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value. private character ( len = :), allocatable , public :: switch !< Switch name. character ( len = :), allocatable , public :: switch_ab !< Abbreviated switch name. logical , public :: is_required = . false . !< Flag for set required argument. logical , public :: is_positional = . false . !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), public :: position = 0_I4P !< Position of positional CLA. logical , public :: is_passed = . false . !< Flag for checking if CLA has been passed to CLI. logical , public :: is_hidden = . false . !< Flag for hiding CLA, thus it does not compare into help. character ( len = :), allocatable , public :: act !< CLA value action. character ( len = :), allocatable , public :: def !< Default value. character ( len = :), allocatable , public :: nargs !< Number of arguments consumed by CLA. character ( len = :), allocatable , public :: choices !< List (comma separated) of allowable values for the argument. character ( len = :), allocatable , public :: val !< CLA value. character ( len = :), allocatable , public :: envvar !< Environment variable from which take value. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLA is passed. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: raise_error_nargs_insufficient !< Raise error insufficient number of argument values passed. procedure , public :: raise_error_value_missing !< Raise error missing value. procedure , public :: raise_error_switch_unknown !< Raise error switch_unknown. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s). generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from varying size list. procedure , public :: sanitize_defaults !< Sanitize default values. procedure , public :: usage !< Get correct usage. procedure , public :: signature !< Get signature. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check_envvar_consistency !< Check data consistency for envvar CLA. procedure , private :: check_action_consistency !< Check CLA action consistency. procedure , private :: check_optional_consistency !< Check optional CLA consistency. procedure , private :: check_m_exclude_consistency !< Check mutually exclusion consistency. procedure , private :: check_named_consistency !< Check named CLA consistency. procedure , private :: check_positional_consistency !< Check positional CLA consistency. procedure , private :: check_choices !< Check if CLA value is in allowed choices. procedure , private :: check_list_size !< Check CLA multiple values list size consistency. procedure , private :: get_cla !< Get CLA (single) value. procedure , private :: get_cla_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list !< Get CLA multiple values. procedure , private :: get_cla_list_from_buffer !< Get CLA (single) value from a buffer. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values, varying size, char. procedure , private :: cla_assign_cla !< Assignment operator. generic , private :: assignment ( = ) => cla_assign_cla !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_argument","tags":"","loc":"type/command_line_argument.html","title":"command_line_argument – FLAP "},{"text":"type, public, extends( object ) :: command_line_arguments_group type~~command_line_arguments_group~~InheritsGraph type~command_line_arguments_group command_line_arguments_group type~command_line_argument command_line_argument type~command_line_argument->type~command_line_arguments_group cla type~object object type~object->type~command_line_arguments_group type~object->type~command_line_argument Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Command Line Arguments Group (CLAsG) class. CLAsG are useful for building nested commands. Inherited By type~~command_line_arguments_group~~InheritedByGraph type~command_line_arguments_group command_line_arguments_group type~command_line_interface command_line_interface type~command_line_arguments_group->type~command_line_interface clasg Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables progname version help help_markdown description license authors epilog m_exclude error_message error usage_lun version_lun error_lun group Na Na_required Na_optional cla is_called Finalization Procedures finalize Type-Bound Procedures free_object print_version print_error_message assign_object free check is_required_passed is_passed is_defined raise_error_m_exclude add parse usage signature sanitize_defaults errored check_m_exclusive clasg_assign_clasg assignment(=) Source Code command_line_arguments_group Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: group Group name (command). integer(kind=I4P), public :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of required command line arguments. integer(kind=I4P), private :: Na_optional = 0_I4P Number of optional command line arguments. type( command_line_argument ), public, allocatable :: cla (:) CLA list [1:Na]. logical, public :: is_called = .false. Flag for checking if CLAs group has been passed to CLI. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. procedure, public :: check Check data consistency. private subroutine check (self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: is_required_passed Check if required CLAs are passed. private subroutine is_required_passed (self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: is_passed Check if a CLA has been passed. private pure function is_passed (self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. procedure, public :: is_defined Check if a CLA has been defined. private function is_defined (self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. procedure, public :: raise_error_m_exclude Raise error mutually exclusive CLAs passed. private subroutine raise_error_m_exclude (self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: add Add CLA to CLAsG. private subroutine add (self, pref, cla) Add CLA to CLAs list. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. procedure, public :: parse Parse CLAsG arguments. private subroutine parse (self, args, pref) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in) :: args (:) Command line arguments. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: usage Get correct CLAsG usage. private function usage (self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),\n  allocatable Usage string. procedure, public :: signature Get CLAsG signature. private function signature (self) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. Return Value character(len=:),\n  allocatable Signature. procedure, public :: sanitize_defaults Sanitize default values. private subroutine sanitize_defaults (self) Sanitize defaults values. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. procedure, private :: errored Trig error occurrence and print meaningful message. private subroutine errored (self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs have been passed. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: clasg_assign_clasg Assignment operator. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => clasg_assign_clasg Assignment operator overloading. private elemental subroutine clasg_assign_clasg (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. Source Code type , extends ( object ) :: command_line_arguments_group !< Command Line Arguments Group (CLAsG) class. !< !< CLAsG are useful for building nested commands. private character ( len = :), allocatable , public :: group !< Group name (command). integer ( I4P ), public :: Na = 0_I4P !< Number of CLA. integer ( I4P ) :: Na_required = 0_I4P !< Number of required command line arguments. integer ( I4P ) :: Na_optional = 0_I4P !< Number of optional command line arguments. type ( command_line_argument ), allocatable , public :: cla (:) !< CLA list [1:Na]. logical , public :: is_called = . false . !< Flag for checking if CLAs group has been passed to CLI. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: check !< Check data consistency. procedure , public :: is_required_passed !< Check if required CLAs are passed. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: raise_error_m_exclude !< Raise error mutually exclusive CLAs passed. procedure , public :: add !< Add CLA to CLAsG. procedure , public :: parse !< Parse CLAsG arguments. procedure , public :: usage !< Get correct CLAsG usage. procedure , public :: signature !< Get CLAsG signature. procedure , public :: sanitize_defaults !< Sanitize default values. ! private methods procedure , private :: errored !< Trig error occurrence and print meaningful message. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs have been passed. procedure , private :: clasg_assign_clasg !< Assignment operator. generic , private :: assignment ( = ) => clasg_assign_clasg !< Assignment operator overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_arguments_group","tags":"","loc":"type/command_line_arguments_group.html","title":"command_line_arguments_group – FLAP "},{"text":"type, public, extends( object ) :: command_line_interface type~~command_line_interface~~InheritsGraph type~command_line_interface command_line_interface type~command_line_arguments_group command_line_arguments_group type~command_line_arguments_group->type~command_line_interface clasg type~command_line_argument command_line_argument type~command_line_argument->type~command_line_arguments_group cla type~object object type~object->type~command_line_interface type~object->type~command_line_arguments_group type~object->type~command_line_argument var pantypecommand_line_interfaceInheritsGraph = svgPanZoom('#typecommand_line_interfaceInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Command Line Interface (CLI) class. Variables progname version help help_markdown description license authors epilog m_exclude error_message error usage_lun version_lun error_lun clasg args examples disable_hv is_parsed_ Finalization Procedures finalize Type-Bound Procedures free_object print_version print_error_message assign_object free init add_group add is_passed is_defined_group is_defined is_parsed set_mutually_exclusive_groups run_command parse get get_varying usage signature print_usage save_man_page save_usage_to_markdown errored check check_m_exclusive get_clasg_indexes get_args get_args_from_string get_args_from_invocation get_cla get_cla_list get_cla_list_varying_R16P get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char cli_assign_cli assignment(=) Source Code command_line_interface Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages type( command_line_arguments_group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=512), private, allocatable :: args (:) Actually passed command line arguments. character(len=512), private, allocatable :: examples (:) Examples of correct usage. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. logical, private :: is_parsed_ = .false. Parse status. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private elemental subroutine finalize (self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data. Type-Bound Procedures procedure, public :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. procedure, public :: init Initialize CLI. private subroutine init (self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info procedure, public :: add_group Add CLAs group CLI. private subroutine add_group (self, help, description, exclude, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. procedure, public :: add Add CLA to CLI. private subroutine add (self, pref, group, group_index, switch, switch_ab, help, help_markdown, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. character(len=*), intent(in), optional :: help_markdown Longer help message, markdown formatted. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: is_passed Check if a CLA has been passed. private function is_passed (self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. procedure, public :: is_defined_group Check if a CLAs group has been defined. private function is_defined_group (self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. procedure, public :: is_defined Check if a CLA has been defined. private function is_defined (self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. procedure, public :: is_parsed Check if CLI has been parsed. private elemental function is_parsed (self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. procedure, public :: set_mutually_exclusive_groups Set two CLAs group as mutually exclusive. private subroutine set_mutually_exclusive_groups (self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. procedure, public :: run_command => is_called_group Check if a CLAs group has been run. private function is_called_group (self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. procedure, public :: parse Parse Command Line Interfaces. private subroutine parse (self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. generic, public :: get => get_cla , get_cla_list Get CLA value(s) from CLAs list parsed. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. generic, public :: get_varying => get_cla_list_varying_R8P , get_cla_list_varying_R4P , get_cla_list_varying_I8P , get_cla_list_varying_I4P , get_cla_list_varying_I2P , get_cla_list_varying_I1P , get_cla_list_varying_logical , get_cla_list_varying_char Get CLA value(s) from CLAs list parsed, varying size list. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: usage Get CLI usage. private function usage (self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),\n  allocatable Usage string. procedure, public :: signature Get CLI signature. private function signature (self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value character(len=:),\n  allocatable Signature. procedure, public :: print_usage Print correct usage of CLI. private subroutine print_usage (self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: save_man_page Save man page build on CLI. private subroutine save_man_page (self, man_file, error) Save man page build on the CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, public :: save_usage_to_markdown Save parts of the CLI as markdown. private subroutine save_usage_to_markdown (self, markdown_file, error) Save the CLI as a markdown page, for inclusion into the documentation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: errored Trig error occurence and print meaningful message. private subroutine errored (self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. procedure, private :: check Check data consistency. private subroutine check (self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: check_m_exclusive Check if two mutually exclusive CLAs group have been called. private subroutine check_m_exclusive (self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, private :: get_clasg_indexes Get CLAs groups indexes. private subroutine get_clasg_indexes (self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. generic, private :: get_args => get_args_from_string , get_args_from_invocation Get CLAs. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_args_from_string Get CLAs from string. private subroutine get_args_from_string (self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_args_from_invocation Get CLAs from CLI invocation. private subroutine get_args_from_invocation (self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. procedure, private :: get_cla Get CLA (single) value from CLAs list parsed. private subroutine get_cla (self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list Get CLA multiple values from CLAs list parsed. private subroutine get_cla_list (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R16P Get CLA multiple values from CLAs list parsed, varying size, R16P. private subroutine get_cla_list_varying_R16P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R8P Get CLA multiple values from CLAs list parsed, varying size, R8P. private subroutine get_cla_list_varying_R8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_R4P Get CLA multiple values from CLAs list parsed, varying size, R4P. private subroutine get_cla_list_varying_R4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I8P Get CLA multiple values from CLAs list parsed, varying size, I8P. private subroutine get_cla_list_varying_I8P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I4P Get CLA multiple values from CLAs list parsed, varying size, I4P. private subroutine get_cla_list_varying_I4P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I2P Get CLA multiple values from CLAs list parsed, varying size, I2P. private subroutine get_cla_list_varying_I2P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_I1P Get CLA multiple values from CLAs list parsed, varying size, I1P. private subroutine get_cla_list_varying_I1P (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_logical Get CLA multiple values from CLAs list parsed, varying size, bool. private subroutine get_cla_list_varying_logical (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: get_cla_list_varying_char Get CLA multiple values from CLAs list parsed, varying size, char. private subroutine get_cla_list_varying_char (self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. procedure, private :: cli_assign_cli CLI assignment overloading. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. generic, private :: assignment(=) => cli_assign_cli CLI assignment overloading. private elemental subroutine cli_assign_cli (lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. Source Code type , extends ( object ), public :: command_line_interface !< Command Line Interface (CLI) class. private type ( command_line_arguments_group ), allocatable :: clasg (:) !< CLA list [1:Na]. #ifdef __GFORTRAN__ character ( 512 ), allocatable :: args (:) !< Actually passed command line arguments. character ( 512 ), allocatable :: examples (:) !< Examples of correct usage. #else character ( len = :), allocatable :: args (:) !< Actually passed command line arguments. character ( len = :), allocatable :: examples (:) !< Examples of correct usage (not work with gfortran). #endif logical :: disable_hv = . false . !< Disable automatic 'help' and 'version' CLAs. logical :: is_parsed_ = . false . !< Parse status. contains ! public methods procedure , public :: free !< Free dynamic memory. procedure , public :: init !< Initialize CLI. procedure , public :: add_group !< Add CLAs group CLI. procedure , public :: add !< Add CLA to CLI. procedure , public :: is_passed !< Check if a CLA has been passed. procedure , public :: is_defined_group !< Check if a CLAs group has been defined. procedure , public :: is_defined !< Check if a CLA has been defined. procedure , public :: is_parsed !< Check if CLI has been parsed. procedure , public :: set_mutually_exclusive_groups !< Set two CLAs group as mutually exclusive. procedure , public :: run_command => is_called_group !< Check if a CLAs group has been run. procedure , public :: parse !< Parse Command Line Interfaces. generic , public :: get => & get_cla , & get_cla_list !< Get CLA value(s) from CLAs list parsed. generic , public :: get_varying => & #ifdef r16p get_cla_list_varying_R16P , & #endif get_cla_list_varying_R8P , & get_cla_list_varying_R4P , & get_cla_list_varying_I8P , & get_cla_list_varying_I4P , & get_cla_list_varying_I2P , & get_cla_list_varying_I1P , & get_cla_list_varying_logical , & get_cla_list_varying_char !< Get CLA value(s) from CLAs list parsed, varying size list. procedure , public :: usage !< Get CLI usage. procedure , public :: signature !< Get CLI signature. procedure , public :: print_usage !< Print correct usage of CLI. procedure , public :: save_man_page !< Save man page build on CLI. procedure , public :: save_usage_to_markdown !< Save parts of the CLI as markdown. ! private methods procedure , private :: errored !< Trig error occurence and print meaningful message. procedure , private :: check !< Check data consistency. procedure , private :: check_m_exclusive !< Check if two mutually exclusive CLAs group have been called. procedure , private :: get_clasg_indexes !< Get CLAs groups indexes. generic , private :: get_args => & get_args_from_string , & get_args_from_invocation !< Get CLAs. procedure , private :: get_args_from_string !< Get CLAs from string. procedure , private :: get_args_from_invocation !< Get CLAs from CLI invocation. procedure , private :: get_cla !< Get CLA (single) value from CLAs list parsed. procedure , private :: get_cla_list !< Get CLA multiple values from CLAs list parsed. procedure , private :: get_cla_list_varying_R16P !< Get CLA multiple values from CLAs list parsed, varying size, R16P. procedure , private :: get_cla_list_varying_R8P !< Get CLA multiple values from CLAs list parsed, varying size, R8P. procedure , private :: get_cla_list_varying_R4P !< Get CLA multiple values from CLAs list parsed, varying size, R4P. procedure , private :: get_cla_list_varying_I8P !< Get CLA multiple values from CLAs list parsed, varying size, I8P. procedure , private :: get_cla_list_varying_I4P !< Get CLA multiple values from CLAs list parsed, varying size, I4P. procedure , private :: get_cla_list_varying_I2P !< Get CLA multiple values from CLAs list parsed, varying size, I2P. procedure , private :: get_cla_list_varying_I1P !< Get CLA multiple values from CLAs list parsed, varying size, I1P. procedure , private :: get_cla_list_varying_logical !< Get CLA multiple values from CLAs list parsed, varying size, bool. procedure , private :: get_cla_list_varying_char !< Get CLA multiple values from CLAs list parsed, varying size, char. procedure , private :: cli_assign_cli !< CLI assignment overloading. generic , private :: assignment ( = ) => cli_assign_cli !< CLI assignment overloading. final :: finalize !< Free dynamic memory when finalizing. endtype command_line_interface","tags":"","loc":"type/command_line_interface.html","title":"command_line_interface – FLAP "},{"text":"type, public, abstract :: object Base (abstract) class upon which FLAP's concrete classes are built. Inherited By type~~object~~InheritedByGraph type~object object type~command_line_argument command_line_argument type~object->type~command_line_argument type~command_line_arguments_group command_line_arguments_group type~object->type~command_line_arguments_group type~command_line_interface command_line_interface type~object->type~command_line_interface type~command_line_argument->type~command_line_arguments_group cla type~command_line_arguments_group->type~command_line_interface clasg var pantypeobjectInheritedByGraph = svgPanZoom('#typeobjectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables progname version help help_markdown description license authors epilog m_exclude error_message error usage_lun version_lun error_lun Type-Bound Procedures free_object print_version print_error_message assign_object Source Code object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages Type-Bound Procedures procedure, public :: free_object Free dynamic memory. private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. procedure, public :: print_version Print version. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. procedure, public :: print_error_message Print meaningful error message. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. procedure, public :: assign_object Assignment overloading. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. Source Code type , abstract , public :: object !< Base (abstract) class upon which FLAP's concrete classes are built. private character ( len = :), public , allocatable :: progname !< Program name. character ( len = :), public , allocatable :: version !< Program version. character ( len = :), public , allocatable :: help !< Help message. character ( len = :), public , allocatable :: help_markdown !< Longer help message, markdown formatted. character ( len = :), public , allocatable :: description !< Detailed description. character ( len = :), public , allocatable :: license !< License description. character ( len = :), public , allocatable :: authors !< Authors list. character ( len = :), public , allocatable :: epilog !< Epilogue message. character ( len = :), public , allocatable :: m_exclude !< Mutually exclude other CLA(s group). character ( len = :), public , allocatable :: error_message !< Meaningful error message to standard-error. integer ( I4P ), public :: error = 0_I4P !< Error trapping flag. integer ( I4P ), public :: usage_lun = stderr !< Output unit to print help/usage messages integer ( I4P ), public :: version_lun = stdout !< Output unit to print version message integer ( I4P ), public :: error_lun = stderr !< Error unit to print error messages contains procedure :: free_object !< Free dynamic memory. procedure :: print_version !< Print version. procedure :: print_error_message !< Print meaningful error message. procedure :: assign_object !< Assignment overloading. endtype object","tags":"","loc":"type/object.html","title":"object – FLAP "},{"text":"private function is_required_passed(self, pref) result(is_ok) Check if required CLA is passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Source Code is_required_passed Source Code function is_required_passed ( self , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLA is passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if (((. not . self % is_passed ). and . self % is_required ). or .((. not . self % is_passed ). and .(. not . allocated ( self % def )))) then call self % errored ( pref = pref , error = ERROR_MISSING_REQUIRED ) is_ok = . false . endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_required_passed","tags":"","loc":"proc/is_required_passed.html","title":"is_required_passed – FLAP"},{"text":"private function usage(self, pref, markdown) Get correct usage. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLAs group data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: markdown Format for markdown Return Value character(len=:),\n  allocatable Usage string. Calls proc~~usage~~CallsGraph proc~usage usage interface~cton cton proc~usage->interface~cton interface~str str proc~usage->interface~str proc~replace_all replace_all proc~usage->proc~replace_all proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~wstrip wstrip proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code usage Source Code function usage ( self , pref , markdown ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( in ) :: self !< CLAs group data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: markdown !< Format for markdown character ( len = :), allocatable :: usage !< Usage string. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: a !< Counter. logical :: markdownd !< Format for markdown integer :: indent !< how many spaces to indent !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- markdownd = . false . ; if ( present ( markdown )) markdownd = markdown indent = 4 if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then usage = '' select case ( self % nargs ) case ( '+' ) usage = usage // ' value#1 [value#2...]' case ( '*' ) usage = usage // ' [value#1 value#2...]' case default do a = 1 , cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) usage = usage // ' value#' // trim ( str ( a , . true .)) enddo endselect if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`, `' // trim ( adjustl ( self % switch_ab )) // usage // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // usage // ', ' // trim ( adjustl ( self % switch_ab )) // usage endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // usage // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // usage endif endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`, `' // trim ( adjustl ( self % switch_ab )) // ' value' // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // ' value, ' // trim ( adjustl ( self % switch_ab )) // ' value' endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // ' value`' else usage = '   ' // trim ( adjustl ( self % switch )) // ' value' endif endif endif else usage = '  value' endif if ( allocated ( self % choices )) then usage = usage // ', value in: `' // self % choices // '`' endif elseif ( self % act == action_store_star ) then usage = '  [value]' if ( allocated ( self % choices )) then usage = usage // ', value in: (' // self % choices // ')' endif else if ( trim ( adjustl ( self % switch )) /= trim ( adjustl ( self % switch_ab ))) then if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`, `' // trim ( adjustl ( self % switch_ab )) // '`' else usage = '   ' // trim ( adjustl ( self % switch )) // ', ' // trim ( adjustl ( self % switch_ab )) endif else if ( markdownd ) then usage = new_line ( 'a' ) // '* `' // trim ( adjustl ( self % switch )) // '`' else usage = '   ' // trim ( adjustl ( self % switch )) endif endif endif prefd = '' ; if ( present ( pref )) prefd = pref usage = prefd // usage if ( self % is_positional ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( str ( self % position , . true .)) // & '-th argument' if ( allocated ( self % envvar )) then if ( self % envvar /= '' ) then usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // 'environment variable name \"' // trim ( adjustl ( self % envvar )) // '\"' endif endif if (. not . self % is_required ) then if ( self % def /= '' ) then if ( markdownd ) then ! two spaces make a line break in markdown. usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'default value ' // trim ( replace_all ( self % def , ARGS_SEP , ' ' )) endif endif endif if ( self % m_exclude /= '' ) usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // 'mutually exclude \"' // self % m_exclude // '\"' if ( markdownd ) then usage = usage // '  ' // new_line ( 'a' ) // prefd // repeat ( ' ' , 4 ) // trim ( adjustl ( self % help )) if ( self % help_markdown /= '' ) then usage = usage // trim ( adjustl ( self % help_markdown )) endif else usage = usage // new_line ( 'a' ) // prefd // repeat ( ' ' , indent ) // trim ( adjustl ( self % help )) endif else usage = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage","tags":"","loc":"proc/usage.html","title":"usage – FLAP"},{"text":"private function signature(self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(in) :: self CLA data. Return Value character(len=:),\n  allocatable Signature. Calls proc~~signature~~CallsGraph proc~signature signature interface~cton cton proc~signature->interface~cton interface~str str proc~signature->interface~str proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code signature Source Code function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( in ) :: self !< CLA data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: nargs !< Number of arguments consumed by CLA. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_hidden ) then if ( self % act == action_store ) then if (. not . self % is_positional ) then if ( allocated ( self % nargs )) then select case ( self % nargs ) case ( '+' ) signature = ' value#1 [value#2 value#3...]' case ( '*' ) signature = ' [value#1 value#2 value#3...]' case default nargs = cton ( str = trim ( adjustl ( self % nargs )), knd = 1_I4P ) signature = '' do a = 1 , nargs signature = signature // ' value#' // trim ( str ( a , . true .)) enddo endselect else signature = ' value' endif if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) // signature else signature = ' [' // trim ( adjustl ( self % switch )) // signature // ']' endif else if ( self % is_required ) then signature = ' value' else signature = ' [value]' endif endif elseif ( self % act == action_store_star ) then signature = ' [value]' else if ( self % is_required ) then signature = ' ' // trim ( adjustl ( self % switch )) else signature = ' [' // trim ( adjustl ( self % switch )) // ']' endif endif else signature = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature.html","title":"signature – FLAP"},{"text":"private function check_list_size(self, Nv, val, pref) result(is_ok) Check CLA multiple values list size consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: Nv Number of values. character(len=*), intent(in) :: val First value. character(len=*), intent(in), optional :: pref Prefixing string. Return Value logical Check result. Source Code check_list_size Source Code function check_list_size ( self , Nv , val , pref ) result ( is_ok ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA multiple values list size consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: Nv !< Number of values. character ( * ), intent ( in ) :: val !< First value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical :: is_ok !< Check result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_ok = . true . if ( Nv == 1 ) then if ( trim ( adjustl ( val )) == '' ) then ! there is no real value, but only for nargs=+ this is a real error is_ok = . false . if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction check_list_size","tags":"","loc":"proc/check_list_size.html","title":"check_list_size – FLAP"},{"text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. Source Code free Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_argument members if ( allocated ( self % switch )) deallocate ( self % switch ) if ( allocated ( self % switch_ab )) deallocate ( self % switch_ab ) if ( allocated ( self % act )) deallocate ( self % act ) if ( allocated ( self % def )) deallocate ( self % def ) if ( allocated ( self % nargs )) deallocate ( self % nargs ) if ( allocated ( self % choices )) deallocate ( self % choices ) if ( allocated ( self % val )) deallocate ( self % val ) if ( allocated ( self % envvar )) deallocate ( self % envvar ) self % is_required = . false . self % is_positional = . false . self % position = 0_I4P self % is_passed = . false . self % is_hidden = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free – FLAP"},{"text":"private subroutine check(self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check Source Code subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % check_envvar_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_action_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_optional_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_m_exclude_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_named_consistency ( pref = pref ) ; if ( self % error /= 0 ) return call self % check_positional_consistency ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check.html","title":"check – FLAP"},{"text":"private subroutine raise_error_m_exclude(self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_m_exclude Source Code subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude","tags":"","loc":"proc/raise_error_m_exclude.html","title":"raise_error_m_exclude – FLAP"},{"text":"private subroutine raise_error_nargs_insufficient(self, pref) Raise error insufficient number of argument values passed. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_nargs_insufficient Source Code subroutine raise_error_nargs_insufficient ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error insufficient number of argument values passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_nargs_insufficient","tags":"","loc":"proc/raise_error_nargs_insufficient.html","title":"raise_error_nargs_insufficient – FLAP"},{"text":"private subroutine raise_error_value_missing(self, pref) Raise error missing value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_value_missing Source Code subroutine raise_error_value_missing ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error missing value. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_VALUE_MISSING ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_value_missing","tags":"","loc":"proc/raise_error_value_missing.html","title":"raise_error_value_missing – FLAP"},{"text":"private subroutine raise_error_switch_unknown(self, switch, pref) Raise error switch_unknown. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_switch_unknown Source Code subroutine raise_error_switch_unknown ( self , switch , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error switch_unknown. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_UNKNOWN , switch = switch ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_switch_unknown","tags":"","loc":"proc/raise_error_switch_unknown.html","title":"raise_error_switch_unknown – FLAP"},{"text":"private subroutine sanitize_defaults(self) Sanitize defaults values. It is necessary to sanitize the default values of non-passed, optional CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLAsG data. Calls proc~~sanitize_defaults~~CallsGraph proc~sanitize_defaults sanitize_defaults proc~unique unique proc~sanitize_defaults->proc~unique proc~wstrip wstrip proc~sanitize_defaults->proc~wstrip proc~replace_all replace_all proc~sanitize_defaults->proc~replace_all proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sanitize_defaults Source Code subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_passed ) then if ( allocated ( self % def )) then ! strip leading and trailing white spaces self % def = wstrip ( self % def ) if ( allocated ( self % nargs )) then ! replace white space separator with FLAP ARGS_SEP self % def = unique ( string = self % def , substring = ' ' ) self % def = replace_all ( string = self % def , substring = ' ' , restring = ARGS_SEP ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults","tags":"","loc":"proc/sanitize_defaults.html","title":"sanitize_defaults – FLAP"},{"text":"private subroutine errored(self, error, pref, switch, val_str, log_value) Trig error occurence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: switch CLA switch name. character(len=*), intent(in), optional :: val_str Value string. character(len=*), intent(in), optional :: log_value Logical value to be casted. Calls proc~~errored~~CallsGraph proc~errored errored interface~str str proc~errored->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code errored Source Code subroutine errored ( self , error , pref , switch , val_str , log_value ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( * ), optional , intent ( in ) :: val_str !< Value string. character ( * ), optional , intent ( in ) :: log_value !< Logical value to be casted. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select case ( self % error ) case ( ERROR_OPTIONAL_NO_DEF ) if ( self % is_positional ) then self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( n = self % position )) // & '-th\" positional option has not a default value!' else self % error_message = prefd // self % progname // ': error: named option \"' // self % switch // '\" has not a default value!' endif case ( ERROR_REQUIRED_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: named option \"' // self % switch // '\" cannot exclude others' // & ', it being requiredi, only optional ones can!' case ( ERROR_POSITIONAL_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( n = self % position )) // & '-th\" positional option cannot exclude others, only optional named options can!' case ( ERROR_NAMED_NO_NAME ) self % error_message = prefd // self % progname // ': error: a non positional optiona must have a switch name!' case ( ERROR_POSITIONAL_NO_POSITION ) self % error_message = prefd // self % progname // ': error: a positional option must have a position number different from 0!' case ( ERROR_POSITIONAL_NO_STORE ) self % error_message = prefd // self % progname // ': error: a positional option must have action set to \"' // action_store // '\"!' case ( ERROR_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: the options \"' // self % switch // '\" and \"' // self % m_exclude // & '\" are mutually exclusive, but both have been passed!' case ( ERROR_NOT_IN_CHOICES ) if ( self % is_positional ) then self % error_message = prefd // self % progname // ': error: value of \"' // trim ( str ( n = self % position )) // & '-th\" positional option must be chosen in:' else self % error_message = prefd // self % progname // ': error: value of named option \"' // self % switch // '\" must be chosen in: ' endif self % error_message = self % error_message // '(' // self % choices // ')' self % error_message = self % error_message // ' but \"' // trim ( val_str ) // '\" has been passed!' case ( ERROR_MISSING_REQUIRED ) if (. not . self % is_positional ) then self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // '\" is required!' else self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option is required!' endif case ( ERROR_CASTING_LOGICAL ) self % error_message = prefd // self % progname // ': error: cannot convert \"' // log_value // '\" of option \"' // self % switch // & '\" to logical type!' case ( ERROR_CHOICES_LOGICAL ) self % error_message = prefd // self % progname // ': error: cannot use \"choices\" value check for option \"' // self % switch // & '\" it being of logical type! The choices is, by definition of logical, limited to \".true.\" or \".false.\"' case ( ERROR_NO_LIST ) if (. not . self % is_positional ) then self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has not \"nargs\" value but an array has been passed to \"get\" method!' else self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has not \"nargs\" value but an array has been passed to \"get\" method!' endif case ( ERROR_NARGS_INSUFFICIENT ) if (. not . self % is_positional ) then if ( self % nargs == '+' ) then self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" requires at least 1 argument but no one remains!' else self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // '\" requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif else if ( self % nargs == '+' ) then self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires at least 1 argument but no one remains' else self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // & '-th\" positional option requires ' // & trim ( adjustl ( self % nargs )) // ' arguments but no enough ones remain!' endif endif case ( ERROR_VALUE_MISSING ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" needs a value that is not passed!' case ( ERROR_UNKNOWN ) self % error_message = prefd // self % progname // ': error: switch \"' // trim ( adjustl ( switch )) // '\" is unknown!' case ( ERROR_ENVVAR_POSITIONAL ) self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"envvar\" value that is not allowed for positional option!' case ( ERROR_ENVVAR_NOT_STORE ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar with action different from \"' // action_store // '\" that is not allowed!' case ( ERROR_ENVVAR_NARGS ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" is an envvar that is not allowed for list valued option!' case ( ERROR_STORE_STAR_POSITIONAL ) self % error_message = prefd // self % progname // ': error: \"' // trim ( str ( self % position , . true .)) // '-th\" positional option ' // & 'has \"' // action_store_star // '\" action that is not allowed for positional option!' case ( ERROR_STORE_STAR_NARGS ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for list valued option!' case ( ERROR_STORE_STAR_ENVVAR ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has \"' // action_store_star // '\" action that is not allowed for environment variable option!' case ( ERROR_ACTION_UNKNOWN ) self % error_message = prefd // self % progname // ': error: named option \"' // trim ( adjustl ( self % switch )) // & '\" has unknown \"' // self % act // '\" action!' endselect call self % print_error_message endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored","tags":"","loc":"proc/errored.html","title":"errored – FLAP"},{"text":"private subroutine check_envvar_consistency(self, pref) Check data consistency for envvar CLA. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_envvar_consistency Source Code subroutine check_envvar_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency for envvar CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % envvar )) then if ( self % is_positional ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_POSITIONAL ) return endif if (. not . allocated ( self % act )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return else if ( self % act /= action_store ) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NOT_STORE ) return endif endif if ( allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_ENVVAR_NARGS ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_envvar_consistency","tags":"","loc":"proc/check_envvar_consistency.html","title":"check_envvar_consistency – FLAP"},{"text":"private subroutine check_action_consistency(self, pref) Check CLA action consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_action_consistency Source Code subroutine check_action_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check CLA action consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % act )) then if ( self % act == ACTION_STORE_STAR . and . self % is_positional ) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_POSITIONAL ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_NARGS ) return endif if ( self % act == ACTION_STORE_STAR . and . allocated ( self % envvar )) then call self % errored ( pref = pref , error = ERROR_STORE_STAR_ENVVAR ) return endif if ( self % act /= ACTION_STORE . and . & self % act /= ACTION_STORE_STAR . and . & self % act /= ACTION_STORE_TRUE . and . & self % act /= ACTION_STORE_FALSE . and .& self % act /= ACTION_PRINT_HELP . and . & self % act /= ACTION_PRINT_VERS ) then call self % errored ( pref = pref , error = ERROR_ACTION_UNKNOWN ) return endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_action_consistency","tags":"","loc":"proc/check_action_consistency.html","title":"check_action_consistency – FLAP"},{"text":"private subroutine check_optional_consistency(self, pref) Check optional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_optional_consistency Source Code subroutine check_optional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check optional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_required ). and .(. not . allocated ( self % def ))) call self % errored ( pref = pref , error = ERROR_OPTIONAL_NO_DEF ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_optional_consistency","tags":"","loc":"proc/check_optional_consistency.html","title":"check_optional_consistency – FLAP"},{"text":"private subroutine check_m_exclude_consistency(self, pref) Check mutually exclusion consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_m_exclude_consistency Source Code subroutine check_m_exclude_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check mutually exclusion consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_required ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_REQUIRED_M_EXCLUDE ) return endif if (( self % is_positional ). and .( self % m_exclude /= '' )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_M_EXCLUDE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclude_consistency","tags":"","loc":"proc/check_m_exclude_consistency.html","title":"check_m_exclude_consistency – FLAP"},{"text":"private subroutine check_named_consistency(self, pref) Check named CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_named_consistency Source Code subroutine check_named_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check named CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ((. not . self % is_positional ). and .(. not . allocated ( self % switch ))) call self % errored ( pref = pref , error = ERROR_NAMED_NO_NAME ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_named_consistency","tags":"","loc":"proc/check_named_consistency.html","title":"check_named_consistency – FLAP"},{"text":"private subroutine check_positional_consistency(self, pref) Check positional CLA consistency. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_positional_consistency Source Code subroutine check_positional_consistency ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check positional CLA consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( self % is_positional ). and .( self % position == 0_I4P )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_POSITION ) return elseif (( self % is_positional ). and .( self % act /= action_store )) then call self % errored ( pref = pref , error = ERROR_POSITIONAL_NO_STORE ) return endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_positional_consistency","tags":"","loc":"proc/check_positional_consistency.html","title":"check_positional_consistency – FLAP"},{"text":"private subroutine check_choices(self, val, pref) Check if CLA value is in allowed choices. Note This procedure can be called if and only if cla%choices has been allocated. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(in) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~check_choices~~CallsGraph proc~check_choices check_choices interface~cton cton proc~check_choices->interface~cton proc~tokenize tokenize proc~check_choices->proc~tokenize interface~str str proc~check_choices->interface~str proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_choices Source Code subroutine check_choices ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLA value is in allowed choices. !< !< @note This procedure can be called if and only if cla%choices has been allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( in ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len ( self % choices )), allocatable :: toks (:) !< Tokens for parsing choices list. integer ( I4P ) :: Nc !< Number of choices. logical :: val_in !< Flag for checking if val is in the choosen range. character ( len = :), allocatable :: val_str !< Value in string form. character ( len = :), allocatable :: tmp !< Temporary string for avoiding GNU gfrotran bug. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- val_in = . false . val_str = '' tmp = self % choices call tokenize ( strin = tmp , delimiter = ',' , toks = toks , Nt = Nc ) select type ( val ) #ifdef r16p type is ( real ( R16P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R16P )) val_in = . true . enddo #endif type is ( real ( R8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R8P )) val_in = . true . enddo type is ( real ( R4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1._R4P )) val_in = . true . enddo type is ( integer ( I8P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I8P )) val_in = . true . enddo type is ( integer ( I4P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I4P )) val_in = . true . enddo type is ( integer ( I2P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I2P )) val_in = . true . enddo type is ( integer ( I1P )) val_str = str ( n = val ) do c = 1 , Nc if ( val == cton ( str = trim ( adjustl ( toks ( c ))), knd = 1_I1P )) val_in = . true . enddo type is ( character ( * )) val_str = val do c = 1 , Nc if ( val == toks ( c )) val_in = . true . enddo type is ( logical ) call self % errored ( pref = pref , error = ERROR_CHOICES_LOGICAL ) endselect if (. not . val_in . and .( self % error == 0 )) then call self % errored ( pref = pref , error = ERROR_NOT_IN_CHOICES , val_str = val_str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_choices","tags":"","loc":"proc/check_choices.html","title":"check_choices – FLAP"},{"text":"private subroutine get_cla(self, val, pref) Get CLA (single) value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Source Code get_cla Source Code subroutine get_cla ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if ( self % act == action_store . or . self % act == action_store_star ) then if ( self % is_passed . and . allocated ( self % val )) then call self % get_cla_from_buffer ( buffer = self % val , val = val , pref = pref ) elseif ( allocated ( self % def )) then ! using default value call self % get_cla_from_buffer ( buffer = self % def , val = val , pref = pref ) endif if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val , pref = pref ) elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect elseif ( allocated ( self % def )) then select type ( val ) type is ( logical ) read ( self % def , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = self % def ) endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla","tags":"","loc":"proc/get_cla.html","title":"get_cla – FLAP"},{"text":"private subroutine get_cla_from_buffer(self, buffer, val, pref) Get CLA (single) value from parsed value. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_from_buffer~~CallsGraph proc~get_cla_from_buffer get_cla_from_buffer interface~cton cton proc~get_cla_from_buffer->interface~cton proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_from_buffer Source Code subroutine get_cla_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from parsed value. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( val ) #ifdef r16p type is ( real ( R16P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R16P ) #endif type is ( real ( R8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R8P ) type is ( real ( R4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1._R4P ) type is ( integer ( I8P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I8P ) type is ( integer ( I4P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I4P ) type is ( integer ( I2P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I2P ) type is ( integer ( I1P )) val = cton ( pref = pref , error = self % error , str = trim ( adjustl ( buffer )), knd = 1_I1P ) type is ( logical ) read ( buffer , * , iostat = self % error ) val if ( self % error /= 0 ) call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = buffer ) type is ( character ( * )) val = buffer endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_from_buffer","tags":"","loc":"proc/get_cla_from_buffer.html","title":"get_cla_from_buffer – FLAP"},{"text":"private subroutine get_cla_list(self, pref, val) Get CLA multiple values. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. class(*), intent(inout) :: val (1:) CLA values. Calls proc~~get_cla_list~~CallsGraph proc~get_cla_list get_cla_list proc~tokenize tokenize proc~get_cla_list->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list Source Code subroutine get_cla_list ( self , pref , val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call self % get_cla_list_from_buffer ( buffer = self % val , val = val , pref = pref ) else ! using default value call self % get_cla_list_from_buffer ( buffer = self % def , val = val , pref = pref ) endif elseif ( self % act == action_store_true ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . true . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif elseif ( self % act == action_store_false ) then if ( self % is_passed ) then select type ( val ) type is ( logical ) val = . false . endselect else call tokenize ( strin = self % def , delimiter = ' ' , toks = valsD , Nt = Nv ) select type ( val ) type is ( logical ) do v = 1 , Nv read ( valsD ( v ), * ) val ( v ) enddo endselect endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list.html","title":"get_cla_list – FLAP"},{"text":"private subroutine get_cla_list_from_buffer(self, buffer, val, pref) Get CLA multiple values from a buffer. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(in) :: buffer Buffer containing values (parsed or default CLA value). class(*), intent(inout) :: val (1:) CLA value. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_from_buffer~~CallsGraph proc~get_cla_list_from_buffer get_cla_list_from_buffer interface~cton cton proc~get_cla_list_from_buffer->interface~cton proc~tokenize tokenize proc~get_cla_list_from_buffer->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_from_buffer Source Code subroutine get_cla_list_from_buffer ( self , buffer , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from a buffer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), intent ( in ) :: buffer !< Buffer containing values (parsed or default CLA value). class ( * ), intent ( inout ) :: val ( 1 :) !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( buffer )), allocatable :: vals (:) !< String array of values based on buffer value. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = buffer , delimiter = args_sep , toks = vals , Nt = Nv ) select type ( val ) #ifdef r16p type is ( real ( R16P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R16P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo #endif type is ( real ( R8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( real ( R4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1._R4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I8P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I8P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I4P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I4P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I2P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I2P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( integer ( I1P )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( vals ( v ))), knd = 1_I1P ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo type is ( logical ) do v = 1 , Nv read ( vals ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = vals ( v )) exit endif enddo type is ( character ( * )) do v = 1 , Nv val ( v ) = vals ( v ) if ( allocated ( self % choices ). and . self % error == 0 ) call self % check_choices ( val = val ( v ), pref = pref ) if ( self % error /= 0 ) exit enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_from_buffer","tags":"","loc":"proc/get_cla_list_from_buffer.html","title":"get_cla_list_from_buffer – FLAP"},{"text":"private subroutine get_cla_list_varying_R16P(self, val, pref) Get CLA (multiple) value with varying size, real(R16P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r16p~~CallsGraph proc~get_cla_list_varying_r16p get_cla_list_varying_R16P interface~cton cton proc~get_cla_list_varying_r16p->interface~cton proc~tokenize tokenize proc~get_cla_list_varying_r16p->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_R16P Source Code subroutine get_cla_list_varying_R16P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return if ( Nv == 1 ) then if ( trim ( adjustl ( valsD ( 1 ))) == '' ) then if ( self % nargs == '+' ) then call self % errored ( pref = pref , error = ERROR_NARGS_INSUFFICIENT ) endif return endif endif allocate ( real ( R16P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R16P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p.html","title":"get_cla_list_varying_R16P – FLAP"},{"text":"private subroutine get_cla_list_varying_R8P(self, val, pref) Get CLA (multiple) value with varying size, real(R8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r8p~~CallsGraph proc~get_cla_list_varying_r8p get_cla_list_varying_R8P interface~cton cton proc~get_cla_list_varying_r8p->interface~cton proc~tokenize tokenize proc~get_cla_list_varying_r8p->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_R8P Source Code subroutine get_cla_list_varying_R8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p.html","title":"get_cla_list_varying_R8P – FLAP"},{"text":"private subroutine get_cla_list_varying_R4P(self, val, pref) Get CLA (multiple) value with varying size, real(R4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_r4p~~CallsGraph proc~get_cla_list_varying_r4p get_cla_list_varying_R4P interface~cton cton proc~get_cla_list_varying_r4p->interface~cton proc~tokenize tokenize proc~get_cla_list_varying_r4p->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_R4P Source Code subroutine get_cla_list_varying_R4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, real(R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( real ( R4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1._R4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p.html","title":"get_cla_list_varying_R4P – FLAP"},{"text":"private subroutine get_cla_list_varying_I8P(self, val, pref) Get CLA (multiple) value with varying size, integer(I8P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i8p~~CallsGraph proc~get_cla_list_varying_i8p get_cla_list_varying_I8P interface~cton cton proc~get_cla_list_varying_i8p->interface~cton proc~tokenize tokenize proc~get_cla_list_varying_i8p->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I8P Source Code subroutine get_cla_list_varying_I8P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I8P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I8P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p.html","title":"get_cla_list_varying_I8P – FLAP"},{"text":"private subroutine get_cla_list_varying_I4P(self, val, pref) Get CLA (multiple) value with varying size, integer(I4P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i4p~~CallsGraph proc~get_cla_list_varying_i4p get_cla_list_varying_I4P interface~cton cton proc~get_cla_list_varying_i4p->interface~cton proc~tokenize tokenize proc~get_cla_list_varying_i4p->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I4P Source Code subroutine get_cla_list_varying_I4P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( INOUT ) :: self !< CLA data. integer ( I4P ), allocatable , intent ( OUT ) :: val (:) !< CLA values. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I4P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I4P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p.html","title":"get_cla_list_varying_I4P – FLAP"},{"text":"private subroutine get_cla_list_varying_I2P(self, val, pref) Get CLA (multiple) value with varying size, integer(I2P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i2p~~CallsGraph proc~get_cla_list_varying_i2p get_cla_list_varying_I2P interface~cton cton proc~get_cla_list_varying_i2p->interface~cton proc~tokenize tokenize proc~get_cla_list_varying_i2p->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I2P Source Code subroutine get_cla_list_varying_I2P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I2P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I2P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p.html","title":"get_cla_list_varying_I2P – FLAP"},{"text":"private subroutine get_cla_list_varying_I1P(self, val, pref) Get CLA (multiple) value with varying size, integer(I1P). Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_i1p~~CallsGraph proc~get_cla_list_varying_i1p get_cla_list_varying_I1P interface~cton cton proc~get_cla_list_varying_i1p->interface~cton proc~tokenize tokenize proc~get_cla_list_varying_i1p->proc~tokenize proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_I1P Source Code subroutine get_cla_list_varying_I1P ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, integer(I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsV ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( integer ( I1P ) :: val ( 1 : Nv )) do v = 1 , Nv val ( v ) = cton ( pref = pref , error = self % error , str = trim ( adjustl ( valsD ( v ))), knd = 1_I1P ) if ( self % error /= 0 ) exit enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p.html","title":"get_cla_list_varying_I1P – FLAP"},{"text":"private subroutine get_cla_list_varying_logical(self, val, pref) Get CLA (multiple) value with varying size, logical. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_logical~~CallsGraph proc~get_cla_list_varying_logical get_cla_list_varying_logical proc~tokenize tokenize proc~get_cla_list_varying_logical->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_logical Source Code subroutine get_cla_list_varying_logical ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, logical. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsV ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( logical :: val ( 1 : Nv )) do v = 1 , Nv read ( valsD ( v ), * , iostat = self % error ) val ( v ) if ( self % error /= 0 ) then call self % errored ( pref = pref , error = ERROR_CASTING_LOGICAL , log_value = valsD ( v )) exit endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical.html","title":"get_cla_list_varying_logical – FLAP"},{"text":"private subroutine get_cla_list_varying_char(self, val, pref) Get CLA (multiple) value with varying size, character. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: self CLA data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~get_cla_list_varying_char~~CallsGraph proc~get_cla_list_varying_char get_cla_list_varying_char proc~tokenize tokenize proc~get_cla_list_varying_char->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_cla_list_varying_char Source Code subroutine get_cla_list_varying_char ( self , val , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (multiple) value with varying size, character. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: self !< CLA data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: Nv !< Number of values. character ( len = len ( self % val )), allocatable :: valsV (:) !< String array of values based on self%val. character ( len = len ( self % def )), allocatable :: valsD (:) !< String array of values based on self%def. integer ( I4P ) :: v !< Values counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_required_passed ( pref = pref )) return if (. not . allocated ( self % nargs )) then call self % errored ( pref = pref , error = ERROR_NO_LIST ) return endif if ( self % act == action_store ) then if ( self % is_passed ) then call tokenize ( strin = self % val , delimiter = ARGS_SEP , toks = valsV , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsV ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsV ( v ))) enddo else ! using default value call tokenize ( strin = self % def , delimiter = ARGS_SEP , toks = valsD , Nt = Nv ) if (. not . self % check_list_size ( Nv = Nv , val = valsD ( 1 ), pref = pref )) return allocate ( val ( 1 : Nv )) do v = 1 , Nv val ( v ) = trim ( adjustl ( valsD ( v ))) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char.html","title":"get_cla_list_varying_char – FLAP"},{"text":"private elemental subroutine cla_assign_cla(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_argument ), intent(inout) :: lhs Left hand side. type( command_line_argument ), intent(in) :: rhs Rigth hand side. Source Code cla_assign_cla Source Code elemental subroutine cla_assign_cla ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_argument ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_argument ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_argument members if ( allocated ( rhs % switch )) lhs % switch = rhs % switch if ( allocated ( rhs % switch_ab )) lhs % switch_ab = rhs % switch_ab if ( allocated ( rhs % act )) lhs % act = rhs % act if ( allocated ( rhs % def )) lhs % def = rhs % def if ( allocated ( rhs % nargs )) lhs % nargs = rhs % nargs if ( allocated ( rhs % choices )) lhs % choices = rhs % choices if ( allocated ( rhs % val )) lhs % val = rhs % val if ( allocated ( rhs % envvar )) lhs % envvar = rhs % envvar lhs % is_required = rhs % is_required lhs % is_positional = rhs % is_positional lhs % position = rhs % position lhs % is_passed = rhs % is_passed lhs % is_hidden = rhs % is_hidden return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine cla_assign_cla","tags":"","loc":"proc/cla_assign_cla.html","title":"cla_assign_cla – FLAP"},{"text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_argument ), intent(inout) :: self CLA data. Source Code finalize Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_argument ), intent ( inout ) :: self !< CLA data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FLAP"},{"text":"private pure function is_passed(self, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Source Code is_passed Source Code pure function is_passed ( self , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_passed = . false . if ( self % Na > 0 ) then if ( present ( switch )) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_passed = self % cla ( a )% is_passed exit endif endif enddo elseif ( present ( position )) then is_passed = self % cla ( position )% is_passed endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_passed","tags":"","loc":"proc/is_passed.html","title":"is_passed – FLAP"},{"text":"private function is_defined(self, switch, pos) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in) :: switch Switch name. integer(kind=I4P), intent(out), optional :: pos CLA position. Return Value logical Check if a CLA has been defined. Source Code is_defined Source Code function is_defined ( self , switch , pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( out ) :: pos !< CLA position. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: a !< CLA counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_defined = . false . if ( present ( pos )) pos = 0 if ( self % Na > 0 ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if (( self % cla ( a )% switch == switch ). or .( self % cla ( a )% switch_ab == switch )) then is_defined = . true . if ( present ( pos )) pos = a exit endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined","tags":"","loc":"proc/is_defined.html","title":"is_defined – FLAP"},{"text":"private function usage(self, pref, no_header, markdown) Get correct CLAsG usage. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: markdown Format things form markdown. Return Value character(len=:),\n  allocatable Usage string. Source Code usage Source Code function usage ( self , pref , no_header , markdown ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get correct CLAsG usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: markdown !< Format things form markdown. character ( len = :), allocatable :: usage !< Usage string. integer ( I4P ) :: a !< Counters. character ( len = :), allocatable :: prefd !< Prefixing string. logical :: markdownd !< Markdonw format, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref usage = self % progname ; if ( self % group /= '' ) usage = self % progname // ' ' // self % group usage = prefd // self % help // ' ' // usage // self % signature () if ( self % description /= '' ) usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description if ( present ( no_header )) then if ( no_header ) usage = '' endif if ( self % Na_required > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Required switches:' do a = 1 , self % Na if ( self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif if ( self % Na_optional > 0 ) then usage = usage // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Optional switches:' do a = 1 , self % Na if (. not . self % cla ( a )% is_required . and .(. not . self % cla ( a )% is_hidden )) usage = usage // new_line ( 'a' ) // & self % cla ( a )% usage ( pref = prefd , markdown = markdownd ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage","tags":"","loc":"proc/usage~2.html","title":"usage – FLAP"},{"text":"private function signature(self) Get CLAsG signature. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(in) :: self CLAsG data. Return Value character(len=:),\n  allocatable Signature. Source Code signature Source Code function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAsG signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( in ) :: self !< CLAsG data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signature = '' do a = 1 , self % Na signature = signature // self % cla ( a )% signature () enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature~2.html","title":"signature – FLAP"},{"text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. Source Code free Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_arguments_group members if ( allocated ( self % group )) deallocate ( self % group ) if ( allocated ( self % cla )) then call self % cla % free deallocate ( self % cla ) endif self % Na = 0_I4P self % Na_required = 0_I4P self % Na_optional = 0_I4P self % is_called = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~2.html","title":"free – FLAP"},{"text":"private subroutine check(self, pref) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check Source Code subroutine check ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! verify if CLAs switches are unique CLA_unique : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then do aa = 1 , self % Na if (( a /= aa ). and .(. not . self % cla ( aa )% is_positional )) then if (( self % cla ( a )% switch == self % cla ( aa )% switch ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch ). or .& ( self % cla ( a )% switch == self % cla ( aa )% switch_ab ). or .( self % cla ( a )% switch_ab == self % cla ( aa )% switch_ab )) then call self % errored ( pref = pref , error = ERROR_CONSISTENCY , a1 = a , a2 = aa ) exit CLA_unique endif endif enddo endif enddo CLA_unique ! update mutually exclusive relations CLA_exclude : do a = 1 , self % Na if (. not . self % cla ( a )% is_positional ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_defined ( switch = self % cla ( a )% m_exclude , pos = aa )) then self % cla ( aa )% m_exclude = self % cla ( a )% switch endif endif endif enddo CLA_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check~2.html","title":"check – FLAP"},{"text":"private subroutine is_required_passed(self, pref) Check if required CLAs are passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code is_required_passed Source Code subroutine is_required_passed ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if required CLAs are passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if (. not . self % cla ( a )% is_required_passed ( pref = pref )) then self % error = self % cla ( a )% error write ( self % usage_lun , '(A)' ) self % usage ( pref = pref ) return endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine is_required_passed","tags":"","loc":"proc/is_required_passed~2.html","title":"is_required_passed – FLAP"},{"text":"private subroutine raise_error_m_exclude(self, pref) Raise error mutually exclusive CLAs passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLA data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code raise_error_m_exclude Source Code subroutine raise_error_m_exclude ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Raise error mutually exclusive CLAs passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLA data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % errored ( pref = pref , error = ERROR_M_EXCLUDE ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine raise_error_m_exclude","tags":"","loc":"proc/raise_error_m_exclude~2.html","title":"raise_error_m_exclude – FLAP"},{"text":"private subroutine add(self, pref, cla) Add CLA to CLAs list. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. type( command_line_argument ), intent(in) :: cla CLA data. Source Code add Source Code subroutine add ( self , pref , cla ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLAs list. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. type ( command_line_argument ), intent ( in ) :: cla !< CLA data. type ( command_line_argument ), allocatable :: cla_list_new (:) !< New (extended) CLA list. integer ( I4P ) :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % Na > 0_I4P ) then if (. not . cla % is_positional ) then allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , self % Na cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( self % Na + 1 ) = cla else allocate ( cla_list_new ( 1 : self % Na + 1 )) do c = 1 , cla % position - 1 cla_list_new ( c ) = self % cla ( c ) enddo cla_list_new ( cla % position ) = cla do c = cla % position + 1 , self % Na + 1 cla_list_new ( c ) = self % cla ( c - 1 ) enddo endif else allocate ( cla_list_new ( 1 : 1 )) cla_list_new ( 1 ) = cla endif call move_alloc ( from = cla_list_new , to = self % cla ) self % Na = self % Na + 1 if ( cla % is_required ) then self % Na_required = self % Na_required + 1 else self % Na_optional = self % Na_optional + 1 endif if ( allocated ( cla_list_new )) deallocate ( cla_list_new ) call self % check ( pref = pref ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add","tags":"","loc":"proc/add.html","title":"add – FLAP"},{"text":"private subroutine parse(self, args, pref) Parse CLAsG arguments. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in) :: args (:) Command line arguments. character(len=*), intent(in), optional :: pref Prefixing string. Calls proc~~parse~~CallsGraph proc~parse parse interface~cton cton proc~parse->interface~cton proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parse Source Code subroutine parse ( self , args , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse CLAsG arguments. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), intent ( in ) :: args (:) !< Command line arguments. character ( 500 ) :: envvar !< Environment variables buffer. integer ( I4P ) :: arg !< Argument counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: aa !< Counter. integer ( I4P ) :: aaa !< Counter. integer ( I4P ) :: nargs !< Number of arguments consumed by a CLA. logical :: found !< Flag for checking if switch is a defined CLA. logical :: found_val !< Flag for checking if switch value is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then arg = 0 do while ( arg < size ( args , dim = 1 )) ! loop over CLAs group arguments passed arg = arg + 1 found = . false . do a = 1 , self % Na ! loop over CLAs group clas named options if (. not . self % cla ( a )% is_positional ) then if ( trim ( adjustl ( self % cla ( a )% switch )) == trim ( adjustl ( args ( arg ))). or .& trim ( adjustl ( self % cla ( a )% switch_ab )) == trim ( adjustl ( args ( arg )))) then found_val = . false . if ( self % cla ( a )% act == action_store ) then if ( allocated ( self % cla ( a )% envvar )) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! not found, try to take val from environment call get_environment_variable ( name = self % cla ( a )% envvar , value = envvar , status = aa ) if ( aa == 0 ) then self % cla ( a )% val = trim ( adjustl ( envvar )) found_val = . true . else ! flush default to val if environment is not set and default is set if ( allocated ( self % cla ( a )% def )) then self % cla ( a )% val = self % cla ( a )% def found_val = . true . endif endif endif elseif ( allocated ( self % cla ( a )% nargs )) then self % cla ( a )% val = '' select case ( self % cla ( a )% nargs ) case ( '+' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa elseif ( aaa == 0 ) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif case ( '*' ) aaa = 0 do aa = arg + 1 , size ( args , dim = 1 ) if (. not . self % is_defined ( switch = trim ( adjustl ( args ( aa ))))) then aaa = aa else exit endif enddo if ( aaa >= arg + 1 ) then do aa = aaa , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) found_val = . true . enddo arg = aaa endif case default nargs = cton ( str = trim ( adjustl ( self % cla ( a )% nargs )), knd = 1_I4P ) if ( arg + nargs > size ( args , dim = 1 )) then call self % cla ( a )% raise_error_nargs_insufficient ( pref = pref ) self % error = self % cla ( a )% error return endif do aa = arg + nargs , arg + 1 , - 1 ! decreasing loop due to gfortran bug self % cla ( a )% val = trim ( adjustl ( args ( aa ))) // args_sep // trim ( self % cla ( a )% val ) enddo found_val = . true . arg = arg + nargs endselect else if ( arg + 1 > size ( args )) then call self % cla ( a )% raise_error_value_missing ( pref = pref ) self % error = self % cla ( a )% error return endif arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found_val = . true . endif elseif ( self % cla ( a )% act == action_store_star ) then if ( arg + 1 <= size ( args , dim = 1 )) then ! verify if the value has been passed directly to cli ! there are still other arguments to check if (. not . self % is_defined ( switch = trim ( adjustl ( args ( arg + 1 ))))) then ! argument seem good... arg = arg + 1 self % cla ( a )% val = trim ( adjustl ( args ( arg ))) found = . true . found_val = . true . endif endif if (. not . found ) then ! flush default to val if default is set if ( allocated ( self % cla ( a )% def )) self % cla ( a )% val = self % cla ( a )% def endif elseif ( self % cla ( a )% act == action_print_help ) then self % error = STATUS_PRINT_H elseif ( self % cla ( a )% act == action_print_vers ) then self % error = STATUS_PRINT_V endif self % cla ( a )% is_passed = . true . found = . true . exit endif endif enddo if (. not . found ) then ! current argument (arg-th) does not correspond to a named option if (. not . self % cla ( arg )% is_positional ) then ! current argument (arg-th) is not positional... there is a problem! call self % cla ( arg )% raise_error_switch_unknown ( pref = pref , switch = trim ( adjustl ( args ( arg )))) self % error = self % cla ( arg )% error return else ! positional CLA always stores a value self % cla ( arg )% val = trim ( adjustl ( args ( arg ))) self % cla ( arg )% is_passed = . true . endif endif enddo call self % check_m_exclusive ( pref = pref ) call self % sanitize_defaults endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse.html","title":"parse – FLAP"},{"text":"private subroutine errored(self, error, pref, a1, a2) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(in), optional :: a1 First index CLAs group inconsistent. integer(kind=I4P), intent(in), optional :: a2 Second index CLAs group inconsistent. Calls proc~~errored~2~~CallsGraph proc~errored~2 errored interface~str str proc~errored~2->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code errored Source Code subroutine errored ( self , error , pref , a1 , a2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurrence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( in ) :: a1 !< First index CLAs group inconsistent. integer ( I4P ), optional , intent ( in ) :: a2 !< Second index CLAs group inconsistent. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select case ( self % error ) case ( ERROR_CONSISTENCY ) if ( self % group /= '' ) then self % error_message = prefd // self % progname // ': error: group (command) name: \"' // self % group // '\" consistency error:' else self % error_message = prefd // self % progname // ': error: consistency error:' endif self % error_message = self % error_message // ' \"' // trim ( str ( a1 , . true .)) // & '-th\" option has the same switch or abbreviated switch of \"' // trim ( str ( a2 , . true .)) // '-th\" option:' // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a1 , . true .)) // ') switches = ' // self % cla ( a1 )% switch // ' ' // & self % cla ( a1 )% switch_ab // new_line ( 'a' ) self % error_message = self % error_message // prefd // ' CLA(' // trim ( str ( a2 , . true .)) // ') switches = ' // self % cla ( a2 )% switch // ' ' // & self % cla ( a2 )% switch_ab case ( ERROR_M_EXCLUDE ) self % error_message = prefd // self % progname // ': error: the group \"' // self % group // '\" and \"' // self % m_exclude // '\" are mutually' // & ' exclusive, but both have been called!' endselect call self % print_error_message endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored","tags":"","loc":"proc/errored~2.html","title":"errored – FLAP"},{"text":"private subroutine check_m_exclusive(self, pref) Check if two mutually exclusive CLAs have been passed. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_m_exclusive Source Code subroutine check_m_exclusive ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs have been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na if ( self % cla ( a )% is_passed ) then if ( self % cla ( a )% m_exclude /= '' ) then if ( self % is_passed ( switch = self % cla ( a )% m_exclude )) then call self % cla ( a )% raise_error_m_exclude ( pref = pref ) self % error = self % cla ( a )% error return endif endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive.html","title":"check_m_exclusive – FLAP"},{"text":"private subroutine sanitize_defaults(self) Sanitize defaults values. It is necessary to sanitize the default values of non-passed, optional CLAs. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: self CLAsG data. Source Code sanitize_defaults Source Code subroutine sanitize_defaults ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sanitize defaults values. !< !< It is necessary to *sanitize* the default values of non-passed, optional CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_called ) then do a = 1 , self % Na call self % cla ( a )% sanitize_defaults enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine sanitize_defaults","tags":"","loc":"proc/sanitize_defaults~2.html","title":"sanitize_defaults – FLAP"},{"text":"private elemental subroutine clasg_assign_clasg(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_arguments_group ), intent(inout) :: lhs Left hand side. type( command_line_arguments_group ), intent(in) :: rhs Right hand side. Source Code clasg_assign_clasg Source Code elemental subroutine clasg_assign_clasg ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_arguments_group ), intent ( INOUT ) :: lhs !< Left hand side. type ( command_line_arguments_group ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_arguments_group members if ( allocated ( rhs % group )) lhs % group = rhs % group if ( allocated ( rhs % cla )) then if ( allocated ( lhs % cla )) deallocate ( lhs % cla ) ; allocate ( lhs % cla ( 1 : size ( rhs % cla , dim = 1 )), source = rhs % cla ) endif lhs % Na = rhs % Na lhs % Na_required = rhs % Na_required lhs % Na_optional = rhs % Na_optional lhs % is_called = rhs % is_called return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine clasg_assign_clasg","tags":"","loc":"proc/clasg_assign_clasg.html","title":"clasg_assign_clasg – FLAP"},{"text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_arguments_group ), intent(inout) :: self CLAsG data. Source Code finalize Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_arguments_group ), intent ( inout ) :: self !< CLAsG data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize – FLAP"},{"text":"private function is_passed(self, group, switch, position) Check if a CLA has been passed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. Return Value logical Check if a CLA has been passed. Source Code is_passed Source Code function is_passed ( self , group , switch , position ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been passed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical :: is_passed !< Check if a CLA has been passed. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_passed = . false . if (. not . present ( group )) then if ( present ( switch )) then is_passed = self % clasg ( 0 )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( 0 )% is_passed ( position = position ) endif else if ( self % is_defined_group ( group = group , g = g )) then if ( present ( switch )) then is_passed = self % clasg ( g )% is_passed ( switch = switch ) elseif ( present ( position )) then is_passed = self % clasg ( g )% is_passed ( position = position ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_passed","tags":"","loc":"proc/is_passed~2.html","title":"is_passed – FLAP"},{"text":"private function is_defined_group(self, group, g) result(defined) Check if a CLAs group has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. integer(kind=I4P), intent(out), optional :: g Index of group. Return Value logical Check if a CLAs group has been defined. Source Code is_defined_group Source Code function is_defined_group ( self , group , g ) result ( defined ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. integer ( I4P ), optional , intent ( out ) :: g !< Index of group. logical :: defined !< Check if a CLAs group has been defined. integer ( I4P ) :: gg !< Counter. integer ( I4P ) :: ggg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- defined = . false . do gg = 0 , size ( self % clasg , dim = 1 ) - 1 ggg = gg if ( allocated ( self % clasg ( gg )% group )) defined = ( self % clasg ( gg )% group == group ) if ( defined ) exit enddo if ( present ( g )) g = ggg return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined_group","tags":"","loc":"proc/is_defined_group.html","title":"is_defined_group – FLAP"},{"text":"private function is_called_group(self, group) result(called) Check if a CLAs group has been run. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: group Name of group (command) of CLAs. Return Value logical Check if a CLAs group has been runned. Source Code is_called_group Source Code function is_called_group ( self , group ) result ( called ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLAs group has been run. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: group !< Name of group (command) of CLAs. logical :: called !< Check if a CLAs group has been runned. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- called = . false . if ( self % is_defined_group ( group = group , g = g )) called = self % clasg ( g )% is_called return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_called_group","tags":"","loc":"proc/is_called_group.html","title":"is_called_group – FLAP"},{"text":"private function is_defined(self, switch, group) Check if a CLA has been defined. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: switch Switch name. character(len=*), intent(in), optional :: group Name of group (command) of CLAs. Return Value logical Check if a CLA has been defined. Source Code is_defined Source Code function is_defined ( self , switch , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if a CLA has been defined. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLAs. logical :: is_defined !< Check if a CLA has been defined. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_defined = . false . if (. not . present ( group )) then is_defined = self % clasg ( 0 )% is_defined ( switch = switch ) else if ( self % is_defined_group ( group = group , g = g )) is_defined = self % clasg ( g )% is_defined ( switch = switch ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_defined","tags":"","loc":"proc/is_defined~2.html","title":"is_defined – FLAP"},{"text":"private elemental function is_parsed(self) Check if CLI has been parsed. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value logical Parsed status. Source Code is_parsed Source Code elemental function is_parsed ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if CLI has been parsed. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. logical :: is_parsed !< Parsed status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_parsed = self % is_parsed_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_parsed","tags":"","loc":"proc/is_parsed.html","title":"is_parsed – FLAP"},{"text":"private function usage(self, g, pref, no_header, no_examples, no_epilog, markdown) result(usaged) Print correct usage of CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. integer(kind=I4P), intent(in) :: g Group index. character(len=*), intent(in), optional :: pref Prefixing string. logical, intent(in), optional :: no_header Avoid insert header to usage. logical, intent(in), optional :: no_examples Avoid insert examples to usage. logical, intent(in), optional :: no_epilog Avoid insert epilogue to usage. logical, intent(in), optional :: markdown Format things with markdown Return Value character(len=:),\n  allocatable Usage string. Source Code usage Source Code function usage ( self , g , pref , no_header , no_examples , no_epilog , markdown ) result ( usaged ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage of CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. integer ( I4P ), intent ( in ) :: g !< Group index. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. logical , optional , intent ( in ) :: no_header !< Avoid insert header to usage. logical , optional , intent ( in ) :: no_examples !< Avoid insert examples to usage. logical , optional , intent ( in ) :: no_epilog !< Avoid insert epilogue to usage. logical , optional , intent ( in ) :: markdown !< Format things with markdown character ( len = :), allocatable :: prefd !< Prefixing string. character ( len = :), allocatable :: usaged !< Usage string. logical :: no_headerd !< Avoid insert header to usage. logical :: no_examplesd !< Avoid insert examples to usage. logical :: no_epilogd !< Avoid insert epilogue to usage. logical :: markdownd !< Format for markdown. integer ( I4P ) :: gi !< Counter. integer ( I4P ) :: e !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- no_headerd = . false . ; if ( present ( no_header )) no_headerd = no_header no_examplesd = . false . ; if ( present ( no_examples )) no_examplesd = no_examples no_epilogd = . false . ; if ( present ( no_epilog )) no_epilogd = no_epilog markdownd = . false . ; if ( present ( markdown )) markdownd = markdown prefd = '' ; if ( present ( pref )) prefd = pref if ( g > 0 ) then ! usage of a specific command usaged = self % clasg ( g )% usage ( pref = prefd , no_header = no_headerd , markdown = markdownd ) else ! usage of whole CLI if ( no_headerd ) then usaged = '' else usaged = prefd // self % help // self % progname // ' ' // self % signature () if ( self % description /= '' ) usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // self % description endif if ( self % clasg ( 0 )% Na > 0 ) usaged = usaged // new_line ( 'a' ) // self % clasg ( 0 )% usage ( pref = prefd , no_header = . true ., markdown = markdownd ) if ( size ( self % clasg , dim = 1 ) > 1 ) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Commands:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % clasg ( gi )% group usaged = usaged // new_line ( 'a' ) // prefd // repeat ( ' ' , 10 ) // self % clasg ( gi )% description enddo usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'For more detailed commands help try:' do gi = 1 , size ( self % clasg , dim = 1 ) - 1 usaged = usaged // new_line ( 'a' ) // prefd // '  ' // self % progname // ' ' // self % clasg ( gi )% group // ' -h,--help' enddo endif endif if ( allocated ( self % examples ). and .(. not . no_examplesd )) then usaged = usaged // new_line ( 'a' ) // new_line ( 'a' ) // prefd // 'Examples:' do e = 1 , size ( self % examples , dim = 1 ) usaged = usaged // new_line ( 'a' ) // prefd // '   ' // trim ( self % examples ( e )) enddo endif if ( self % epilog /= '' . and .(. not . no_epilogd )) usaged = usaged // new_line ( 'a' ) // prefd // self % epilog return !--------------------------------------------------------------------------------------------------------------------------------- endfunction usage","tags":"","loc":"proc/usage~3.html","title":"usage – FLAP"},{"text":"private function signature(self) Get signature. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. Return Value character(len=:),\n  allocatable Signature. Source Code signature Source Code function signature ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get signature. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( len = :), allocatable :: signature !< Signature. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- signature = self % clasg ( 0 )% signature () if ( size ( self % clasg , dim = 1 ) > 1 ) then signature = signature // ' {' // self % clasg ( 1 )% group do g = 2 , size ( self % clasg , dim = 1 ) - 1 signature = signature // ',' // self % clasg ( g )% group enddo signature = signature // '} ...' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction signature","tags":"","loc":"proc/signature~3.html","title":"signature – FLAP"},{"text":"private elemental subroutine free(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. Source Code free Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call self % free_object ! command_line_interface members if ( allocated ( self % clasg )) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 call self % clasg ( g )% free enddo deallocate ( self % clasg ) endif if ( allocated ( self % examples )) deallocate ( self % examples ) self % disable_hv = . false . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~3.html","title":"free – FLAP"},{"text":"private subroutine init(self, progname, version, help, description, license, authors, examples, epilog, disable_hv, usage_lun, error_lun, version_lun) Initialize CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: progname Program name. character(len=*), intent(in), optional :: version Program version. character(len=*), intent(in), optional :: help Help message introducing the CLI usage. character(len=*), intent(in), optional :: description Detailed description message introducing the program. character(len=*), intent(in), optional :: license License description. character(len=*), intent(in), optional :: authors Authors list. character(len=*), intent(in), optional :: examples (1:) Examples of correct usage. character(len=*), intent(in), optional :: epilog Epilog message. logical, intent(in), optional :: disable_hv Disable automatic insert of 'help' and 'version' CLAs. integer(kind=I4P), intent(in), optional :: usage_lun Unit number to print usage/help integer(kind=I4P), intent(in), optional :: error_lun Unit number to print error info integer(kind=I4P), intent(in), optional :: version_lun Unit number to print version/license info Source Code init Source Code subroutine init ( self , progname , version , help , description , license , authors , examples , epilog , disable_hv , & usage_lun , error_lun , version_lun ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: progname !< Program name. character ( * ), optional , intent ( in ) :: version !< Program version. character ( * ), optional , intent ( in ) :: help !< Help message introducing the CLI usage. character ( * ), optional , intent ( in ) :: description !< Detailed description message introducing the program. character ( * ), optional , intent ( in ) :: license !< License description. character ( * ), optional , intent ( in ) :: authors !< Authors list. character ( * ), optional , intent ( in ) :: examples ( 1 :) !< Examples of correct usage. character ( * ), optional , intent ( in ) :: epilog !< Epilog message. logical , optional , intent ( in ) :: disable_hv !< Disable automatic insert of 'help' and 'version' CLAs. integer ( I4P ), optional , intent ( in ) :: usage_lun !< Unit number to print usage/help integer ( I4P ), optional , intent ( in ) :: version_lun !< Unit number to print version/license info integer ( I4P ), optional , intent ( in ) :: error_lun !< Unit number to print error info character ( len = :), allocatable :: prog_invocation !< Complete program invocation. integer ( I4P ) :: invocation_length !< Length of invocation. integer ( I4P ) :: retrieval_status !< Retrieval status. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free if ( present ( usage_lun )) self % usage_lun = usage_lun if ( present ( version_lun )) self % version_lun = version_lun if ( present ( error_lun )) self % error_lun = error_lun if ( present ( progname )) then self % progname = progname else ! try to set the default progname to the 0th command line entry a-la unix $0 call get_command_argument ( 0 , length = invocation_length ) allocate ( character ( len = invocation_length ) :: prog_invocation ) call get_command_argument ( 0 , value = prog_invocation , status = retrieval_status ) if ( retrieval_status == 0 ) then self % progname = prog_invocation else self % progname = 'program' endif endif self % version = 'unknown' ; if ( present ( version )) self % version = version self % help = 'usage: ' ; if ( present ( help )) self % help = help self % description = '' ; if ( present ( description )) self % description = description self % license = '' ; if ( present ( license )) self % license = license self % authors = '' ; if ( present ( authors )) self % authors = authors self % epilog = '' ; if ( present ( epilog )) self % epilog = epilog if ( present ( disable_hv )) self % disable_hv = disable_hv if ( present ( examples )) then #ifdef __GFORTRAN__ allocate ( self % examples ( 1 : size ( examples ))) #else allocate ( character ( len = len ( examples ( 1 ))) :: self % examples ( 1 : size ( examples ))) ! does not work with gfortran 4.9.2 #endif self % examples = examples endif ! initialize only the first default group allocate ( self % clasg ( 0 : 0 )) call self % clasg ( 0 )% assign_object ( self ) self % clasg ( 0 )% group = '' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FLAP"},{"text":"private subroutine add_group(self, help, description, exclude, group) Add CLAs group to CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: help Help message. character(len=*), intent(in), optional :: description Detailed description. character(len=*), intent(in), optional :: exclude Group name of the mutually exclusive group. character(len=*), intent(in) :: group Name of the grouped CLAs. Source Code add_group Source Code subroutine add_group ( self , help , description , exclude , group ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLAs group to CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: help !< Help message. character ( * ), optional , intent ( in ) :: description !< Detailed description. character ( * ), optional , intent ( in ) :: exclude !< Group name of the mutually exclusive group. character ( * ), intent ( in ) :: group !< Name of the grouped CLAs. type ( command_line_arguments_group ), allocatable :: clasg_list_new (:) !< New (extended) CLAs group list. character ( len = :), allocatable :: helpd !< Help message. character ( len = :), allocatable :: descriptiond !< Detailed description. character ( len = :), allocatable :: excluded !< Group name of the mutually exclusive group. integer ( I4P ) :: Ng !< Number of groups. integer ( I4P ) :: gi !< Group index !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_defined_group ( group = group )) then helpd = 'usage: ' ; if ( present ( help )) helpd = help descriptiond = '' ; if ( present ( description )) descriptiond = description excluded = '' ; if ( present ( exclude )) excluded = exclude Ng = size ( self % clasg , dim = 1 ) allocate ( clasg_list_new ( 0 : Ng )) !    clasg_list_new(0:Ng-1) = self%clasg(0:Ng-1) ! Not working on Intel Fortran 15.0.2 do gi = 0 , Ng - 1 clasg_list_new ( gi ) = self % clasg ( gi ) enddo call clasg_list_new ( Ng )% assign_object ( self ) clasg_list_new ( Ng )% help = helpd clasg_list_new ( Ng )% description = descriptiond clasg_list_new ( Ng )% group = group clasg_list_new ( Ng )% m_exclude = excluded deallocate ( self % clasg ) allocate ( self % clasg ( 0 : Ng )) self % clasg = clasg_list_new deallocate ( clasg_list_new ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_group","tags":"","loc":"proc/add_group.html","title":"add_group – FLAP"},{"text":"private subroutine set_mutually_exclusive_groups(self, group1, group2) Set two CLAs group ad mutually exclusive. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: group1 Name of the first grouped CLAs. character(len=*), intent(in) :: group2 Name of the second grouped CLAs. Source Code set_mutually_exclusive_groups Source Code subroutine set_mutually_exclusive_groups ( self , group1 , group2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set two CLAs group ad mutually exclusive. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: group1 !< Name of the first grouped CLAs. character ( * ), intent ( in ) :: group2 !< Name of the second grouped CLAs. integer ( I4P ) :: g1 !< Counter. integer ( I4P ) :: g2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_defined_group ( group = group1 , g = g1 ). and . self % is_defined_group ( group = group2 , g = g2 )) then self % clasg ( g1 )% m_exclude = group2 self % clasg ( g2 )% m_exclude = group1 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_mutually_exclusive_groups","tags":"","loc":"proc/set_mutually_exclusive_groups.html","title":"set_mutually_exclusive_groups – FLAP"},{"text":"private subroutine add(self, pref, group, group_index, switch, switch_ab, help, help_markdown, required, positional, position, hidden, act, def, nargs, choices, exclude, envvar, error) Add CLA to CLI. Note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name\n or directly passed in case of positional CLA. Note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. Note If CLA belongs to a not yet present group it is created on the fly. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Name of the grouped CLAs. integer(kind=I4P), intent(in), optional :: group_index Index of the grouped CLAs. character(len=*), intent(in), optional :: switch Switch name. character(len=*), intent(in), optional :: switch_ab Abbreviated switch name. character(len=*), intent(in), optional :: help Help message describing the CLA. character(len=*), intent(in), optional :: help_markdown Longer help message, markdown formatted. logical, intent(in), optional :: required Flag for set required argument. logical, intent(in), optional :: positional Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. logical, intent(in), optional :: hidden Flag for hiding CLA, thus it does not compare into help. character(len=*), intent(in), optional :: act CLA value action. character(len=*), intent(in), optional :: def Default value. character(len=*), intent(in), optional :: nargs Number of arguments consumed by CLA. character(len=*), intent(in), optional :: choices List of allowable values for the argument. character(len=*), intent(in), optional :: exclude Switch name of the mutually exclusive CLA. character(len=*), intent(in), optional :: envvar Environment variable from which take value. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Calls proc~~add~2~~CallsGraph proc~add~2 add proc~upper_case upper_case proc~add~2->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code add Source Code subroutine add ( self , pref , group , group_index , switch , switch_ab , help , help_markdown , required , & positional , position , hidden , act , def , nargs , choices , exclude , envvar , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add CLA to CLI. !< !< @note If not otherwise declared the action on CLA value is set to \"store\" a value that must be passed after the switch name !< or directly passed in case of positional CLA. !< !< @note If not otherwise speficied the CLA belongs to the default group \"zero\" that is the group of non-grouped CLAs. !< !< @note If CLA belongs to a not yet present group it is created on the fly. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Name of the grouped CLAs. integer ( I4P ), optional , intent ( in ) :: group_index !< Index of the grouped CLAs. character ( * ), optional , intent ( in ) :: switch !< Switch name. character ( * ), optional , intent ( in ) :: switch_ab !< Abbreviated switch name. character ( * ), optional , intent ( in ) :: help !< Help message describing the CLA. character ( * ), optional , intent ( in ) :: help_markdown !< Longer help message, markdown formatted. logical , optional , intent ( in ) :: required !< Flag for set required argument. logical , optional , intent ( in ) :: positional !< Flag for checking if CLA is a positional or a named CLA. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. logical , optional , intent ( in ) :: hidden !< Flag for hiding CLA, thus it does not compare into help. character ( * ), optional , intent ( in ) :: act !< CLA value action. character ( * ), optional , intent ( in ) :: def !< Default value. character ( * ), optional , intent ( in ) :: nargs !< Number of arguments consumed by CLA. character ( * ), optional , intent ( in ) :: choices !< List of allowable values for the argument. character ( * ), optional , intent ( in ) :: exclude !< Switch name of the mutually exclusive CLA. character ( * ), optional , intent ( in ) :: envvar !< Environment variable from which take value. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. type ( command_line_argument ) :: cla !< CLA data. integer ( I4P ) :: g !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialize CLA call cla % assign_object ( self ) if ( present ( switch )) then cla % switch = switch cla % switch_ab = switch else if ( present ( switch_ab )) then cla % switch = switch_ab cla % switch_ab = switch_ab endif endif if ( present ( switch_ab )) cla % switch_ab = switch_ab cla % help = 'Undocumented argument' ; if ( present ( help )) cla % help = help cla % help_markdown = '' ; if ( present ( help_markdown )) cla % help_markdown = help_markdown cla % is_required = . false . ; if ( present ( required )) cla % is_required = required cla % is_positional = . false . ; if ( present ( positional )) cla % is_positional = positional cla % position = 0_I4P ; if ( present ( position )) cla % position = position cla % is_hidden = . false . ; if ( present ( hidden )) cla % is_hidden = hidden cla % act = action_store ; if ( present ( act )) cla % act = trim ( adjustl ( Upper_Case ( act ))) if ( present ( def )) cla % def = def if ( present ( def )) cla % val = def if ( present ( nargs )) cla % nargs = nargs if ( present ( choices )) cla % choices = choices cla % m_exclude = '' ; if ( present ( exclude )) cla % m_exclude = exclude if ( present ( envvar )) cla % envvar = envvar call cla % check ( pref = pref ) ; self % error = cla % error if ( self % error /= 0 ) then if ( present ( error )) error = self % error return endif ! add CLA to CLI if ((. not . present ( group )). and .(. not . present ( group_index ))) then call self % clasg ( 0 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( 0 )% error elseif ( present ( group )) then if ( self % is_defined_group ( group = group , g = g )) then call self % clasg ( g )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( g )% error else call self % add_group ( group = group ) call self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( size ( self % clasg , dim = 1 ) - 1 )% error endif elseif ( present ( group_index )) then if ( group_index <= size ( self % clasg , dim = 1 ) - 1 ) then call self % clasg ( group_index )% add ( pref = pref , cla = cla ) ; self % error = self % clasg ( group_index )% error endif endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add","tags":"","loc":"proc/add~2.html","title":"add – FLAP"},{"text":"private subroutine check(self, pref, error) Check data consistency. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code check Source Code subroutine check ( self , pref , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check data consistency. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( INOUT ) :: self !< CLI data. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 0 , size ( self % clasg , dim = 1 ) - 1 ! check group consistency call self % clasg ( g )% check ( pref = pref ) self % error = self % clasg ( g )% error if ( present ( error )) error = self % error if ( self % error /= 0 ) exit ! check mutually exclusive interaction if ( g > 0 ) then if ( self % clasg ( g )% m_exclude /= '' ) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) self % clasg ( gg )% m_exclude = self % clasg ( g )% group endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check","tags":"","loc":"proc/check~3.html","title":"check – FLAP"},{"text":"private subroutine check_m_exclusive(self, pref) Check if two mutually exclusive CLAs group have been called. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code check_m_exclusive Source Code subroutine check_m_exclusive ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check if two mutually exclusive CLAs group have been called. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ) :: g !< Counter. integer ( I4P ) :: gg !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do g = 1 , size ( self % clasg , dim = 1 ) - 1 if ( self % clasg ( g )% is_called . and .( self % clasg ( g )% m_exclude /= '' )) then if ( self % is_defined_group ( group = self % clasg ( g )% m_exclude , g = gg )) then if ( self % clasg ( gg )% is_called ) then call self % clasg ( g )% raise_error_m_exclude ( pref = pref ) self % error = self % clasg ( g )% error exit endif endif endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_m_exclusive","tags":"","loc":"proc/check_m_exclusive~2.html","title":"check_m_exclusive – FLAP"},{"text":"private subroutine parse(self, pref, args, error) Parse Command Line Interfaces by means of a previously initialized CLAs groups list. Note The leading and trailing white spaces are removed from CLA values. Note If the args argument is passed the command line arguments are taken from it and not from the actual program CLI\n invocations. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code parse Source Code subroutine parse ( self , pref , args , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse Command Line Interfaces by means of a previously initialized CLAs groups list. !< !< @note The leading and trailing white spaces are removed from CLA values. !< !< @note If the *args* argument is passed the command line arguments are taken from it and not from the actual program CLI !< invocations. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. integer ( I4P ) :: g !< Counter for CLAs group. integer ( I4P ), allocatable :: ai (:,:) !< Counter for CLAs grouped. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % is_parsed_ ) return ! add help and version switches if not done by user if (. not . self % disable_hv ) then do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--help' ). and .& self % is_defined ( group = self % clasg ( g )% group , switch = '-h' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--help' , & switch_ab = '-h' , & help = 'Print this help message' , & required = . false ., & def = '' , & act = 'print_help' ) if (. not .( self % is_defined ( group = self % clasg ( g )% group , switch = '--version' ). and . & self % is_defined ( group = self % clasg ( g )% group , switch = '-v' ))) & call self % add ( pref = pref , & group_index = g , & switch = '--version' , & switch_ab = '-v' , & help = 'Print version' , & required = . false ., & def = '' , & act = 'print_version' ) enddo endif ! add hidden CLA '--' for getting the rid of eventual trailing CLAs garbage do g = 0 , size ( self % clasg , dim = 1 ) - 1 if (. not . self % is_defined ( group = self % clasg ( g )% group , switch = '--' )) & call self % add ( pref = pref , & group_index = g , & switch = '--' , & required = . false ., & hidden = . true ., & nargs = '*' , & def = '' , & act = 'store' ) enddo ! parse passed CLAs grouping in indexes if ( present ( args )) then call self % get_args ( args = args , ai = ai ) else call self % get_args ( ai = ai ) endif ! check CLI consistency call self % check ( pref = pref ) if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! parse CLI do g = 0 , size ( ai , dim = 1 ) - 1 if ( ai ( g , 1 ) > 0 ) then call self % clasg ( g )% parse ( args = self % args ( ai ( g , 1 ): ai ( g , 2 )), pref = pref ) else call self % clasg ( g )% sanitize_defaults endif self % error = self % clasg ( g )% error if ( self % error /= 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! trap the special cases of version/help printing if ( self % error == STATUS_PRINT_V ) then call self % print_version ( pref = pref ) stop elseif ( self % error == STATUS_PRINT_H ) then write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = g ) stop endif ! check if all required CLAs have been passed do g = 0 , size ( ai , dim = 1 ) - 1 call self % clasg ( g )% is_required_passed ( pref = pref ) self % error = self % clasg ( g )% error if ( self % error > 0 ) exit enddo if ( self % error > 0 ) then if ( present ( error )) error = self % error return endif ! check mutually exclusive interaction call self % check_m_exclusive ( pref = pref ) self % is_parsed_ = . true . if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse~2.html","title":"parse – FLAP"},{"text":"private subroutine get_clasg_indexes(self, ai) Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Source Code get_clasg_indexes Source Code subroutine get_clasg_indexes ( self , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the argument indexes of CLAs groups defined parsing the actual passed CLAs. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. integer ( I4P ) :: g !< Counter for CLAs group. logical :: found !< Flag for inquiring if a named group is found. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( ai ( 0 : size ( self % clasg , dim = 1 ) - 1 , 1 : 2 )) ai = 0 if ( allocated ( self % args )) then Na = size ( self % args , dim = 1 ) a = 0 found = . false . search_named : do while ( a < Na ) a = a + 1 if ( self % is_defined_group ( group = trim ( self % args ( a )), g = g )) then found = . true . self % clasg ( g )% is_called = . true . ai ( g , 1 ) = a + 1 aa = a do while ( aa < Na ) aa = aa + 1 if ( self % is_defined_group ( group = trim ( self % args ( aa )))) then a = aa - 1 ai ( g , 2 ) = a exit else ai ( g , 2 ) = aa endif enddo elseif (. not . found ) then ai ( 0 , 2 ) = a endif enddo search_named if ( ai ( 0 , 2 ) > 0 ) then ai ( 0 , 1 ) = 1 self % clasg ( 0 )% is_called = . true . elseif ( all ( ai == 0 )) then self % clasg ( 0 )% is_called = . true . endif else self % clasg ( 0 )% is_called = . true . endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_clasg_indexes","tags":"","loc":"proc/get_clasg_indexes.html","title":"get_clasg_indexes – FLAP"},{"text":"private subroutine get_args_from_string(self, args, ai) Get CLAs from string. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(in) :: args String containing command line arguments. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Calls proc~~get_args_from_string~~CallsGraph proc~get_args_from_string get_args_from_string proc~tokenize tokenize proc~get_args_from_string->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_args_from_string Source Code subroutine get_args_from_string ( self , args , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), intent ( in ) :: args !< String containing command line arguments. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. character ( len = len_trim ( args )) :: argsd !< Dummy string containing command line arguments. character ( len = len_trim ( args )), allocatable :: toks (:) !< CLAs tokenized. integer ( I4P ) :: Nt !< Number of tokens. integer ( I4P ) :: Na !< Number of command line arguments passed. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: t !< Counter for tokens. integer ( I4P ) :: c !< Counter for characters inside tokens. #ifndef __GFORTRAN__ integer ( I4P ) :: length !< Maxium lenght of arguments string. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! prepare CLI arguments list if ( allocated ( self % args )) deallocate ( self % args ) ! sanitize arguments string argsd = trim ( args ) if ( index ( args , \"'\" ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = \"'\" ) elseif ( index ( args , '\"' ) > 0 ) then argsd = sanitize_args ( argsin = argsd , delimiter = '\"' ) endif ! tokenize arguments string; the previously sanitized white spaces inside tokens are restored call tokenize ( strin = argsd , delimiter = ' ' , toks = toks , Nt = Nt ) Na = 0 find_number_of_valid_arguments : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then Na = Na + 1 do c = 1 , len ( toks ( t )) if ( toks ( t )( c : c ) == \"'\" ) toks ( t )( c : c ) = \" \" enddo endif enddo find_number_of_valid_arguments if ( Na > 0 ) then ! allocate CLI arguments list #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else length = 0 find_longest_arg : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) length = max ( length , len_trim ( adjustl ( toks ( t )))) enddo find_longest_arg allocate ( character ( length ) :: self % args ( 1 : Na )) #endif ! construct arguments list a = 0 get_args : do t = 1 , Nt if ( trim ( adjustl ( toks ( t ))) /= '' ) then a = a + 1 self % args ( a ) = trim ( adjustl ( toks ( t ))) endif enddo get_args endif call self % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- contains function sanitize_args ( argsin , delimiter ) result ( sanitized ) !------------------------------------------------------------------------------------------------------------------------------- !< Sanitize arguments string. !< !< Substitute white spaces enclosed into string-arguments, i.e. 'string argument with spaces...' or !< \"string argument with spaces...\" with a safe equivalent for tokenization against white spaces, i.e. the finally tokenized !< string is string'argument'with'spaces... !< !< @note The white spaces are reintroduce later. !------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: argsin !< Arguments string. character ( * ), intent ( in ) :: delimiter !< Delimiter enclosing string argument. character ( len = len_trim ( argsin )) :: sanitized !< Arguments string sanitized. character ( len = len_trim ( argsin )), allocatable :: tok (:) !< Arguments string tokens. integer ( I4P ) :: Nt !< Number of command line arguments passed. integer ( I4P ) :: t !< Counter. integer ( I4P ) :: tt !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- call tokenize ( strin = trim ( argsin ), delimiter = delimiter , toks = tok , Nt = Nt ) do t = 2 , Nt , 2 do tt = 1 , len_trim ( adjustl ( tok ( t ))) if ( tok ( t )( tt : tt ) == ' ' ) tok ( t )( tt : tt ) = \"'\" enddo enddo sanitized = '' do t = 1 , Nt sanitized = trim ( sanitized ) // \" \" // trim ( adjustl ( tok ( t ))) enddo sanitized = trim ( adjustl ( sanitized )) return !------------------------------------------------------------------------------------------------------------------------------- endfunction sanitize_args endsubroutine get_args_from_string","tags":"","loc":"proc/get_args_from_string.html","title":"get_args_from_string – FLAP"},{"text":"private subroutine get_args_from_invocation(self, ai) Get CLAs from CLI invocation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: ai (:,:) CLAs grouped indexes. Source Code get_args_from_invocation Source Code subroutine get_args_from_invocation ( self , ai ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLAs from CLI invocation. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: ai (:,:) !< CLAs grouped indexes. integer ( I4P ) :: Na !< Number of command line arguments passed. character ( max_val_len ) :: switch !< Switch name. integer ( I4P ) :: a !< Counter for CLAs. integer ( I4P ) :: aa !< Counter for CLAs. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % args )) deallocate ( self % args ) Na = command_argument_count () if ( Na > 0 ) then #ifdef __GFORTRAN__ allocate ( self % args ( 1 : Na )) #else aa = 0 find_longest_arg : do a = 1 , Na call get_command_argument ( a , switch ) aa = max ( aa , len_trim ( switch )) enddo find_longest_arg allocate ( character ( aa ) :: self % args ( 1 : Na )) #endif get_args : do a = 1 , Na call get_command_argument ( a , switch ) self % args ( a ) = trim ( adjustl ( switch )) enddo get_args endif call self % get_clasg_indexes ( ai = ai ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_args_from_invocation","tags":"","loc":"proc/get_args_from_invocation.html","title":"get_args_from_invocation – FLAP"},{"text":"private subroutine get_cla(self, val, pref, args, group, switch, position, error) Get CLA (single) value from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val CLA value. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla Source Code subroutine get_cla ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA (single) value from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val !< CLA value. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( self % error == 0. and . self % clasg ( g )% is_called ) then if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( position )% error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla","tags":"","loc":"proc/get_cla~2.html","title":"get_cla – FLAP"},{"text":"private subroutine get_cla_list(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. class(*), intent(inout) :: val (1:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list Source Code subroutine get_cla_list ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. class ( * ), intent ( inout ) :: val ( 1 :) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list","tags":"","loc":"proc/get_cla_list~2.html","title":"get_cla_list – FLAP"},{"text":"private subroutine get_cla_list_varying_R16P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R16P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_R16P Source Code subroutine get_cla_list_varying_R16P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R16P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R16P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R16P","tags":"","loc":"proc/get_cla_list_varying_r16p~2.html","title":"get_cla_list_varying_R16P – FLAP"},{"text":"private subroutine get_cla_list_varying_R8P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_R8P Source Code subroutine get_cla_list_varying_R8P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R8P","tags":"","loc":"proc/get_cla_list_varying_r8p~2.html","title":"get_cla_list_varying_R8P – FLAP"},{"text":"private subroutine get_cla_list_varying_R4P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. real(kind=R4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_R4P Source Code subroutine get_cla_list_varying_R4P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, real(R4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. real ( R4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_R4P","tags":"","loc":"proc/get_cla_list_varying_r4p~2.html","title":"get_cla_list_varying_R4P – FLAP"},{"text":"private subroutine get_cla_list_varying_I8P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I8P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I8P Source Code subroutine get_cla_list_varying_I8P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I8P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I8P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I8P","tags":"","loc":"proc/get_cla_list_varying_i8p~2.html","title":"get_cla_list_varying_I8P – FLAP"},{"text":"private subroutine get_cla_list_varying_I4P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I4P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I4P Source Code subroutine get_cla_list_varying_I4P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I4P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I4P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I4P","tags":"","loc":"proc/get_cla_list_varying_i4p~2.html","title":"get_cla_list_varying_I4P – FLAP"},{"text":"private subroutine get_cla_list_varying_I2P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I2P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I2P Source Code subroutine get_cla_list_varying_I2P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I2P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I2P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I2P","tags":"","loc":"proc/get_cla_list_varying_i2p~2.html","title":"get_cla_list_varying_I2P – FLAP"},{"text":"private subroutine get_cla_list_varying_I1P(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. integer(kind=I1P), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_I1P Source Code subroutine get_cla_list_varying_I1P ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, integer(I1P). !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. integer ( I1P ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_I1P","tags":"","loc":"proc/get_cla_list_varying_i1p~2.html","title":"get_cla_list_varying_I1P – FLAP"},{"text":"private subroutine get_cla_list_varying_logical(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, logical. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. logical, intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_logical Source Code subroutine get_cla_list_varying_logical ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, logical. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. logical , allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_logical","tags":"","loc":"proc/get_cla_list_varying_logical~2.html","title":"get_cla_list_varying_logical – FLAP"},{"text":"private subroutine get_cla_list_varying_char(self, val, pref, args, group, switch, position, error) Get CLA multiple values from CLAs list parsed with varying size list, character. Note The CLA list is returned deallocated if values are not correctly gotten. Note For logical type CLA the value is directly read without any robust error trapping. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self CLI data. character(len=*), intent(out), allocatable :: val (:) CLA values. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: args String containing command line arguments. character(len=*), intent(in), optional :: group Name of group (command) of CLA. character(len=*), intent(in), optional :: switch Switch name. integer(kind=I4P), intent(in), optional :: position Position of positional CLA. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code get_cla_list_varying_char Source Code subroutine get_cla_list_varying_char ( self , val , pref , args , group , switch , position , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get CLA multiple values from CLAs list parsed with varying size list, character. !< !< @note The CLA list is returned deallocated if values are not correctly gotten. !< !< @note For logical type CLA the value is directly read without any robust error trapping. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< CLI data. character ( * ), allocatable , intent ( out ) :: val (:) !< CLA values. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: args !< String containing command line arguments. character ( * ), optional , intent ( in ) :: group !< Name of group (command) of CLA. character ( * ), optional , intent ( in ) :: switch !< Switch name. integer ( I4P ), optional , intent ( in ) :: position !< Position of positional CLA. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. logical :: found !< Flag for checking if CLA containing switch has been found. integer ( I4P ) :: g !< Group counter. integer ( I4P ) :: a !< Argument counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . self % is_parsed_ ) then call self % parse ( pref = pref , args = args , error = error ) if ( self % error /= 0 ) return endif if ( present ( group )) then if (. not . self % is_defined_group ( group = group , g = g )) then call self % errored ( pref = pref , error = ERROR_MISSING_GROUP , group = group ) endif else g = 0 endif if ( present ( switch )) then ! search for the CLA corresponding to switch found = . false . do a = 1 , self % clasg ( g )% Na if (. not . self % clasg ( g )% cla ( a )% is_positional ) then if (( self % clasg ( g )% cla ( a )% switch == switch ). or .( self % clasg ( g )% cla ( a )% switch_ab == switch )) then found = . true . exit endif endif enddo if (. not . found ) then call self % errored ( pref = pref , error = ERROR_MISSING_CLA , switch = switch ) else call self % clasg ( g )% cla ( a )% get_varying ( pref = pref , val = val ) ; self % error = self % clasg ( g )% cla ( a )% error endif elseif ( present ( position )) then call self % clasg ( g )% cla ( position )% get_varying ( pref = pref , val = val ) ; self % error = error else call self % errored ( pref = pref , error = ERROR_MISSING_SELECTION_CLA ) endif if ( present ( error )) error = self % error return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_cla_list_varying_char","tags":"","loc":"proc/get_cla_list_varying_char~2.html","title":"get_cla_list_varying_char – FLAP"},{"text":"private subroutine print_usage(self, pref) Print correct usage. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code print_usage Source Code subroutine print_usage ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print correct usage. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( self % usage_lun , '(A)' ) self % usage ( pref = pref , g = 0 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_usage","tags":"","loc":"proc/print_usage.html","title":"print_usage – FLAP"},{"text":"private subroutine save_man_page(self, man_file, error) Save man page build on the CLI. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: man_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Calls proc~~save_man_page~~CallsGraph proc~save_man_page save_man_page interface~strz strz proc~save_man_page->interface~strz proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_man_page Source Code subroutine save_man_page ( self , man_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save man page build on the CLI. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: man_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = idate ) man = '.TH ' // self % progname // ' \"1\" \"' // month ( idate ( 2 )) // ' ' // trim ( adjustl ( strz ( 4 , idate ( 1 )))) // '\" \"version ' // self % version // & '\" \"' // self % progname // ' Manual\"' man = man // new_line ( 'a' ) // '.SH NAME' man = man // new_line ( 'a' ) // self % progname // ' - manual page for ' // self % progname // ' version ' // self % version man = man // new_line ( 'a' ) // '.SH SYNOPSIS' man = man // new_line ( 'a' ) // '.B ' // self % progname // new_line ( 'a' ) // trim ( adjustl ( self % signature ())) if ( self % description /= '' ) man = man // new_line ( 'a' ) // '.SH DESCRIPTION' // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // '.SH OPTIONS' man = man // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 ) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '.SH EXAMPLES' man = man // new_line ( 'a' ) // '.PP' man = man // new_line ( 'a' ) // '.nf' man = man // new_line ( 'a' ) // '.RS' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) // trim ( self % examples ( e )) enddo man = man // new_line ( 'a' ) // '.RE' man = man // new_line ( 'a' ) // '.fi' man = man // new_line ( 'a' ) // '.PP' endif if ( self % authors /= '' ) man = man // new_line ( 'a' ) // '.SH AUTHOR' // new_line ( 'a' ) // self % authors if ( self % license /= '' ) man = man // new_line ( 'a' ) // '.SH COPYRIGHT' // new_line ( 'a' ) // self % license open ( newunit = u , file = trim ( adjustl ( man_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_man_page","tags":"","loc":"proc/save_man_page.html","title":"save_man_page – FLAP"},{"text":"private subroutine save_usage_to_markdown(self, markdown_file, error) Save the CLI as a markdown page, for inclusion into the documentation. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(in) :: self CLI data. character(len=*), intent(in) :: markdown_file Output file name for saving man page. integer(kind=I4P), intent(out), optional :: error Error trapping flag. Source Code save_usage_to_markdown Source Code subroutine save_usage_to_markdown ( self , markdown_file , error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save the CLI as a markdown page, for inclusion into the documentation. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( in ) :: self !< CLI data. character ( * ), intent ( in ) :: markdown_file !< Output file name for saving man page. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag. character ( len = :), allocatable :: man !< Man page. integer ( I4P ) :: idate ( 1 : 8 ) !< Integer array for handling the date. integer ( I4P ) :: e !< Counter. integer ( I4P ) :: u !< Unit file handler. character ( * ), parameter :: month ( 12 ) = [ \"Jan\" ,& \"Feb\" ,& \"Mar\" ,& \"Apr\" ,& \"May\" ,& \"Jun\" ,& \"Jul\" ,& \"Aug\" ,& \"Sep\" ,& \"Oct\" ,& \"Nov\" ,& \"Dec\" ] !< Months list. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! add the other tags here. man = '' ! add the short description if ( self % description /= '' ) man = man // new_line ( 'a' ) // '### Short description' // new_line ( 'a' ) // new_line ( 'a' ) // self % description if ( self % clasg ( 0 )% Na > 0 ) then man = man // new_line ( 'a' ) // new_line ( 'a' ) // '### Command line options:' man = man // new_line ( 'a' ) // new_line ( 'a' ) // self % usage ( no_header = . true ., no_examples = . true ., no_epilog = . true ., g = 0 , markdown = . true .) endif if ( allocated ( self % examples )) then man = man // new_line ( 'a' ) // '### Examples' do e = 1 , size ( self % examples , dim = 1 ) man = man // new_line ( 'a' ) man = man // new_line ( 'a' ) // '`' // trim ( self % examples ( e )) // '` ' enddo endif open ( newunit = u , file = trim ( adjustl ( markdown_file ))) if ( present ( error )) then write ( u , \"(A)\" , iostat = error ) man else write ( u , \"(A)\" ) man endif close ( u ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_usage_to_markdown","tags":"","loc":"proc/save_usage_to_markdown.html","title":"save_usage_to_markdown – FLAP"},{"text":"private subroutine errored(self, error, pref, group, switch) Trig error occurrence and print meaningful message. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: self Object data. integer(kind=I4P), intent(in) :: error Error occurred. character(len=*), intent(in), optional :: pref Prefixing string. character(len=*), intent(in), optional :: group Group name. character(len=*), intent(in), optional :: switch CLA switch name. Source Code errored Source Code subroutine errored ( self , error , pref , group , switch ) !--------------------------------------------------------------------------------------------------------------------------------- !< Trig error occurrence and print meaningful message. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: self !< Object data. integer ( I4P ), intent ( in ) :: error !< Error occurred. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( * ), optional , intent ( in ) :: group !< Group name. character ( * ), optional , intent ( in ) :: switch !< CLA switch name. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % error = error if ( self % error /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref select case ( self % error ) case ( ERROR_MISSING_CLA ) self % error_message = prefd // self % progname // ': error: there is no option \"' // trim ( adjustl ( switch )) // '\"!' case ( ERROR_MISSING_SELECTION_CLA ) self % error_message = prefd // self % progname // & ': error: to get an option value one of switch \"name\" or \"position\" must be provided!' case ( ERROR_MISSING_GROUP ) self % error_message = prefd // self % progname // ': error: ther is no group (command) named \"' // trim ( adjustl ( group )) // '\"!' case ( ERROR_TOO_FEW_CLAS ) ! self%error_message = prefd//self%progname//': error: too few arguments ('//trim(str(.true.,Na))//')'//& ! ' respect the required ('//trim(str(.true.,self%Na_required))//')' endselect write ( self % error_lun , '(A)' ) call self % print_error_message endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine errored","tags":"","loc":"proc/errored~3.html","title":"errored – FLAP"},{"text":"private elemental subroutine cli_assign_cli(lhs, rhs) Assignment operator. Arguments Type Intent Optional Attributes Name class( command_line_interface ), intent(inout) :: lhs Left hand side. type( command_line_interface ), intent(in) :: rhs Right hand side. Source Code cli_assign_cli Source Code elemental subroutine cli_assign_cli ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( command_line_interface ), intent ( inout ) :: lhs !< Left hand side. type ( command_line_interface ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! object members call lhs % assign_object ( rhs ) ! command_line_interface members if ( allocated ( rhs % clasg )) lhs % clasg = rhs % clasg if ( allocated ( rhs % examples )) lhs % examples = rhs % examples lhs % disable_hv = rhs % disable_hv return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine cli_assign_cli","tags":"","loc":"proc/cli_assign_cli.html","title":"cli_assign_cli – FLAP"},{"text":"private elemental subroutine finalize(self) Free dynamic memory when finalizing. Arguments Type Intent Optional Attributes Name type( command_line_interface ), intent(inout) :: self CLI data. Source Code finalize Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( command_line_interface ), intent ( inout ) :: self !< CLI data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~3.html","title":"finalize – FLAP"},{"text":"private elemental subroutine free_object(self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. Source Code free_object Source Code elemental subroutine free_object ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( inout ) :: self !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % progname )) deallocate ( self % progname ) if ( allocated ( self % version )) deallocate ( self % version ) if ( allocated ( self % help )) deallocate ( self % help ) if ( allocated ( self % description )) deallocate ( self % description ) if ( allocated ( self % license )) deallocate ( self % license ) if ( allocated ( self % authors )) deallocate ( self % authors ) if ( allocated ( self % epilog )) deallocate ( self % epilog ) if ( allocated ( self % m_exclude )) deallocate ( self % m_exclude ) if ( allocated ( self % error_message )) deallocate ( self % error_message ) self % error = 0_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free_object","tags":"","loc":"proc/free_object.html","title":"free_object – FLAP"},{"text":"private subroutine print_version(self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. Source Code print_version Source Code subroutine print_version ( self , pref ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print version. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( in ) :: self !< Object data. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- prefd = '' ; if ( present ( pref )) prefd = pref write ( self % version_lun , '(A)' ) prefd // self % progname // ' version ' // self % version if ( self % license /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % license endif if ( self % authors /= '' ) then write ( self % version_lun , '(A)' ) prefd // self % authors endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_version","tags":"","loc":"proc/print_version.html","title":"print_version – FLAP"},{"text":"private subroutine print_error_message(self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. Source Code print_error_message Source Code subroutine print_error_message ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print meaningful error message to standard-error. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( in ) :: self !< Object data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( self % error_lun , '(A)' ) self % error_message write ( self % error_lun , '(A)' ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine print_error_message","tags":"","loc":"proc/print_error_message.html","title":"print_error_message – FLAP"},{"text":"private elemental subroutine assign_object(lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side. Source Code assign_object Source Code elemental subroutine assign_object ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign two abstract objects. !--------------------------------------------------------------------------------------------------------------------------------- class ( object ), intent ( inout ) :: lhs !< Left hand side. class ( object ), intent ( in ) :: rhs !< Rigth hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % progname )) lhs % progname = rhs % progname if ( allocated ( rhs % version )) lhs % version = rhs % version if ( allocated ( rhs % help )) lhs % help = rhs % help if ( allocated ( rhs % description )) lhs % description = rhs % description if ( allocated ( rhs % license )) lhs % license = rhs % license if ( allocated ( rhs % authors )) lhs % authors = rhs % authors if ( allocated ( rhs % epilog )) lhs % epilog = rhs % epilog if ( allocated ( rhs % m_exclude )) lhs % m_exclude = rhs % m_exclude return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_object","tags":"","loc":"proc/assign_object.html","title":"assign_object – FLAP"},{"text":"private elemental function count_substring(string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Called By proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code count_substring Source Code elemental function count_substring ( string , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string )) return c1 = 1 do c2 = index ( string = string ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring","tags":"","loc":"proc/count_substring.html","title":"count_substring – FLAP"},{"text":"public pure function replace(string, substring, restring) result(newstring) Replace substring (only first occurrence) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. Called By proc~~replace~~CalledByGraph proc~replace replace proc~replace_all replace_all proc~replace_all->proc~replace proc~usage usage proc~usage->proc~replace_all proc~sanitize_defaults sanitize_defaults proc~sanitize_defaults->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code replace Source Code pure function replace ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (only first occurrence) into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. integer ( I4P ) :: pos !< Position from which replace the substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos = index ( string = string , substring = substring ) newstring = string if ( pos > 0 ) then if ( pos == 1 ) then newstring = restring // string ( len ( substring ) + 1 :) else newstring = string ( 1 : pos - 1 ) // restring // string ( pos + len ( substring ):) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace","tags":"","loc":"proc/replace.html","title":"replace – FLAP"},{"text":"public pure function replace_all(string, substring, restring) result(newstring) Replace substring (all occurrences) into a string. Note Leading and trailing white spaces are stripped out. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. Calls proc~~replace_all~~CallsGraph proc~replace_all replace_all proc~wstrip wstrip proc~replace_all->proc~wstrip proc~replace replace proc~replace_all->proc~replace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~replace_all~~CalledByGraph proc~replace_all replace_all proc~usage usage proc~usage->proc~replace_all proc~sanitize_defaults sanitize_defaults proc~sanitize_defaults->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code replace_all Source Code pure function replace_all ( string , substring , restring ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Replace substring (all occurrences) into a string. !< !< @note Leading and trailing white spaces are stripped out. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len =* ), intent ( in ) :: substring !< Substring to be replaced. character ( len =* ), intent ( in ) :: restring !< String to be inserted. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- newstring = wstrip ( string ) do if ( index ( newstring , substring ) > 0 ) then newstring = replace ( string = newstring , substring = substring , restring = restring ) else exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_all","tags":"","loc":"proc/replace_all.html","title":"replace_all – FLAP"},{"text":"public elemental function unique(string, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. Note Eventual multiple trailing white space are not reduced to one occurrence. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be parsed. character(len=*), intent(in) :: substring Substring which multiple occurences must be reduced to one. Return Value character(len=len(string)) String parsed. Called By proc~~unique~~CalledByGraph proc~unique unique proc~sanitize_defaults sanitize_defaults proc~sanitize_defaults->proc~unique Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code unique Source Code elemental function unique ( string , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be parsed. character ( len =* ), intent ( in ) :: substring !< Substring which multiple occurences must be reduced to one. character ( len = len ( string )) :: uniq !< String parsed. integer ( I4P ) :: Lsub !< Lenght of substring. integer ( I4P ) :: c1 !< Counter. integer ( I4P ) :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- uniq = string Lsub = len ( substring ) if ( Lsub > len ( string )) return c1 = 1 Loop1 : do if ( c1 >= len_trim ( uniq )) exit Loop1 if ( uniq ( c1 : c1 + Lsub - 1 ) == substring . and . uniq ( c1 + Lsub : c1 + 2 * Lsub - 1 ) == substring ) then c2 = c1 + Lsub Loop2 : do if ( c2 >= len_trim ( uniq )) exit Loop2 if ( uniq ( c2 : c2 + Lsub - 1 ) == substring ) then c2 = c2 + Lsub else exit Loop2 endif enddo Loop2 uniq = uniq ( 1 : c1 ) // uniq ( c2 :) else c1 = c1 + Lsub endif enddo Loop1 return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique","tags":"","loc":"proc/unique.html","title":"unique – FLAP"},{"text":"public elemental function upper_case(string) Convert the lower case characters of a string to upper case one. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. Called By proc~~upper_case~~CalledByGraph proc~upper_case upper_case proc~add~2 add proc~add~2->proc~upper_case Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code upper_case Source Code elemental function upper_case ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the lower case characters of a string to upper case one. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be converted. character ( len = len ( string )) :: upper_case !< Converted string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. character ( len = 26 ), parameter :: upper_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( len = 26 ), parameter :: lower_alphabet = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- upper_case = string do n1 = 1 , len ( string ) n2 = index ( lower_alphabet , string ( n1 : n1 )) if ( n2 > 0 ) upper_case ( n1 : n1 ) = upper_alphabet ( n2 : n2 ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper_case","tags":"","loc":"proc/upper_case.html","title":"upper_case – FLAP"},{"text":"public pure function wstrip(string) result(newstring) Strip out leading and trailing white spaces from a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. Return Value character(len=:),\n  allocatable New modified string. Called By proc~~wstrip~~CalledByGraph proc~wstrip wstrip proc~replace_all replace_all proc~replace_all->proc~wstrip proc~sanitize_defaults sanitize_defaults proc~sanitize_defaults->proc~wstrip proc~sanitize_defaults->proc~replace_all proc~usage usage proc~usage->proc~replace_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code wstrip Source Code pure function wstrip ( string ) result ( newstring ) !--------------------------------------------------------------------------------------------------------------------------------- !< Strip out leading and trailing white spaces from a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string !< String to be modified. character ( len = :), allocatable :: newstring !< New modified string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( newstring , source = trim ( adjustl ( string ))) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction wstrip","tags":"","loc":"proc/wstrip.html","title":"wstrip – FLAP"},{"text":"public pure subroutine tokenize(strin, delimiter, toks, Nt) Tokenize a string in order to parse it. Note The dummy array containing tokens must allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to input string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens. Called By proc~~tokenize~~CalledByGraph proc~tokenize tokenize proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->proc~tokenize proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->proc~tokenize proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->proc~tokenize proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->proc~tokenize proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->proc~tokenize proc~get_cla_list_varying_logical get_cla_list_varying_logical proc~get_cla_list_varying_logical->proc~tokenize proc~get_cla_list_varying_char get_cla_list_varying_char proc~get_cla_list_varying_char->proc~tokenize proc~check_choices check_choices proc~check_choices->proc~tokenize proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->proc~tokenize proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->proc~tokenize proc~get_args_from_string get_args_from_string proc~get_args_from_string->proc~tokenize proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->proc~tokenize proc~get_cla_list get_cla_list proc~get_cla_list->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tokenize Source Code pure subroutine tokenize ( strin , delimiter , toks , Nt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to input string. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: strin !< String to be tokenized. character ( len =* ), intent ( in ) :: delimiter !< Delimiter of tokens. character ( len = len ( strin )), intent ( out ), allocatable :: toks (:) !< Tokens. integer ( I4P ), intent ( out ), optional :: Nt !< Number of tokens. character ( len = len ( strin )) :: strsub !< Temporary string. integer ( I4P ) :: dlen !< Delimiter length. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: n !< Counter. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! initialization if ( allocated ( toks )) deallocate ( toks ) strsub = strin dlen = len ( delimiter ) if ( dlen > len ( strin )) then allocate ( toks ( 1 : 1 )) ; toks ( 1 ) = strin ; if ( present ( Nt )) Nt = 1 ; return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenization do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tokenize","tags":"","loc":"proc/tokenize.html","title":"tokenize – FLAP"},{"text":"public interface count Overload intrinsic function count for counting substring occurences into strings. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures count_substring Module Procedures private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences.","tags":"","loc":"interface/count.html","title":"count – FLAP"},{"text":"private elemental function digit_I8(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I8 Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – FLAP"},{"text":"private elemental function digit_I4(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I4 Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – FLAP"},{"text":"private elemental function digit_I2(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I2 Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – FLAP"},{"text":"private elemental function digit_I1(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I1 Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – FLAP"},{"text":"public subroutine check_endian() Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Arguments None Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian program~compact_real compact_real program~compact_real->proc~penf_init program~test_all test_all program~test_all->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_endian Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – FLAP"},{"text":"public subroutine penf_init() Initialize PENF's variables that are not initialized into the definition specification. Arguments None Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~penf_init~~CalledByGraph proc~penf_init penf_init program~compact_real compact_real program~compact_real->proc~penf_init program~test_all test_all program~test_all->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code penf_init Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init – FLAP"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Called By proc~~penf_print~~CalledByGraph proc~penf_print penf_print program~test_all test_all program~test_all->proc~penf_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code penf_print Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print – FLAP"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables.","tags":"","loc":"interface/bit_size.html","title":"bit_size – FLAP"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~digit~~CalledByGraph interface~digit digit program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures digit_I8 digit_I4 digit_I2 digit_I1 Module Procedures private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits.","tags":"","loc":"interface/digit.html","title":"digit – FLAP"},{"text":"private elemental function bit_size_R16P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Source Code bit_size_R16P Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – FLAP"},{"text":"private elemental function bit_size_R8P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R8P Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – FLAP"},{"text":"private elemental function bit_size_R4P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R4P Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – FLAP"},{"text":"private elemental function bit_size_chr(i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_chr Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – FLAP"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I8P Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – FLAP"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I4P Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – FLAP"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I2P Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – FLAP"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I1P Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – FLAP"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Source Code byte_size_R16P Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – FLAP"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R8P Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – FLAP"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R4P Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – FLAP"},{"text":"private elemental function byte_size_chr(i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_chr Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – FLAP"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~2~~CallsGraph interface~bit_size~2 bit_size proc~bit_size_r8p bit_size_R8P interface~bit_size~2->proc~bit_size_r8p proc~bit_size_chr bit_size_chr interface~bit_size~2->proc~bit_size_chr proc~bit_size_r4p bit_size_R4P interface~bit_size~2->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bit_size_R8P bit_size_R4P bit_size_chr Module Procedures private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c.","tags":"","loc":"interface/bit_size~2.html","title":"bit_size – FLAP"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R8P byte_size_R4P byte_size_chr Module Procedures private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"interface/byte_size.html","title":"byte_size – FLAP"},{"text":"private elemental function strf_R16P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Source Code strf_R16P Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – FLAP"},{"text":"private elemental function strf_R8P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R8P Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – FLAP"},{"text":"private elemental function strf_R4P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R4P Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – FLAP"},{"text":"private elemental function strf_I8P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I8P Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – FLAP"},{"text":"private elemental function strf_I4P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I4P Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – FLAP"},{"text":"private elemental function strf_I2P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I2P Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – FLAP"},{"text":"private elemental function strf_I1P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I1P Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – FLAP"},{"text":"private elemental function str_R16P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. Calls proc~~str_r16p~~CallsGraph proc~str_r16p str_R16P proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R16P Source Code elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – FLAP"},{"text":"private elemental function str_R8P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. Calls proc~~str_r8p~~CallsGraph proc~str_r8p str_R8P proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R8P Source Code elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – FLAP"},{"text":"private elemental function str_R4P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. Calls proc~~str_r4p~~CallsGraph proc~str_r4p str_R4P proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R4P Source Code elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – FLAP"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I8P Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – FLAP"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I4P Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – FLAP"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I2P Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – FLAP"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I1P Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – FLAP"},{"text":"private elemental function str_bol(n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_bol Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – FLAP"},{"text":"private pure function str_a_R16P(n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R16P Source Code pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – FLAP"},{"text":"private pure function str_a_R8P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R8P Source Code pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – FLAP"},{"text":"private pure function str_a_R4P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R4P Source Code pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – FLAP"},{"text":"private pure function str_a_I8P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I8P Source Code pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – FLAP"},{"text":"private pure function str_a_I4P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I4P Source Code pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – FLAP"},{"text":"private pure function str_a_I2P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I2P Source Code pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – FLAP"},{"text":"private pure function str_a_I1P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I1P Source Code pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – FLAP"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p proc~save_man_page save_man_page proc~save_man_page->interface~strz program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I8P Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – FLAP"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p proc~save_man_page save_man_page proc~save_man_page->interface~strz program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I4P Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – FLAP"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p proc~save_man_page save_man_page proc~save_man_page->interface~strz program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I2P Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – FLAP"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p proc~save_man_page save_man_page proc~save_man_page->interface~strz program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I1P Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – FLAP"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Source Code ctor_R16P Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – FLAP"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p proc~signature signature proc~signature->interface~cton proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->interface~cton proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->interface~cton proc~usage usage proc~usage->interface~cton proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->interface~cton proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->interface~cton proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->interface~cton proc~parse parse proc~parse->interface~cton program~test_all test_all program~test_all->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R8P Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – FLAP"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p proc~signature signature proc~signature->interface~cton proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->interface~cton proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->interface~cton proc~usage usage proc~usage->interface~cton proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->interface~cton proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->interface~cton proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->interface~cton proc~parse parse proc~parse->interface~cton program~test_all test_all program~test_all->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R4P Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – FLAP"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p proc~signature signature proc~signature->interface~cton proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->interface~cton proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->interface~cton proc~usage usage proc~usage->interface~cton proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->interface~cton proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->interface~cton proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->interface~cton proc~parse parse proc~parse->interface~cton program~test_all test_all program~test_all->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I8P Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – FLAP"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p proc~signature signature proc~signature->interface~cton proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->interface~cton proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->interface~cton proc~usage usage proc~usage->interface~cton proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->interface~cton proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->interface~cton proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->interface~cton proc~parse parse proc~parse->interface~cton program~test_all test_all program~test_all->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I4P Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – FLAP"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p proc~signature signature proc~signature->interface~cton proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->interface~cton proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->interface~cton proc~usage usage proc~usage->interface~cton proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->interface~cton proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->interface~cton proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->interface~cton proc~parse parse proc~parse->interface~cton program~test_all test_all program~test_all->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I2P Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – FLAP"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p proc~signature signature proc~signature->interface~cton proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->interface~cton proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->interface~cton proc~usage usage proc~usage->interface~cton proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->interface~cton proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->interface~cton proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->interface~cton proc~parse parse proc~parse->interface~cton program~test_all test_all program~test_all->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I1P Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – FLAP"},{"text":"private elemental function bstr_R16P(n) result(bstr) Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Source Code bstr_R16P Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – FLAP"},{"text":"private elemental function bstr_R8P(n) result(bstr) Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R8P Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – FLAP"},{"text":"private elemental function bstr_R4P(n) result(bstr) Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R4P Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – FLAP"},{"text":"private elemental function bstr_I8P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I8P Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – FLAP"},{"text":"private elemental function bstr_I4P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I4P Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – FLAP"},{"text":"private elemental function bstr_I2P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I2P Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – FLAP"},{"text":"private elemental function bstr_I1P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I1P Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – FLAP"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R16P Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P – FLAP"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R8P Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – FLAP"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R4P Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – FLAP"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I8P Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – FLAP"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I4P Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – FLAP"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I2P Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – FLAP"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I1P Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – FLAP"},{"text":"private pure subroutine compact_real_string(string) Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number. Called By proc~~compact_real_string~~CalledByGraph proc~compact_real_string compact_real_string proc~str_r8p str_R8P proc~str_r8p->proc~compact_real_string proc~str_r4p str_R4P proc~str_r4p->proc~compact_real_string proc~str_r16p str_R16P proc~str_r16p->proc~compact_real_string proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_r4p interface~str->proc~str_a_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p proc~str_a_r4p->proc~str_r4p proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p var panproccompact_real_stringCalledByGraph = svgPanZoom('#proccompact_real_stringCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compact_real_string Source Code pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string","tags":"","loc":"proc/compact_real_string.html","title":"compact_real_string – FLAP"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str program~test_basic test_basic program~test_basic->interface~str proc~signature signature proc~signature->interface~str program~test_nested test_nested program~test_nested->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str program~compact_real compact_real program~compact_real->interface~str proc~usage usage proc~usage->interface~str program~test_choices_logical test_choices_logical program~test_choices_logical->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str program~test_hidden test_hidden program~test_hidden->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~check_choices check_choices proc~check_choices->interface~str program~test_string test_string program~test_string->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~errored~2 errored proc~errored~2->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~errored errored proc~errored->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strf_R8P str_R8P strf_R4P str_R4P strf_I8P str_I8P strf_I4P str_I4P strf_I2P str_I2P strf_I1P str_I1P str_bol str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P Module Procedures private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number.","tags":"","loc":"interface/str.html","title":"str – FLAP"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~strz~~CalledByGraph interface~strz strz proc~save_man_page save_man_page proc~save_man_page->interface~strz program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros.","tags":"","loc":"interface/strz.html","title":"strz – FLAP"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~cton~~CalledByGraph interface~cton cton proc~signature signature proc~signature->interface~cton proc~get_cla_list_varying_i2p get_cla_list_varying_I2P proc~get_cla_list_varying_i2p->interface~cton proc~get_cla_list_varying_r8p get_cla_list_varying_R8P proc~get_cla_list_varying_r8p->interface~cton proc~usage usage proc~usage->interface~cton proc~get_cla_list_varying_r16p get_cla_list_varying_R16P proc~get_cla_list_varying_r16p->interface~cton proc~get_cla_list_varying_r4p get_cla_list_varying_R4P proc~get_cla_list_varying_r4p->interface~cton proc~get_cla_list_varying_i1p get_cla_list_varying_I1P proc~get_cla_list_varying_i1p->interface~cton proc~parse parse proc~parse->interface~cton program~test_all test_all program~test_all->interface~cton proc~check_choices check_choices proc~check_choices->interface~cton proc~get_cla_list_varying_i8p get_cla_list_varying_I8P proc~get_cla_list_varying_i8p->interface~cton proc~get_cla_list_from_buffer get_cla_list_from_buffer proc~get_cla_list_from_buffer->interface~cton proc~get_cla_from_buffer get_cla_from_buffer proc~get_cla_from_buffer->interface~cton proc~get_cla_list_varying_i4p get_cla_list_varying_I4P proc~get_cla_list_varying_i4p->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/cton.html","title":"cton – FLAP"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~bstr~~CalledByGraph interface~bstr bstr program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P Module Procedures private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number.","tags":"","loc":"interface/bstr.html","title":"bstr – FLAP"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p interface~str str proc~bctor_r4p->interface~str proc~bctoi_i4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i8p->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~bcton~~CalledByGraph interface~bcton bcton program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/bcton.html","title":"bcton – FLAP"},{"text":"Uses: flap_command_line_argument_t flap_command_line_arguments_group_t flap_command_line_interface_t module~~flap~~UsesGraph module~flap flap module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_utils_m flap_utils_m module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t module~penf penf module~penf->module~flap_command_line_interface_t module~penf->module~flap_command_line_argument_t module~penf->module~flap_command_line_arguments_group_t module~penf->module~flap_utils_m module~penf->module~flap_object_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panmoduleflapUsesGraph = svgPanZoom('#moduleflapUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLAP, Fortran command Line Arguments Parser for poor people FLAP FLAP, Fortran command Line Arguments Parser for poor people A KISS pure Fortran Library for building powerful, easy-to-use, elegant command line interfaces FLAP is a pure Fortran (KISS) library for building easily nice Command Line Interfaces (CLI) for modern Fortran projects; FLAP is Fortran 2003+ standard compliant; FLAP is OOP designed; FLAP is a Free, Open Source Project. Issues Compiler Support | What is FLAP? | Main features | Copyrights | Documentation | Download & Compile | What is FLAP? Modern Fortran standards (2003+) have introduced support for Command Line Arguments (CLA), thus it is possible to construct nice and effective Command Line Interfaces (CLI). FLAP is a small library designed to simplify the (repetitive) construction of complicated CLI in pure Fortran (standard 2003+). FLAP has been inspired by the python module argparse trying to mimic it. Once you have defined the arguments that are required by means of a user-friendly method of the CLI, FLAP will parse the CLAs for you. It is worthy of note that FLAP, as argparse , also automatically generates help and usage messages and issues errors when users give the program invalid arguments. Go to Top Main features FLAP is inspired by the python great module argparse , thus many features are taken from it. Here the main features are listed. User-friendly methods for building flexible and effective Command Line Interfaces (CLI); comprehensive Command Line Arguments (CLA) support: support optional and non optional CLA; support boolean CLA; support positional CLA; support list of allowable values for defined CLA with automatic consistency check; support multiple valued (list of values, aka list-valued) CLA: compiletime sized list, e.g. nargs='3' ; runtime sized list with at least 1 value, e.g. nargs='+' ; runtime sized list with any size, even empty, e.g. nargs='*' ; support mutually exclusive CLAs; self-consistency-check of CLA definition; support fake CLAs input from a string; support fake CLAs input from environment variables; comprehensive command (group of CLAs) support: support nested subcommands; support mutually exclusive commands; self-consistency-check of command definition; automatic generation of help and usage messages; consistency-check of whole CLI definition; errors trapping for invalid CLI usage; POSIX style compliant; automatic generation of MAN PAGE using your CLI definition!; replicate all the useful features of argparse ; implement docopt features. implement click features. Any feature request is welcome. Go to Top Copyrights FLAP is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FLAP is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FLAP documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of FLAP A minimal plate : program minimal type ( command_line_interface ) :: cli ! Command Line Interface (CLI). character ( 99 ) :: string ! String value. integer :: error ! Error trapping flag. call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , & switch_ab = '-s' , & help = 'a string' , & required = . true ., & act = 'store' , & error = error ) if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) endprogram minimal That built and run provides: → ./minimal\n./minimal: error: named option \"--string\" is required!\n\nusage:  ./exe/test_minimal --string value [ --help ] [ --version ] minimal FLAP example\n\nRequired switches:\n   --string value, -s value\n    a string\n\nOptional switches:\n   --help, -h\n    Print this help message\n   --version, -v\n    Print version A nice automatic help-message, right? Executed correctly gives. → ./minimal --string 'hello world' ./exe/minimal has been called with the following argument: String = hello world For more details, see the provided tests . Nested (sub)commands FLAP fully supports nested (sub)commands or groups of command line arguments. For example a fake git toy remake can be coded as ! initializing Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' ,& examples = [ 'test_nested                      ' ,& 'test_nested -h                   ' ,& 'test_nested init                 ' ,& 'test_nested commit -m \"fix bug-1\"' ,& 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parsing Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! using Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif that when invoked without arguments prompts: cowardly you are doing nothing... try at least \"-h\" option! and invoked with -h option gives: usage: test_nested [ --authors ] [ --help ] [ --version ] { init,commit,tag } ...\n\nToy program for testing FLAP with nested commands\n\nOptional switches:\n   --authors, -a\n          default value .false.\n          Print authors names\n   --help, -h\n          Print this help message\n   --version, -v\n          Print version\n\nCommands:\n  init\n          fake init versioning\n  commit\n          fake commit changes to current branch\n  tag\n          fake tag current commit\n\nFor more detailed commands help try:\n  test_nested init -h,--help\n  test_nested commit -h,--help\n  test_nested tag -h,--help\n\nExamples:\n   test_nested\n   test_nested -h\n   test_nested init\n   test_nested commit -m \"fix bug-1\" test_nested tag -a \"v2.1.5\" For more details, see the provided example . Go to Top Download and Compile FLAP is a Fortran library composed by several modules. Before download and compile the library you must check the requirements . Download The tree structure of the FLAP project is the following: .\n├── CONTRIBUTING.md\n├── fobos\n├── LICENSE.bsd-2.md\n├── LICENSE.bsd-3.md\n├── LICENSE.gpl3.md\n├── LICENSE.mit.md\n├── makedoc.sh\n├── makefile\n├── README.md\n└── src\n    ├── lib\n    │   ├── flap_command_line_arguments_group_t.f90\n    │   ├── flap_command_line_argument_t.F90\n    │   ├── flap_command_line_interface_t.F90\n    │   ├── flap.f90\n    │   ├── flap_object_t.f90\n    │   └── flap_utils_m.f90\n    ├── tests\n    │   ├── test_basic.f90\n    │   ├── test_choices_logical.f90\n    │   ├── test_nested.f90\n    │   └── test_string.f90\n    └── third_party\n        └── PENF To download all the available releases and utilities (fobos, license, readme, etc…), it can be convenient to clone whole the project: git clone --recursive https://github.com/szaghi/FLAP Alternatively, you can directly download a release from GitHub server, see the ChangeLog . Compile The most easy way to compile FLAP is to use FoBiS.py within the provided fobos file. Consequently, it is strongly encouraged to install FoBiS.py . | Build by means of FoBiS | Build by means of GNU Make | Build by means of CMake | Build by means of FoBiS FoBiS.py is a KISS tool for automatic building of modern Fortran projects. Providing very few options, FoBiS.py is able to build almost automatically complex Fortran projects with cumbersome inter-modules dependency. This removes the necessity to write complex makefile. Moreover, providing a very simple options file (in the FoBiS.py nomenclature indicated as fobos file) FoBiS.py can substitute the (ab)use of makefile for other project stuffs (build documentations, make project archive, etc…). FLAP is shipped with a fobos file that can build the library in both static and shared forms and also build the Test_Driver program. The provided fobos file has several building modes. Listing fobos building modes Typing: FoBiS.py build -lmodes the following message should be printed: The fobos file defines the following modes:\n - \"shared-gnu\" - \"static-gnu\" - \"test-driver-gnu\" - \"shared-gnu-debug\" - \"static-gnu-debug\" - \"test-driver-gnu-debug\" - \"shared-intel\" - \"static-intel\" - \"test-driver-intel\" - \"shared-intel-debug\" - \"static-intel-debug\" - \"test-driver-intel-debug\" The modes should be self-explicative: shared , static and test-driver are the modes for building (in release, optimized form) the shared and static versions of the library and the Test Driver program, respectively. The other 3 modes are the same, but in debug form instead of release one. -gnu use the GNU gfortran compiler while -intel the Intel one. Building the library The shared or static directories are created accordingly to the form of the library built. The compiled objects and mod files are placed inside this directory, as well as the linked library. Release shared library FoBiS.py build -mode shared-gnu Release static library FoBiS.py build -mode static-gnu Debug shared library FoBiS.py build -mode shared-gnu-debug Debug static library FoBiS.py build -mode static-gnu-debug Building the Test Driver program The Test_Driver directory is created. The compiled objects and mod files are placed inside this directory, as well as the linked program. Release test driver program FoBiS.py build -mode test-driver-gnu Debug test driver program FoBiS.py build -mode test-driver-gnu-debug Listing fobos rules Typing: FoBiS.py rule -ls the following message should be printed: The fobos file defines the following rules:\n  - \"makedoc\" Rule for building documentation from source files Command = > rm -rf doc/html/* Command = > ford doc/main_page.md Command = > cp -r doc/html/publish/* doc/html/\n  - \"deldoc\" Rule for deleting documentation Command = > rm -rf doc/html/*\n  - \"maketar\" Rule for making tar archive of the project Command = > tar -czf FLAP.tar.gz *\n  - \"makecoverage\" Rule for performing coverage analysis Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33.0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64.123d0  --boolean --boolean_val .false.\n  - \"coverage-analysis\" Rule for performing coverage analysis and saving reports in markdown Command = > FoBiS.py clean -mode test-driver-gnu Command = > FoBiS.py build -mode test-driver-gnu -coverage Command = > ./Test_Driver/Test_Driver Command = > ./Test_Driver/Test_Driver -v Command = > ./Test_Driver/Test_Driver -s 'Hello FLAP' -i 2 Command = > ./Test_Driver/Test_Driver 33.0 -s 'Hello FLAP' --integer_list 10 -3 87 -i 3 -r 64.123d0  --boolean --boolean_val .false. Command = > gcov -o Test_Driver/obj/ src/* Command = > FoBiS.py rule -gcov_analyzer wiki/ Coverage-Analysis Command = > rm -f *.gcov The rules should be self-explicative. Build by means of GNU Make Bad choice :-) However, a makefile (generated by FoBiS.py…) to be used with a compatible GNU Make tool is provided . It is convenient to clone the whole FLAP repository and run a standard make: git clone --recursive https://github.com/szaghi/FLAP cd FLAP\nmake This commands build all tests (executables are in exe/ directory). To build only the library (statically linked) type: git clone --recursive https://github.com/szaghi/FLAP cd FLAP\nmake STATIC = yes Build by means of CMake Bad choice :-) However, a CMake setup (kindly developed by victorsndvg ) is provided. It is convenient to clone the whole FLAP repository and run a standard CMake configure/build commands: git clone --recursive https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake $YOUR_FLAP_PATH make If you want to run the tests suite type: git clone --recursive https://github.com/szaghi/FLAP $YOUR_FLAP_PATH mkdir build cd build\ncmake -DFLAP_ENABLE_TESTS = ON $YOUR_FLAP_PATH make\nctest Go to Top Used By module~~flap~~UsedByGraph module~flap flap program~test_basic test_basic module~flap->program~test_basic program~test_nested test_nested module~flap->program~test_nested program~test_hidden test_hidden module~flap->program~test_hidden program~test_string test_string module~flap->program~test_string program~test_minimal test_minimal module~flap->program~test_minimal program~test_choices_logical test_choices_logical module~flap->program~test_choices_logical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/flap.html","title":"flap – FLAP"},{"text":"Uses: flap_object_t flap_utils_m penf module~~flap_command_line_argument_t~~UsesGraph module~flap_command_line_argument_t flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_object_t->module~flap_command_line_argument_t module~flap_utils_m flap_utils_m module~flap_utils_m->module~flap_command_line_argument_t module~penf penf module~penf->module~flap_command_line_argument_t module~penf->module~flap_object_t module~penf->module~flap_utils_m iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panmoduleflap_command_line_argument_tUsesGraph = svgPanZoom('#moduleflap_command_line_argument_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Command Line Argument (CLA) class. Used By module~~flap_command_line_argument_t~~UsedByGraph module~flap_command_line_argument_t flap_command_line_argument_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap flap module~flap_command_line_argument_t->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_interface_t->module~flap program~test_basic test_basic module~flap->program~test_basic program~test_nested test_nested module~flap->program~test_nested program~test_hidden test_hidden module~flap->program~test_hidden program~test_string test_string module~flap->program~test_string program~test_minimal test_minimal module~flap->program~test_minimal program~test_choices_logical test_choices_logical module~flap->program~test_choices_logical module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap var panmoduleflap_command_line_argument_tUsedByGraph = svgPanZoom('#moduleflap_command_line_argument_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ACTION_STORE ACTION_STORE_STAR ACTION_STORE_TRUE ACTION_STORE_FALSE ACTION_PRINT_HELP ACTION_PRINT_VERS ARGS_SEP ERROR_OPTIONAL_NO_DEF ERROR_REQUIRED_M_EXCLUDE ERROR_POSITIONAL_M_EXCLUDE ERROR_NAMED_NO_NAME ERROR_POSITIONAL_NO_POSITION ERROR_POSITIONAL_NO_STORE ERROR_NOT_IN_CHOICES ERROR_MISSING_REQUIRED ERROR_M_EXCLUDE ERROR_CASTING_LOGICAL ERROR_CHOICES_LOGICAL ERROR_NO_LIST ERROR_NARGS_INSUFFICIENT ERROR_VALUE_MISSING ERROR_UNKNOWN ERROR_ENVVAR_POSITIONAL ERROR_ENVVAR_NOT_STORE ERROR_ENVVAR_NARGS ERROR_STORE_STAR_POSITIONAL ERROR_STORE_STAR_NARGS ERROR_STORE_STAR_ENVVAR ERROR_ACTION_UNKNOWN Derived Types command_line_argument Functions is_required_passed usage signature check_list_size Subroutines free check raise_error_m_exclude raise_error_nargs_insufficient raise_error_value_missing raise_error_switch_unknown sanitize_defaults errored check_envvar_consistency check_action_consistency check_optional_consistency check_m_exclude_consistency check_named_consistency check_positional_consistency check_choices get_cla get_cla_from_buffer get_cla_list get_cla_list_from_buffer get_cla_list_varying_R16P get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char cla_assign_cla finalize Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: ACTION_STORE = 'STORE' Store value (if invoked a value must be passed). character(len=*), public, parameter :: ACTION_STORE_STAR = 'STORE*' Store value or revert on default is invoked alone. character(len=*), public, parameter :: ACTION_STORE_TRUE = 'STORE_TRUE' Store .true. without the necessity of a value. character(len=*), public, parameter :: ACTION_STORE_FALSE = 'STORE_FALSE' Store .false. without the necessity of a value. character(len=*), public, parameter :: ACTION_PRINT_HELP = 'PRINT_HELP' Print help message. character(len=*), public, parameter :: ACTION_PRINT_VERS = 'PRINT_VERSION' Print version. character(len=*), public, parameter :: ARGS_SEP = '||!||' Arguments separator for multiple valued (list) CLA. integer(kind=I4P), private, parameter :: ERROR_OPTIONAL_NO_DEF = 1 Optional CLA without default value. integer(kind=I4P), private, parameter :: ERROR_REQUIRED_M_EXCLUDE = 2 Required CLA cannot exclude others. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_M_EXCLUDE = 3 Positional CLA cannot exclude others. integer(kind=I4P), private, parameter :: ERROR_NAMED_NO_NAME = 4 Named CLA without switch name. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_NO_POSITION = 5 Positional CLA without position. integer(kind=I4P), private, parameter :: ERROR_POSITIONAL_NO_STORE = 6 Positional CLA without action_store. integer(kind=I4P), private, parameter :: ERROR_NOT_IN_CHOICES = 7 CLA value out of a specified choices. integer(kind=I4P), private, parameter :: ERROR_MISSING_REQUIRED = 8 Missing required CLA. integer(kind=I4P), private, parameter :: ERROR_M_EXCLUDE = 9 Two mutually exclusive CLAs have been passed. integer(kind=I4P), private, parameter :: ERROR_CASTING_LOGICAL = 10 Error casting CLA value to logical type. integer(kind=I4P), private, parameter :: ERROR_CHOICES_LOGICAL = 11 Error adding choices check for CLA val of logical type. integer(kind=I4P), private, parameter :: ERROR_NO_LIST = 12 Actual CLA is not list-values. integer(kind=I4P), private, parameter :: ERROR_NARGS_INSUFFICIENT = 13 Multi-valued CLA with insufficient arguments. integer(kind=I4P), private, parameter :: ERROR_VALUE_MISSING = 14 Missing value of CLA. integer(kind=I4P), private, parameter :: ERROR_UNKNOWN = 15 Unknown CLA (switch name). integer(kind=I4P), private, parameter :: ERROR_ENVVAR_POSITIONAL = 16 Envvar not allowed for positional CLA. integer(kind=I4P), private, parameter :: ERROR_ENVVAR_NOT_STORE = 17 Envvar not allowed action different from store; integer(kind=I4P), private, parameter :: ERROR_ENVVAR_NARGS = 18 Envvar not allowed for list-values CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_POSITIONAL = 19 Action store* not allowed for positional CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_NARGS = 20 Action store* not allowed for list-values CLA. integer(kind=I4P), private, parameter :: ERROR_STORE_STAR_ENVVAR = 21 Action store* not allowed for environment variable CLA. integer(kind=I4P), private, parameter :: ERROR_ACTION_UNKNOWN = 22 Unknown CLA (switch name). Derived Types type, public, extends( object ) :: command_line_argument Command Line Argument (CLA) class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: switch Switch name. character(len=:), public, allocatable :: switch_ab Abbreviated switch name. logical, public :: is_required = .false. Flag for set required argument. logical, public :: is_positional = .false. Flag for checking if CLA is a positional or a named CLA. integer(kind=I4P), public :: position = 0_I4P Position of positional CLA. logical, public :: is_passed = .false. Flag for checking if CLA has been passed to CLI. logical, public :: is_hidden = .false. Flag for hiding CLA, thus it does not compare into help. character(len=:), public, allocatable :: act CLA value action. character(len=:), public, allocatable :: def Default value. character(len=:), public, allocatable :: nargs Number of arguments consumed by CLA. character(len=:), public, allocatable :: choices List (comma separated) of allowable values for the argument. character(len=:), public, allocatable :: val CLA value. character(len=:), public, allocatable :: envvar Environment variable from which take value. Finalizations Procedures final :: finalize","tags":"","loc":"module/flap_command_line_argument_t.html","title":"flap_command_line_argument_t – FLAP"},{"text":"Uses: flap_command_line_argument_t flap_object_t penf module~~flap_command_line_arguments_group_t~~UsesGraph module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_object_t flap_object_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~penf penf module~penf->module~flap_command_line_arguments_group_t module~penf->module~flap_object_t module~penf->module~flap_command_line_argument_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~flap_utils_m->module~flap_command_line_argument_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panmoduleflap_command_line_arguments_group_tUsesGraph = svgPanZoom('#moduleflap_command_line_arguments_group_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Command Line Arguments Group (CLAsG) class. Used By module~~flap_command_line_arguments_group_t~~UsedByGraph module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap flap module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_interface_t->module~flap program~test_basic test_basic module~flap->program~test_basic program~test_nested test_nested module~flap->program~test_nested program~test_hidden test_hidden module~flap->program~test_hidden program~test_string test_string module~flap->program~test_string program~test_minimal test_minimal module~flap->program~test_minimal program~test_choices_logical test_choices_logical module~flap->program~test_choices_logical var panmoduleflap_command_line_arguments_group_tUsedByGraph = svgPanZoom('#moduleflap_command_line_arguments_group_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables STATUS_PRINT_V STATUS_PRINT_H ERROR_CONSISTENCY ERROR_M_EXCLUDE Derived Types command_line_arguments_group Functions is_passed is_defined usage signature Subroutines free check is_required_passed raise_error_m_exclude add parse errored check_m_exclusive sanitize_defaults clasg_assign_clasg finalize Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: STATUS_PRINT_V = -1 Print version status. integer(kind=I4P), public, parameter :: STATUS_PRINT_H = -2 Print help status. integer(kind=I4P), private, parameter :: ERROR_CONSISTENCY = 23 CLAs group consistency error. integer(kind=I4P), private, parameter :: ERROR_M_EXCLUDE = 24 Two mutually exclusive CLAs group have been called. Derived Types type, public, extends( object ) :: command_line_arguments_group Command Line Arguments Group (CLAsG) class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages character(len=:), public, allocatable :: group Group name (command). integer(kind=I4P), public :: Na = 0_I4P Number of CLA. integer(kind=I4P), private :: Na_required = 0_I4P Number of required command line arguments. integer(kind=I4P), private :: Na_optional = 0_I4P Number of optional command line arguments. type( command_line_argument ), public, allocatable :: cla (:) CLA list [1:Na]. logical, public :: is_called = .false. Flag for checking if CLAs group has been passed to CLI. Finalizations Procedures final :: finalize","tags":"","loc":"module/flap_command_line_arguments_group_t.html","title":"flap_command_line_arguments_group_t – FLAP"},{"text":"Uses: flap_command_line_argument_t flap_command_line_arguments_group_t flap_object_t flap_utils_m penf module~~flap_command_line_interface_t~~UsesGraph module~flap_command_line_interface_t flap_command_line_interface_t module~flap_utils_m flap_utils_m module~flap_utils_m->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t flap_object_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_arguments_group_t module~penf penf module~penf->module~flap_command_line_interface_t module~penf->module~flap_utils_m module~penf->module~flap_object_t module~penf->module~flap_command_line_argument_t module~penf->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panmoduleflap_command_line_interface_tUsesGraph = svgPanZoom('#moduleflap_command_line_interface_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Command Line Interface (CLI) class. Used By module~~flap_command_line_interface_t~~UsedByGraph module~flap_command_line_interface_t flap_command_line_interface_t module~flap flap module~flap_command_line_interface_t->module~flap program~test_basic test_basic module~flap->program~test_basic program~test_nested test_nested module~flap->program~test_nested program~test_hidden test_hidden module~flap->program~test_hidden program~test_string test_string module~flap->program~test_string program~test_minimal test_minimal module~flap->program~test_minimal program~test_choices_logical test_choices_logical module~flap->program~test_choices_logical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables MAX_VAL_LEN ERROR_MISSING_CLA ERROR_MISSING_GROUP ERROR_MISSING_SELECTION_CLA ERROR_TOO_FEW_CLAS Derived Types command_line_interface Functions is_passed is_defined_group is_called_group is_defined is_parsed usage signature Subroutines free init add_group set_mutually_exclusive_groups add check check_m_exclusive parse get_clasg_indexes get_args_from_string get_args_from_invocation get_cla get_cla_list get_cla_list_varying_R16P get_cla_list_varying_R8P get_cla_list_varying_R4P get_cla_list_varying_I8P get_cla_list_varying_I4P get_cla_list_varying_I2P get_cla_list_varying_I1P get_cla_list_varying_logical get_cla_list_varying_char print_usage save_man_page save_usage_to_markdown errored cli_assign_cli finalize Variables Type Visibility Attributes Name Initial integer(kind=I4P), public, parameter :: MAX_VAL_LEN = 1000 Maximum number of characters of CLA value. integer(kind=I4P), public, parameter :: ERROR_MISSING_CLA = 25 CLA not found in CLI. integer(kind=I4P), public, parameter :: ERROR_MISSING_GROUP = 26 Group not found in CLI. integer(kind=I4P), public, parameter :: ERROR_MISSING_SELECTION_CLA = 27 CLA selection in CLI failing. integer(kind=I4P), public, parameter :: ERROR_TOO_FEW_CLAS = 28 Insufficient arguments for CLI. Derived Types type, public, extends( object ) :: command_line_interface Command Line Interface (CLI) class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages type( command_line_arguments_group ), private, allocatable :: clasg (:) CLA list [1:Na]. character(len=512), private, allocatable :: args (:) Actually passed command line arguments. character(len=512), private, allocatable :: examples (:) Examples of correct usage. logical, private :: disable_hv = .false. Disable automatic 'help' and 'version' CLAs. logical, private :: is_parsed_ = .false. Parse status. Finalizations Procedures final :: finalize","tags":"","loc":"module/flap_command_line_interface_t.html","title":"flap_command_line_interface_t – FLAP"},{"text":"Uses: iso_fortran_env penf module~~flap_object_t~~UsesGraph module~flap_object_t flap_object_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf penf module~penf->module~flap_object_t module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Base (abstract) class upon which FLAP's concrete classes are built. Used By module~~flap_object_t~~UsedByGraph module~flap_object_t flap_object_t module~flap_command_line_interface_t flap_command_line_interface_t module~flap_object_t->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap program~test_basic test_basic module~flap->program~test_basic program~test_nested test_nested module~flap->program~test_nested program~test_hidden test_hidden module~flap->program~test_hidden program~test_string test_string module~flap->program~test_string program~test_minimal test_minimal module~flap->program~test_minimal program~test_choices_logical test_choices_logical module~flap->program~test_choices_logical var panmoduleflap_object_tUsedByGraph = svgPanZoom('#moduleflap_object_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types object Subroutines free_object print_version print_error_message assign_object Derived Types type, public, abstract :: object Base (abstract) class upon which FLAP's concrete classes are built. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: progname Program name. character(len=:), public, allocatable :: version Program version. character(len=:), public, allocatable :: help Help message. character(len=:), public, allocatable :: help_markdown Longer help message, markdown formatted. character(len=:), public, allocatable :: description Detailed description. character(len=:), public, allocatable :: license License description. character(len=:), public, allocatable :: authors Authors list. character(len=:), public, allocatable :: epilog Epilogue message. character(len=:), public, allocatable :: m_exclude Mutually exclude other CLA(s group). character(len=:), public, allocatable :: error_message Meaningful error message to standard-error. integer(kind=I4P), public :: error = 0_I4P Error trapping flag. integer(kind=I4P), public :: usage_lun = stderr Output unit to print help/usage messages integer(kind=I4P), public :: version_lun = stdout Output unit to print version message integer(kind=I4P), public :: error_lun = stderr Error unit to print error messages Type-Bound Procedures procedure, public :: free_object Free dynamic memory. procedure, public :: print_version Print version. procedure, public :: print_error_message Print meaningful error message. procedure, public :: assign_object Assignment overloading. Subroutines private elemental subroutine free_object (self) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: self Object data. private subroutine print_version (self, pref) Print version. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. character(len=*), intent(in), optional :: pref Prefixing string. private subroutine print_error_message (self) Print meaningful error message to standard-error. Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: self Object data. private elemental subroutine assign_object (lhs, rhs) Assign two abstract objects. Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: lhs Left hand side. class( object ), intent(in) :: rhs Rigth hand side.","tags":"","loc":"module/flap_object_t.html","title":"flap_object_t – FLAP"},{"text":"Uses: penf module~~flap_utils_m~~UsesGraph module~flap_utils_m flap_utils_m module~penf penf module~penf->module~flap_utils_m module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLAP utils. Used By module~~flap_utils_m~~UsedByGraph module~flap_utils_m flap_utils_m module~flap_command_line_interface_t flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~flap_utils_m->module~flap_command_line_argument_t module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t program~test_basic test_basic module~flap->program~test_basic program~test_nested test_nested module~flap->program~test_nested program~test_hidden test_hidden module~flap->program~test_hidden program~test_string test_string module~flap->program~test_string program~test_minimal test_minimal module~flap->program~test_minimal program~test_choices_logical test_choices_logical module~flap->program~test_choices_logical module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap var panmoduleflap_utils_mUsedByGraph = svgPanZoom('#moduleflap_utils_mUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces count Functions count_substring replace replace_all unique upper_case wstrip Subroutines tokenize Interfaces public interface count Overload intrinsic function count for counting substring occurences into strings. private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Functions private elemental function count_substring (string, substring) result(No) Count the number of occurences of a substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. public pure function replace (string, substring, restring) result(newstring) Replace substring (only first occurrence) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. public pure function replace_all (string, substring, restring) result(newstring) Replace substring (all occurrences) into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. character(len=*), intent(in) :: substring Substring to be replaced. character(len=*), intent(in) :: restring String to be inserted. Return Value character(len=:),\n  allocatable New modified string. public elemental function unique (string, substring) result(uniq) Reduce to one (unique) multiple (sequential) occurrences of a characters substring into a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be parsed. character(len=*), intent(in) :: substring Substring which multiple occurences must be reduced to one. Return Value character(len=len(string)) String parsed. public elemental function upper_case (string) Convert the lower case characters of a string to upper case one. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be converted. Return Value character(len=len(string)) Converted string. public pure function wstrip (string) result(newstring) Strip out leading and trailing white spaces from a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be modified. Return Value character(len=:),\n  allocatable New modified string. Subroutines public pure subroutine tokenize (strin, delimiter, toks, Nt) Tokenize a string in order to parse it. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strin String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(strin)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I4P), intent(out), optional :: Nt Number of tokens.","tags":"","loc":"module/flap_utils_m.html","title":"flap_utils_m – FLAP"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Portability Environment for Fortran poor people. Used By module~~penf~~UsedByGraph module~penf penf program~test_basic test_basic module~penf->program~test_basic program~test_nested test_nested module~penf->program~test_nested program~test_choices_logical test_choices_logical module~penf->program~test_choices_logical program~test_hidden test_hidden module~penf->program~test_hidden program~compact_real compact_real module~penf->program~compact_real module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t program~test_all test_all module~penf->program~test_all module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t program~test_string test_string module~penf->program~test_string module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m program~test_minimal test_minimal module~penf->program~test_minimal module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap->program~test_basic module~flap->program~test_nested module~flap->program~test_choices_logical module~flap->program~test_hidden module~flap->program~test_string module~flap->program~test_minimal var panmodulepenfUsedByGraph = svgPanZoom('#modulepenfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size digit Functions digit_I8 digit_I4 digit_I2 digit_I1 Subroutines check_endian penf_init penf_print Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Functions private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Subroutines public subroutine check_endian () Check the type of bit ordering (big or little endian) of the running architecture. Arguments None public subroutine penf_init () Initialize PENF's variables that are not initialized into the definition specification. Arguments None public subroutine penf_print (unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message.","tags":"","loc":"module/penf.html","title":"penf – FLAP"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF bit/byte size functions. Used By module~~penf_b_size~~UsedByGraph module~penf_b_size penf_b_size module~penf penf module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify program~test_basic test_basic module~penf->program~test_basic program~test_nested test_nested module~penf->program~test_nested program~test_choices_logical test_choices_logical module~penf->program~test_choices_logical program~test_hidden test_hidden module~penf->program~test_hidden program~compact_real compact_real module~penf->program~compact_real module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t program~test_all test_all module~penf->program~test_all module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t program~test_string test_string module~penf->program~test_string module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m program~test_minimal test_minimal module~penf->program~test_minimal module~penf_stringify->module~penf module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap->program~test_basic module~flap->program~test_nested module~flap->program~test_choices_logical module~flap->program~test_hidden module~flap->program~test_string module~flap->program~test_minimal var panmodulepenf_b_sizeUsedByGraph = svgPanZoom('#modulepenf_b_sizeUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size byte_size Functions bit_size_R16P bit_size_R8P bit_size_R4P bit_size_chr byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R16P byte_size_R8P byte_size_R4P byte_size_chr Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Functions private elemental function bit_size_R16P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R16P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size – FLAP"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf penf module~penf_global_parameters_variables->module~penf module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify program~test_basic test_basic module~penf->program~test_basic program~test_nested test_nested module~penf->program~test_nested program~test_choices_logical test_choices_logical module~penf->program~test_choices_logical program~test_hidden test_hidden module~penf->program~test_hidden program~compact_real compact_real module~penf->program~compact_real module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t program~test_all test_all module~penf->program~test_all module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t program~test_string test_string module~penf->program~test_string module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m program~test_minimal test_minimal module~penf->program~test_minimal module~penf_stringify->module~penf module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap->program~test_basic module~flap->program~test_nested module~flap->program~test_choices_logical module~flap->program~test_hidden module~flap->program~test_string module~flap->program~test_minimal var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables is_initialized endianL endianB endian R16P R8P R4P R_P I8P I4P I2P I1P I_P FR16P FR8P FR4P FR_P FI8P FI8PZP FI4P FI4PZP FI2P FI2PZP FI1P FI1PZP FI_P FI_PZP DR16P DR8P DR4P DR_P DI8P DI4P DI2P DI1P DI_P REAL_KINDS_LIST REAL_FORMATS_LIST INTEGER_KINDS_LIST INTEGER_FORMATS_LIST MinR16P MaxR16P MinR8P MaxR8P MinR4P MaxR4P MinR_P MaxR_P MinI8P MinI4P MinI2P MinI1P MinI_P MaxI8P MaxI4P MaxI2P MaxI1P MaxI_P smallR16P smallR8P smallR4P smallR_P ZeroR16 ZeroR8 ZeroR4 Zero BIR16P BIR8P BIR4P BIR_P BYR16P BYR8P BYR4P BYR_P BII8P BII4P BII2P BII1P BII_P BYI8P BYI4P BYI2P BYI1P BYI_P Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables – FLAP"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_b_size->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf penf module~penf_stringify->module~penf program~test_basic test_basic module~penf->program~test_basic program~test_nested test_nested module~penf->program~test_nested program~test_choices_logical test_choices_logical module~penf->program~test_choices_logical program~test_hidden test_hidden module~penf->program~test_hidden program~compact_real compact_real module~penf->program~compact_real module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t program~test_all test_all module~penf->program~test_all module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t program~test_string test_string module~penf->program~test_string module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m program~test_minimal test_minimal module~penf->program~test_minimal module~flap flap module~flap_command_line_interface_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_command_line_arguments_group_t->module~flap module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_arguments_group_t module~flap_object_t->module~flap_command_line_argument_t module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_argument_t->module~flap module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap->program~test_basic module~flap->program~test_nested module~flap->program~test_choices_logical module~flap->program~test_hidden module~flap->program~test_string module~flap->program~test_minimal var panmodulepenf_stringifyUsedByGraph = svgPanZoom('#modulepenf_stringifyUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces str strz cton bstr bcton Functions strf_R16P strf_R8P strf_R4P strf_I8P strf_I4P strf_I2P strf_I1P str_R16P str_R8P str_R4P str_I8P str_I4P str_I2P str_I1P str_bol str_a_R16P str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P strz_I8P strz_I4P strz_I2P strz_I1P ctor_R16P ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P bstr_R16P bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P bctor_R16P bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Subroutines compact_real_string Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Functions private elemental function strf_R16P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_R16P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R16P (n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private function ctor_R16P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. private elemental function bstr_R16P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. private elemental function bctor_R16P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Subroutines private pure subroutine compact_real_string (string) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify – FLAP"},{"text":"Uses: flap penf program~~test_basic~~UsesGraph program~test_basic test_basic module~flap flap module~flap->program~test_basic module~penf penf module~penf->program~test_basic module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramtest_basicUsesGraph = svgPanZoom('#programtest_basicUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~test_basic~~CallsGraph program~test_basic test_basic interface~str str program~test_basic->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables cli sval rval prval ival ieval envi bval vbval ilist vlistR8P vlistR4P vlistI8P vlistI4P vlistI2P vlistI1P vlistBool vlistChar garbage error l Source Code test_basic Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. integer(kind=I4P) :: envi Environment set integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. real(kind=R8P), allocatable :: vlistR8P (:) Varying size real list values. real(kind=R4P), allocatable :: vlistR4P (:) Varying size real list values. integer(kind=I8P), allocatable :: vlistI8P (:) Varying size integer list values. integer(kind=I4P), allocatable :: vlistI4P (:) Varying size integer list values. integer(kind=I2P), allocatable :: vlistI2P (:) Varying size integer list values. integer(kind=I1P), allocatable :: vlistI1P (:) Varying size integer list values. logical, allocatable :: vlistBool (:) Varying size boolean list values. character(len=10), allocatable :: vlistChar (:) Varying size character list values. character(len=99), allocatable :: garbage (:) Varying size character list for trailing garbage values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program test_basic !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. integer ( I4P ) :: envi !< Environment set integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. real ( R8P ), allocatable :: vlistR8P (:) !< Varying size real list values. real ( R4P ), allocatable :: vlistR4P (:) !< Varying size real list values. integer ( I8P ), allocatable :: vlistI8P (:) !< Varying size integer list values. integer ( I4P ), allocatable :: vlistI4P (:) !< Varying size integer list values. integer ( I2P ), allocatable :: vlistI2P (:) !< Varying size integer list values. integer ( I1P ), allocatable :: vlistI1P (:) !< Varying size integer list values. logical , allocatable :: vlistBool (:) !< Varying size boolean list values. character ( 10 ), allocatable :: vlistChar (:) !< Varying size character list values. character ( 99 ), allocatable :: garbage (:) !< Varying size character list for trailing garbage values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize Command Line Interface call cli % init ( progname = 'test_basic' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & help = 'Usage: ' , & description = 'Toy program for testing FLAP' , & examples = [ \"test_basic -s 'Hello FLAP'                               \" , & \"test_basic -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_basic -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_basic -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_basic -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_basic -s 'Hello FLAP' --man_file FLAP.1             \" , & \"test_basic 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_basic --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Argumenst call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) if ( error /= 0 ) stop call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--env' , switch_ab = '-e' , help = 'Environment input' , required = . false ., act = 'store' , def = '-1' , envvar = 'FLAP_NUM_INT' ,& error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--man_file' , help = 'Save manual into man_file' , required = . false ., act = 'store' , def = 'test_basic.1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR8P' , switch_ab = '-vlR8P' , help = 'Varying size real R8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listR4P' , switch_ab = '-vlR4P' , help = 'Varying size real R4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1.0 2.0 3.0 4.0' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI8P' , switch_ab = '-vlI8P' , help = 'Varying size integer I8P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4 5 6 7 8' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI4P' , switch_ab = '-vlI4P' , help = 'Varying size integer I4P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2 3 4' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI2P' , switch_ab = '-vlI2P' , help = 'Varying size integer I2P list input' , required = . false ., act = 'store' ,& nargs = '*' , def = '1 2' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listI1P' , switch_ab = '-vlI1P' , help = 'Varying size integer I1P list input' , required = . false ., act = 'store' ,& nargs = '+' , def = '1' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listBool' , switch_ab = '-vlBool' , help = 'Varying size boolean list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'T F T T F' , error = error ) if ( error /= 0 ) stop call cli % add ( switch = '--varying_listChar' , switch_ab = '-vlChar' , help = 'Varying size character list input' , required = . false ., act = 'store' ,& nargs = '*' , def = 'foo bar baz' , error = error ) if ( error /= 0 ) stop ! parse Command Line Interface ! this is optional: if skipped the first call to cli%get will automatically call cli%parse call cli % parse ( error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_basic behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-e' , val = envi , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR8P' , val = vlistR8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlR4P' , val = vlistR4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI8P' , val = vlistI8P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI4P' , val = vlistI4P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI2P' , val = vlistI2P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlI1P' , val = vlistI1P , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlBool' , val = vlistBool , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '-vlChar' , val = vlistChar , error = error ) ; if ( error /= 0 ) stop call cli % get_varying ( switch = '--' , val = garbage , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_basic has been called with the following arguments values:' print '(A)' , 'String              input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real                input = ' // str ( n = rval ) print '(A)' , 'Integer             input = ' // str ( n = ival ) print '(A)' , 'Exclusive   integer input = ' // str ( n = ieval ) print '(A)' , 'Environment integer input = ' // str ( n = envi ) print '(A,L1)' , 'Boolean             input = ' , bval print '(A,L1)' , 'Valued boolean      input = ' , vbval print '(A)' , 'Positional real     input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo if ( allocated ( vlistR8P )) then print '(A)' , 'Varying size real R8P list inputs:' do l = 1 , size ( vlistR8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R8P list!' endif if ( allocated ( vlistR4P )) then print '(A)' , 'Varying size real R4P list inputs:' do l = 1 , size ( vlistR4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistR4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size real R4P list!' endif if ( allocated ( vlistI8P )) then print '(A)' , 'Varying size integer I8P list inputs:' do l = 1 , size ( vlistI8P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI8P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I8P list!' endif if ( allocated ( vlistI4P )) then print '(A)' , 'Varying size integer I4P list inputs:' do l = 1 , size ( vlistI4P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI4P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I4P list!' endif if ( allocated ( vlistI2P )) then print '(A)' , 'Varying size integer I2P list inputs:' do l = 1 , size ( vlistI2P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI2P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I2P list!' endif if ( allocated ( vlistI1P )) then print '(A)' , 'Varying size integer I1P list inputs:' do l = 1 , size ( vlistI1P ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = vlistI1P ( l ))) enddo else print '(A)' , 'Problems occuour with varying size integer I1P list!' endif if ( allocated ( vlistBool )) then print '(A)' , 'Varying size boolean list inputs:' do l = 1 , size ( vlistBool ) print '(A,L1)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' , vlistBool ( l ) enddo else print '(A)' , 'Problems occuour with varying size boolean list!' endif if ( allocated ( vlistChar )) then print '(A)' , 'Varying size character list inputs:' do l = 1 , size ( vlistChar ) print '(A)' , '  Input(' // trim ( str ( l , . true .)) // ') = ' // vlistChar ( l ) enddo else print '(A)' , 'Problems occuour with varying size character list!' endif if ( allocated ( garbage )) then print '(A)' , 'You have used implicit \"--\" option for collecting list of \"trailing garbage\" values that are:' do l = 1 , size ( garbage ) print '(A)' , '  Garbage(' // trim ( str ( l , . true .)) // ') = ' // garbage ( l ) enddo endif if ( cli % is_passed ( switch = '--man_file' )) then call cli % get ( switch = '--man_file' , val = sval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'Saving man page' call cli % save_man_page ( error = error , man_file = trim ( adjustl ( sval ))) endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_basic","tags":"","loc":"program/test_basic.html","title":"test_basic – FLAP"},{"text":"Uses: flap penf program~~test_choices_logical~~UsesGraph program~test_choices_logical test_choices_logical module~flap flap module~flap->program~test_choices_logical module~penf penf module~penf->program~test_choices_logical module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramtest_choices_logicalUsesGraph = svgPanZoom('#programtest_choices_logicalUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FLAP for bad usage of choices option with logical Calls program~~test_choices_logical~~CallsGraph program~test_choices_logical test_choices_logical interface~str str program~test_choices_logical->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables cli vbval error Source Code test_choices_logical Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). logical :: vbval Valued-boolean value. integer(kind=I4P) :: error Error trapping flag. Source Code program test_choices_logical !----------------------------------------------------------------------------------------------------------------------------------- !< Test FLAP for bad usage of choices option with logical !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: vbval !< Valued-boolean value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( progname = 'test_choices_logical' ) call cli % add ( switch = '--boolean-value' , switch_ab = '-bv' , help = 'A help message' , & required = . false ., def = '.false.' , choices = '.True.,.False.' , act = 'store' , error = error ) call cli % parse ( error = error ) call cli % get ( switch = '-bv' , val = vbval , error = error ) print \"(A)\" , \"Error code: \" // trim ( str ( error , . true .)) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_choices_logical","tags":"","loc":"program/test_choices_logical.html","title":"test_choices_logical – FLAP"},{"text":"Uses: flap penf program~~test_hidden~~UsesGraph program~test_hidden test_hidden module~flap flap module~flap->program~test_hidden module~penf penf module~penf->program~test_hidden module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramtest_hiddenUsesGraph = svgPanZoom('#programtest_hiddenUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~test_hidden~~CallsGraph program~test_hidden test_hidden interface~str str program~test_hidden->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables cli a_string g_string a_integer error Source Code test_hidden Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: a_string String value. character(len=99) :: g_string Ghost string value. integer(kind=I4P) :: a_integer Integer value. integer(kind=I4P) :: error Error trapping flag. Source Code program test_hidden !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: a_string !< String value. character ( 99 ) :: g_string !< Ghost string value. integer ( I4P ) :: a_integer !< Integer value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( description = 'hiddens usage FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--hidden' , switch_ab = '-hi' , help = 'ghost string' , required = . false ., def = 'gstring not passed' , & hidden = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'a integer' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = a_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-hi' , val = g_string , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = a_integer , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String       = ' // trim ( adjustl ( a_string )) print '(A)' , 'Ghost string = ' // trim ( adjustl ( g_string )) print '(A)' , 'Integer      = ' // trim ( adjustl ( str ( a_integer , . true .))) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_hidden","tags":"","loc":"program/test_hidden.html","title":"test_hidden – FLAP"},{"text":"Uses: flap penf program~~test_minimal~~UsesGraph program~test_minimal test_minimal module~flap flap module~flap->program~test_minimal module~penf penf module~penf->program~test_minimal module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramtest_minimalUsesGraph = svgPanZoom('#programtest_minimalUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Note The minimal steps for using a FLAP CLI are:\n+ init the CLI;\n+ add at least one CLA to the CLI;\n+ get the CLAs defined into the CLI; Note that get automatically calls parse method beacuse it is not explicitely called. Variables cli string error Source Code test_minimal Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: string String value. integer(kind=I4P) :: error Error trapping flag. Source Code program test_minimal !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !< !< @note The minimal steps for using a FLAP CLI are: !<+ `init` the CLI; !<+ `add` at least one CLA to the CLI; !<+ `get` the CLAs defined into the CLI; !< !<Note that `get` automatically calls `parse` method beacuse it is not explicitely called. !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: string !< String value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call cli % init ( description = 'minimal FLAP example' ) call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'a string' , required = . true ., act = 'store' , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-s' , val = string , error = error ) ; if ( error /= 0 ) stop print '(A)' , cli % progname // ' has been called with the following argument:' print '(A)' , 'String = ' // trim ( adjustl ( string )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_minimal","tags":"","loc":"program/test_minimal.html","title":"test_minimal – FLAP"},{"text":"Uses: flap penf program~~test_nested~~UsesGraph program~test_nested test_nested module~flap flap module~flap->program~test_nested module~penf penf module~penf->program~test_nested module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramtest_nestedUsesGraph = svgPanZoom('#programtest_nestedUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~test_nested~~CallsGraph program~test_nested test_nested interface~str str program~test_nested->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables cli authors_print message error Source Code test_nested Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). logical :: authors_print Boolean value. character(len=500) :: message Message value. integer(kind=I4P) :: error Error trapping flag. Source Code program test_nested !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). logical :: authors_print !< Boolean value. character ( 500 ) :: message !< Message value. integer ( I4P ) :: error !< Error trapping flag. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- authors_print = . false . ! initialize Command Line Interface call cli % init ( progname = 'test_nested' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with nested commands' , & examples = [ 'test_nested                      ' , & 'test_nested -h                   ' , & 'test_nested init                 ' , & 'test_nested commit -m \"fix bug-1\"' , & 'test_nested tag -a \"v2.1.5\"      ' ]) ! set a Command Line Argument without a group to trigger authors names printing call cli % add ( switch = '--authors' , switch_ab = '-a' , help = 'Print authors names' , required = . false ., act = 'store_true' , def = '.false.' ) ! set Command Line Arguments Groups, i.e. commands call cli % add_group ( group = 'init' , description = 'fake init versioning' ) call cli % add_group ( group = 'commit' , description = 'fake commit changes to current branch' ) call cli % add_group ( group = 'tag' , description = 'fake tag current commit' ) call cli % set_mutually_exclusive_groups ( group1 = 'init' , group2 = 'commit' ) ! set Command Line Arguments of commit command call cli % add ( group = 'commit' , switch = '--message' , switch_ab = '-m' , help = 'Commit message' , required = . false ., act = 'store' , def = '' ) ! set Command Line Arguments of commit command call cli % add ( group = 'tag' , switch = '--annotate' , switch_ab = '-a' , help = 'Tag annotation' , required = . false ., act = 'store' , def = '' ) ! parse Command Line Interface call cli % parse ( error = error ) if ( error /= 0 ) then print '(A)' , 'Error code: ' // trim ( str ( n = error )) stop endif ! use Command Line Interface data to trigger program behaviour call cli % get ( switch = '-a' , val = authors_print , error = error ) ; if ( error /= 0 ) stop if ( authors_print ) then print '(A)' , 'Authors: ' // cli % authors elseif ( cli % run_command ( 'init' )) then print '(A)' , 'init (fake) versioning' elseif ( cli % run_command ( 'commit' )) then call cli % get ( group = 'commit' , switch = '-m' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'commit changes to current branch with message \"' // trim ( message ) // '\"' elseif ( cli % run_command ( 'tag' )) then call cli % get ( group = 'tag' , switch = '-a' , val = message , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'tag current branch with message \"' // trim ( message ) // '\"' else print '(A)' , 'cowardly you are doing nothing... try at least \"-h\" option!' endif stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_nested","tags":"","loc":"program/test_nested.html","title":"test_nested – FLAP"},{"text":"Uses: flap penf program~~test_string~~UsesGraph program~test_string test_string module~flap flap module~flap->program~test_string module~penf penf module~penf->program~test_string module~flap_command_line_interface_t flap_command_line_interface_t module~penf->module~flap_command_line_interface_t module~flap_command_line_argument_t flap_command_line_argument_t module~penf->module~flap_command_line_argument_t module~flap_command_line_arguments_group_t flap_command_line_arguments_group_t module~penf->module~flap_command_line_arguments_group_t module~flap_utils_m flap_utils_m module~penf->module~flap_utils_m module~flap_object_t flap_object_t module~penf->module~flap_object_t module~flap_command_line_interface_t->module~flap module~flap_command_line_argument_t->module~flap module~flap_command_line_argument_t->module~flap_command_line_interface_t module~flap_command_line_argument_t->module~flap_command_line_arguments_group_t module~flap_command_line_arguments_group_t->module~flap module~flap_command_line_arguments_group_t->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_interface_t module~flap_utils_m->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_interface_t module~flap_object_t->module~flap_command_line_argument_t module~flap_object_t->module~flap_command_line_arguments_group_t iso_fortran_env iso_fortran_env iso_fortran_env->module~flap_object_t module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramtest_stringUsesGraph = svgPanZoom('#programtest_stringUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A testing program for FLAP, Fortran command Line Arguments Parser for poor people Compile See compile instructions . Usage Compile See usage instructions . Calls program~~test_string~~CallsGraph program~test_string test_string interface~str str program~test_string->interface~str proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables cli sval rval prval ival ieval bval vbval ilist error l Source Code test_string Variables Type Attributes Name Initial type( command_line_interface ) :: cli Command Line Interface (CLI). character(len=99) :: sval String value. real(kind=R8P) :: rval Real value. real(kind=R8P) :: prval Positional real value. integer(kind=I4P) :: ival Integer value. integer(kind=I4P) :: ieval Exclusive integer value. logical :: bval Boolean value. logical :: vbval Valued-boolean value. integer(kind=I8P) :: ilist (1:3) Integer list values. integer(kind=I4P) :: error Error trapping flag. integer(kind=I4P) :: l Counter. Source Code program test_string !< A testing program for FLAP, Fortran command Line Arguments Parser for poor people !< !<### Compile !< See [compile instructions](https://github.com/szaghi/FLAP/wiki/Download-compile). !< !<###Usage Compile !< See [usage instructions](https://github.com/szaghi/FLAP/wiki/Testing-Programs). !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command Line Interface (CLI). character ( 99 ) :: sval !< String value. real ( R8P ) :: rval !< Real value. real ( R8P ) :: prval !< Positional real value. integer ( I4P ) :: ival !< Integer value. integer ( I4P ) :: ieval !< Exclusive integer value. logical :: bval !< Boolean value. logical :: vbval !< Valued-boolean value. integer ( I8P ) :: ilist ( 1 : 3 ) !< Integer list values. integer ( I4P ) :: error !< Error trapping flag. integer ( I4P ) :: l !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! initialize Command Line Interface call cli % init ( progname = 'test_sting' , & version = 'v2.1.5' , & authors = 'Stefano Zaghi' , & license = 'MIT' , & description = 'Toy program for testing FLAP with a fake string input' , & examples = [ \"test_sting -s 'Hello FLAP'                               \" , & \"test_sting -s 'Hello FLAP' -i -2 # printing error...     \" , & \"test_sting -s 'Hello FLAP' -i 3 -ie 1 # printing error...\" , & \"test_sting -s 'Hello FLAP' -i 3 -r 33.d0                 \" , & \"test_sting -s 'Hello FLAP' --integer_list 10 -3 87       \" , & \"test_sting 33.0 -s 'Hello FLAP' -i 5                     \" , & \"test_sting --string 'Hello FLAP' --boolean               \" ],& epilog = new_line ( 'a' ) // \"And that's how to FLAP your life\" ) ! set Command Line Arguments call cli % add ( switch = '--string' , switch_ab = '-s' , help = 'String input' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--integer_ex' , switch_ab = '-ie' , help = 'Exclusive integer input' , required = . false ., act = 'store' , def = '-1' , error = error ) call cli % add ( switch = '--integer' , switch_ab = '-i' , help = 'Integer input with fixed range' , required = . false ., act = 'store' ,& def = '1' , choices = '1,3,5' , exclude = '-ie' , error = error ) call cli % add ( switch = '--real' , switch_ab = '-r' , help = 'Real input' , required = . false ., act = 'store' , def = '1.0' , error = error ) call cli % add ( switch = '--boolean' , switch_ab = '-b' , help = 'Boolean input' , required = . false ., act = 'store_true' , def = '.false.' ,& error = error ) call cli % add ( switch = '--boolean_val' , switch_ab = '-bv' , help = 'Valued boolean input' , required = . false ., act = 'store' ,& def = '.true.' , error = error ) call cli % add ( switch = '--integer_list' , switch_ab = '-il' , help = 'Integer list input' , required = . false ., act = 'store' ,& nargs = '3' , def = '1 8 32' , error = error ) call cli % add ( positional = . true ., position = 1 , help = 'Positional real input' , required = . false ., def = '1.0' , error = error ) ! parse Command Line Interface call cli % parse ( args = \"-s 'FAKE INVOCATION FROM STRING' --integer_list 10 -3 87\" , error = error ) if ( error /= 0 ) stop ! use Command Line Interface data to set test_string behaviour call cli % get ( switch = '-s' , val = sval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = rval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-i' , val = ival , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-ie' , val = ieval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-b' , val = bval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-bv' , val = vbval , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-il' , val = ilist , error = error ) ; if ( error /= 0 ) stop call cli % get ( position = 1_I4P , val = prval , error = error ) ; if ( error /= 0 ) stop print '(A)' , 'test_string has been called with the following arguments values:' print '(A)' , 'String            input = ' // trim ( adjustl ( sval )) print '(A)' , 'Real              input = ' // str ( n = rval ) print '(A)' , 'Integer           input = ' // str ( n = ival ) print '(A)' , 'Exclusive integer input = ' // str ( n = ieval ) print '(A,L1)' , 'Boolean           input = ' , bval print '(A,L1)' , 'Valued boolean    input = ' , vbval print '(A)' , 'Positional real   input = ' // str ( n = prval ) print '(A)' , 'Integer list inputs:' do l = 1 , 3 print '(A)' , 'Input(' // trim ( str ( l , . true .)) // ') = ' // trim ( str ( n = ilist ( l ))) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_string","tags":"","loc":"program/test_string.html","title":"test_string – FLAP"},{"text":"Uses: penf iso_fortran_env program~~compact_real~~UsesGraph program~compact_real compact_real iso_fortran_env iso_fortran_env iso_fortran_env->program~compact_real module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf penf module~penf->program~compact_real module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF's testing program. Calls program~~compact_real~~CallsGraph program~compact_real compact_real proc~penf_init penf_init program~compact_real->proc~penf_init interface~str str program~compact_real->interface~str proc~check_endian check_endian proc~penf_init->proc~check_endian proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables test_passed Source Code compact_real Variables Type Attributes Name Initial logical :: test_passed (3) List of passed tests. Source Code program compact_real !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init test_passed = . false . test_passed ( 1 ) = trim ( str ( n = 1._R8P , compact = . true .)) == '+0.1E+1' print \"(A,L1)\" , 'Compact 1.0: ' // trim ( str ( n = 1._R8P , compact = . true .)) // ', is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) == '+0.333333E+0' print \"(A,L1)\" , 'Compact 1.0/3.0: ' // trim ( str ( n = 1._R4P / 3._R4P , compact = . true .)) // ', is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) == '+0.25E+0' print \"(A,L1)\" , 'Compact 1.0/4.0: ' // trim ( str ( n = 1._R16P / 4._R16P , compact = . true .)) // ', is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram compact_real","tags":"","loc":"program/compact_real.html","title":"compact_real – FLAP"},{"text":"Uses: penf iso_fortran_env program~~test_all~~UsesGraph program~test_all test_all iso_fortran_env iso_fortran_env iso_fortran_env->program~test_all module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf penf module~penf->program~test_all module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF's testing program. Usage ./test_all Calls program~~test_all~~CallsGraph program~test_all test_all interface~digit digit program~test_all->interface~digit interface~strz strz program~test_all->interface~strz proc~penf_print penf_print program~test_all->proc~penf_print interface~cton cton program~test_all->interface~cton interface~bstr bstr program~test_all->interface~bstr interface~bcton bcton program~test_all->interface~bcton interface~str str program~test_all->interface~str proc~penf_init penf_init program~test_all->proc~penf_init proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~check_endian check_endian proc~penf_init->proc~check_endian proc~bctor_r4p->interface~str proc~bctoi_i4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i8p->interface~str proc~str_a_i2p->proc~str_i2p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i8p->proc~str_i8p var panprogramtest_allCallsGraph = svgPanZoom('#programtest_allCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_all Source Code program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_init call penf_print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"program/test_all.html","title":"test_all – FLAP"}]}